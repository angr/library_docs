[{"name": "Algorithms", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nqsortqsort_s\n(C11)   sorts a range of elements with unspecified type  (function)\nbsearchbsearch_s\n(C11)   searches an array for an element of unspecified type  (function)\n\n", "url": "https://devdocs.io/c/algorithm\n"}, {"name": "bsearch, bsearch_s", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid* bsearch( const void *key, const void *ptr, size_t count, size_t size,\n               int (*comp)(const void*, const void*) );\n  (1)\nvoid* bsearch_s( const void *key, const void *ptr, rsize_t count, rsize_t size,\n                 int (*comp)(const void *, const void *, void *),\n                 void *context );\n  (2)   (since C11)\n\n   If the array contains several elements that comp would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.\n\nParameters\nkey   -   pointer to the element to search for\nptr   -   pointer to the array to examine\ncount   -   number of element in the array\nsize   -   size of each element in the array in bytes\ncomp   -   comparison function which returns \u200ba negative integer value if the first argument is less than the second,  a positive integer value if the first argument is greater than the second and zero if the arguments are equal. key is passed as the first argument, an element from the array as the second. The signature of the comparison function should be equivalent to the following:\n int cmp(const void *a, const void *b);\nThe function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.\n\u200b\ncontext   -   additional information (e.g., collating sequence), passed to comp as the third argument\n\n\nReturn value\n\nNotes\n   Despite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.\n   Unlike other bounds-checked functions, bsearch_s does not treat arrays of zero size as a runtime constraint violation and instead indicates element not found (the other function that accepts arrays of zero size is qsort_s).\n   Until bsearch_s, users of bsearch often used global variables to pass additional context to the comparison function.\n", "url": "https://devdocs.io/c/algorithm/bsearch\n"}, {"name": "qsort, qsort_s", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid qsort( void *ptr, size_t count, size_t size,\n            int (*comp)(const void *, const void *) );\n  (1)\nerrno_t qsort_s( void *ptr, rsize_t count, rsize_t size,\n                 int (*comp)(const void *, const void *, void *),\n                 void *context );\n  (2)   (since C11)\n\n   If comp indicates two elements as equivalent, their order in the resulting sorted array is unspecified.\n\nParameters\nptr   -   pointer to the array to sort\ncount   -   number of element in the array\nsize   -   size of each element in the array in bytes\ncomp   -   comparison function which returns \u200ba negative integer value if the first argument is less than the second,  a positive integer value if the first argument is greater than the second and zero if the arguments are equal. The signature of the comparison function should be equivalent to the following:\n int cmp(const void *a, const void *b);\nThe function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.\n\u200b\ncontext   -   additional information (e.g., collating sequence), passed to comp as the third argument\n\n\nReturn value\n\nNotes\n   Despite the name, neither C nor POSIX standards require this function to be implemented using quicksort or make any complexity or stability guarantees.\n   Unlike other bounds-checked functions, qsort_s does not treat arrays of zero size as a runtime constraint violation and instead returns successfully without altering the array (the other function that accepts arrays of zero size is bsearch_s).\n   Until qsort_s, users of qsort often used global variables to pass additional context to the comparison function.\n", "url": "https://devdocs.io/c/algorithm/qsort\n"}, {"name": "Atomic operations library", "type": "STANDARD LIB", "description": "   If the macro constant __STDC_NO_ATOMICS__(C11) is defined by the compiler, the header <stdatomic.h>, the keyword _Atomic, and all of the names listed here are not provided.\n\nTypes\nDefined in header <stdatomic.h>\nmemory_order\n(C11)   defines memory ordering constraints  (enum)\natomic_flag\n(C11)   lock-free atomic boolean flag  (struct)\n\n\nMacros\nDefined in header <stdatomic.h>\nATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE\n(C11)   indicates that the given atomic type is lock-free  (macro constant)\nATOMIC_FLAG_INIT\n(C11)   initializes a new atomic_flag  (macro constant)\nATOMIC_VAR_INIT\n(C11)(deprecated in C17)   initializes a new atomic object  (function macro)\nkill_dependency\n(C11)   breaks a dependency chain for memory_order_consume  (function macro)\n\n\nFunctions\nDefined in header <stdatomic.h>\natomic_flag_test_and_setatomic_flag_test_and_set_explicit\n(C11)   sets an atomic_flag to true and returns the old value  (function)\natomic_flag_clearatomic_flag_clear_explicit\n(C11)   sets an atomic_flag to false  (function)\natomic_init\n(C11)   initializes an existing atomic object  (function)\natomic_is_lock_free\n(C11)   indicates whether the atomic object is lock-free  (function)\natomic_storeatomic_store_explicit\n(C11)   stores a value in an atomic object  (function)\natomic_loadatomic_load_explicit\n(C11)   reads a value from an atomic object  (function)\natomic_exchangeatomic_exchange_explicit\n(C11)   swaps a value with the value of an atomic object  (function)\natomic_compare_exchange_strongatomic_compare_exchange_strong_explicitatomic_compare_exchange_weakatomic_compare_exchange_weak_explicit\n(C11)   swaps a value with the an atomic object if the old value is what is expected, otherwise reads the old value  (function)\natomic_fetch_addatomic_fetch_add_explicit\n(C11)   atomic addition  (function)\natomic_fetch_subatomic_fetch_sub_explicit\n(C11)   atomic subtraction  (function)\natomic_fetch_oratomic_fetch_or_explicit\n(C11)   atomic bitwise OR  (function)\natomic_fetch_xoratomic_fetch_xor_explicit\n(C11)   atomic bitwise exclusive OR  (function)\natomic_fetch_andatomic_fetch_and_explicit\n(C11)   atomic bitwise AND  (function)\natomic_thread_fence\n(C11)   generic memory order-dependent fence synchronization primitive  (function)\natomic_signal_fence\n(C11)   fence between a thread and a signal handler executed in the same thread  (function)\n\n\nTypes\n   The standard library offers convenience typedefs for the core language atomic types.\nTypedef name   Full type name\natomic_bool   _Atomic _Bool\natomic_char   _Atomic char\natomic_schar   _Atomic signed char\natomic_uchar   _Atomic unsigned char\natomic_short   _Atomic short\natomic_ushort   _Atomic unsigned short\natomic_int   _Atomic int\natomic_uint   _Atomic unsigned int\natomic_long   _Atomic long\natomic_ulong   _Atomic unsigned long\natomic_llong   _Atomic long long\natomic_ullong   _Atomic unsigned long long\natomic_char16_t   _Atomic char16_t\natomic_char32_t   _Atomic char32_t\natomic_wchar_t   _Atomic wchar_t\natomic_int_least8_t   _Atomic int_least8_t\natomic_uint_least8_t   _Atomic uint_least8_t\natomic_int_least16_t   _Atomic int_least16_t\natomic_uint_least16_t   _Atomic uint_least16_t\natomic_int_least32_t   _Atomic int_least32_t\natomic_uint_least32_t   _Atomic uint_least32_t\natomic_int_least64_t   _Atomic int_least64_t\natomic_uint_least64_t   _Atomic uint_least64_t\natomic_int_fast8_t   _Atomic int_fast8_t\natomic_uint_fast8_t   _Atomic uint_fast8_t\natomic_int_fast16_t   _Atomic int_fast16_t\natomic_uint_fast16_t   _Atomic uint_fast16_t\natomic_int_fast32_t   _Atomic int_fast32_t\natomic_uint_fast32_t   _Atomic uint_fast32_t\natomic_int_fast64_t   _Atomic int_fast64_t\natomic_uint_fast64_t   _Atomic uint_fast64_t\natomic_intptr_t   _Atomic intptr_t\natomic_uintptr_t   _Atomic uintptr_t\natomic_size_t   _Atomic size_t\natomic_ptrdiff_t   _Atomic ptrdiff_t\natomic_intmax_t   _Atomic intmax_t\natomic_uintmax_t   _Atomic uintmax_t\n\n", "url": "https://devdocs.io/c/atomic\n"}, {"name": "ATOMIC_*_LOCK_FREE", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\n#define ATOMIC_BOOL_LOCK_FREE     /* implementation-defined */\n#define ATOMIC_CHAR_LOCK_FREE     /* implementation-defined */\n#define ATOMIC_CHAR16_T_LOCK_FREE /* implementation-defined */\n#define ATOMIC_CHAR32_T_LOCK_FREE /* implementation-defined */\n#define ATOMIC_WCHAR_T_LOCK_FREE  /* implementation-defined */\n#define ATOMIC_SHORT_LOCK_FREE    /* implementation-defined */\n#define ATOMIC_INT_LOCK_FREE      /* implementation-defined */\n#define ATOMIC_LONG_LOCK_FREE     /* implementation-defined */\n#define ATOMIC_LLONG_LOCK_FREE    /* implementation-defined */\n#define ATOMIC_POINTER_LOCK_FREE  /* implementation-defined */\n    (since C11)\n\n   Expands to preprocessor constant expressions that evaluate to either 0, 1, or 2 which indicate the lock-free property of the corresponding atomic types (both signed and unsigned).\nValue   Explanation\n0   The atomic type is never lock-free\n1   The atomic type is sometimes lock-free\n2   The atomic type is always lock-free\n\n", "url": "https://devdocs.io/c/atomic/atomic_lock_free_consts\n"}, {"name": "atomic_compare_exchange_weak, atomic_compare_exchange_strong, atomic_compare_exchange_weak_explicit, atomic_compare_exchange_strong_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\n_Bool atomic_compare_exchange_strong( volatile A* obj,\n                                      C* expected, C desired );\n  (1)   (since C11)\n_Bool atomic_compare_exchange_weak( volatile A *obj, \n                                    C* expected, C desired );\n  (2)   (since C11)\n_Bool atomic_compare_exchange_strong_explicit( volatile A* obj, \n                                               C* expected, C desired,\n                                               memory_order succ, \n                                               memory_order fail );\n  (3)   (since C11)\n_Bool atomic_compare_exchange_weak_explicit( volatile A *obj, \n                                             C* expected, C desired,\n                                             memory_order succ, \n                                             memory_order fail );\n  (4)   (since C11)\n\n   Atomically compares the contents of memory pointed to by obj with the contents of memory pointed to by expected, and if those are bitwise equal, replaces the former with desired (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by obj into *expected (performs load operation).\n   The memory models for the read-modify-write and load operations are succ and fail respectively. The (1-2) versions use memory_order_seq_cst by default.\n   The weak forms ((2) and (4)) of the functions are allowed to fail spuriously, that is, act as if *obj != *expected even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.C is the non-atomic type corresponding to A.\n\nParameters\nobj   -   pointer to the atomic object to test and modify\nexpected   -   pointer to the value expected to be found in the atomic object\ndesired   -   the value to store in the atomic object if it is as expected\nsucc   -   the memory synchronization ordering for the read-modify-write operation if the comparison succeeds. All values are permitted.\nfail   -   the memory synchronization ordering for the load operation if the comparison fails. Cannot be memory_order_release or memory_order_acq_rel and cannot specify stronger ordering than succ\n\n\nReturn value\n   The result of the comparison: true if *obj was equal to *exp, false otherwise.\n\nNotes\n   The behavior of atomic_compare_exchange_strong is as if the following was executed atomically:\n", "url": "https://devdocs.io/c/atomic/atomic_compare_exchange\n"}, {"name": "atomic_exchange, atomic_exchange_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nC atomic_exchange( volatile A* obj, C desired );\n  (1)   (since C11)\nC atomic_exchange_explicit( volatile A* obj, C desired, memory_order order );\n  (2)   (since C11)\n\n   Atomically replaces the value pointed by obj with desired and returns the value obj held previously. The operation is read-modify-write operation. The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.C is the non-atomic type corresponding to A..\n\nParameters\nobj   -   pointer to the atomic object to modify\ndesired   -   the value to replace the atomic object with\norder   -   the memory synchronization ordering for this operation: all values are permitted\n\n\nReturn value\n   The value held previously be the atomic object pointed to by obj.\n", "url": "https://devdocs.io/c/atomic/atomic_exchange\n"}, {"name": "atomic_fetch_add, atomic_fetch_add_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nC atomic_fetch_add( volatile A* obj, M arg );\n  (1)   (since C11)\nC atomic_fetch_add_explicit( volatile A* obj, M arg, memory_order order );\n  (2)   (since C11)\n\n   Atomically replaces the value pointed by obj with the result of addition of arg to the old value of obj, and returns the value obj held previously. The operation is read-modify-write operation. The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.M is either the non-atomic type corresponding to A if A is atomic integer type, or ptrdiff_t if A is atomic pointer type.\n   For signed integer types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.\n\nParameters\nobj   -   pointer to the atomic object to modify\narg   -   the value to add to the value stored in the atomic object\norder   -   the memory synchronization ordering for this operation: all values are permitted\n\n\nReturn value\n   The value held previously be the atomic object pointed to by obj.\n", "url": "https://devdocs.io/c/atomic/atomic_fetch_add\n"}, {"name": "atomic_fetch_and, atomic_fetch_and_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nC atomic_fetch_and( volatile A* obj, M arg );\n  (1)   (since C11)\nC atomic_fetch_and_explicit( volatile A* obj, M arg, memory_order order );\n  (2)   (since C11)\n\n   Atomically replaces the value pointed by obj with the result of bitwise AND between the old value of obj and arg, and returns the value obj held previously. The operation is read-modify-write operation. The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.M is either the non-atomic type corresponding to A if A is atomic integer type, or ptrdiff_t if A is atomic pointer type.\n\nParameters\nobj   -   pointer to the atomic object to modify\narg   -   the value to bitwise AND to the value stored in the atomic object\norder   -   the memory sycnhronization ordering for this operation: all values are permitted\n\n\nReturn value\n   The value held previously be the atomic object pointed to by obj.\n", "url": "https://devdocs.io/c/atomic/atomic_fetch_and\n"}, {"name": "atomic_fetch_or, atomic_fetch_or_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nC atomic_fetch_or( volatile A* obj, M arg );\n  (1)   (since C11)\nC atomic_fetch_or_explicit( volatile A* obj, M arg, memory_order order );\n  (2)   (since C11)\n\n   Atomically replaces the value pointed by obj with the result of bitwise OR between the old value of obj and arg, and returns the value obj held previously. The operation is read-modify-write operation. The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.M is either the non-atomic type corresponding to A if A is atomic integer type, or ptrdiff_t if A is atomic pointer type.\n\nParameters\nobj   -   pointer to the atomic object to modify\narg   -   the value to bitwise OR to the value stored in the atomic object\norder   -   the memory synchronization ordering for this operation: all values are permitted\n\n\nReturn value\n   The value held previously be the atomic object pointed to by obj.\n", "url": "https://devdocs.io/c/atomic/atomic_fetch_or\n"}, {"name": "atomic_fetch_sub, atomic_fetch_sub_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nC atomic_fetch_sub( volatile A* obj, M arg );\n  (1)   (since C11)\nC atomic_fetch_sub_explicit( volatile A* obj, M arg, memory_order order );\n  (2)   (since C11)\n\n   Atomically replaces the value pointed by obj with the result of subtraction of arg from the old value of obj, and returns the value obj held previously. The operation is read-modify-write operation. The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.M is either the non-atomic type corresponding to A if A is atomic integer type, or ptrdiff_t if A is atomic pointer type.\n   For signed integer types, arithmetic is defined to use two\u2019s complement representation. There are no undefined results. For pointer types, the result may be an undefined address, but the operations otherwise have no undefined behavior.\n\nParameters\nobj   -   pointer to the atomic object to modify\narg   -   the value to subtract from the value stored in the atomic object\norder   -   the memory synchronization ordering for this operation: all values are permitted\n\n\nReturn value\n   The value held previously by the atomic object pointed to by obj.\n", "url": "https://devdocs.io/c/atomic/atomic_fetch_sub\n"}, {"name": "atomic_fetch_xor, atomic_fetch_xor_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nC atomic_fetch_xor( volatile A* obj, M arg );\n  (1)   (since C11)\nC atomic_fetch_xor_explicit( volatile A* obj, M arg, memory_order order );\n  (2)   (since C11)\n\n   Atomically replaces the value pointed by obj with the result of bitwise XOR between the old value of obj and arg, and returns the value obj held previously. The operation is read-modify-write operation. The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.M is either the non-atomic type corresponding to A if A is atomic integer type, or ptrdiff_t if A is atomic pointer type.\n\nParameters\nobj   -   pointer to the atomic object to modify\narg   -   the value to bitwise XOR to the value stored in the atomic object\norder   -   the memory synchronization ordering for this operation: all values are permitted\n\n\nReturn value\n   The value held previously be the atomic object pointed to by obj.\n", "url": "https://devdocs.io/c/atomic/atomic_fetch_xor\n"}, {"name": "atomic_flag", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nstruct atomic_flag;\n    (since C11)\n\n   atomic_flag is an atomic boolean type. Unlike other atomic types, it is guaranteed to be lock-free. Unlike atomic_bool, atomic_flag does not provide load or store operations.\n", "url": "https://devdocs.io/c/atomic/atomic_flag\n"}, {"name": "atomic_flag_clear, atomic_flag_clear_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nvoid atomic_flag_clear( volatile atomic_flag* obj );\n  (1)   (since C11)\nvoid atomic_flag_clear_explicit( volatile atomic_flag* obj, memory_order order );\n  (2)   (since C11)\n\n   Atomically changes the state of a atomic_flag pointed to by obj to clear (false). The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order.\n   The argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic flags.\n\nParameters\nobj   -   pointer to the atomic flag object to modify\norder   -   the memory synchronization ordering for this operation: all values are permitted\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/atomic/atomic_flag_clear\n"}, {"name": "ATOMIC_FLAG_INIT", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\n#define ATOMIC_FLAG_INIT /* unspecified */\n    (since C11)\n\n   Expands to an expression that can be used to initialize atomic_flag type. The value atomic_flag that is not initialized using this macro is undefined.\n", "url": "https://devdocs.io/c/atomic/atomic_flag_init\n"}, {"name": "atomic_flag_test_and_set, atomic_flag_test_and_set_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\n_Bool atomic_flag_test_and_set( volatile atomic_flag* obj );\n  (1)   (since C11)\n_Bool atomic_flag_test_and_set_explicit( volatile atomic_flag* obj, memory_order order );\n  (2)   (since C11)\n\n   Atomically changes the state of a atomic_flag pointed to by obj to set (true) and returns the previous value. The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order.\n   The argument is pointer to a volatile atomic flag to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic flags.\n\nParameters\nobj   -   pointer to the atomic flag object to modify\norder   -   the memory synchronization ordering for this operation: all values are permitted\n\n\nReturn value\n   The previous value held by the atomic flag pointed to by obj.\n", "url": "https://devdocs.io/c/atomic/atomic_flag_test_and_set\n"}, {"name": "atomic_init", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nvoid atomic_init( volatile A* obj, C desired );\n    (since C11)\n\n   Initializes the default-constructed atomic object obj with the value desired. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.C is the non-atomic type corresponding to A.\n\nParameters\nobj   -   pointer to an atomic object to initialize\ndesired   -   the value to initialize atomic object with\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/atomic/atomic_init\n"}, {"name": "atomic_is_lock_free", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\n_Bool atomic_is_lock_free( const volatile A* obj );\n    (since C11)\n\n   Determines if the atomic operations on all objects of the type A (the type of the object pointed to by obj) are lock-free. In any given program execution, the result of calling atomic_is_lock_free is the same for all pointers of the same type.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.\n\nParameters\nobj   -   pointer to the atomic object to inspect\n\n\nReturn value\n   true if the operations on all objects of the type A are lock-free, false otherwise.\n\nNotes\n   C11, as published, specified that this function is per-object, not per-type. This was corrected by DR 465.\n", "url": "https://devdocs.io/c/atomic/atomic_is_lock_free\n"}, {"name": "atomic_load, atomic_load_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nC atomic_load( const volatile A* obj );\n  (1)   (since C11)\nC atomic_load_explicit( const volatile A* obj, memory_order order );\n  (2)   (since C11)\n\n   Atomically loads and returns the current value of the atomic variable pointed to by obj. The operation is atomic read operation.\n   The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order. order must be one of memory_order_relaxed, memory_order_consume, memory_order_acquire or memory_order_seq_cst. Otherwise the behavior is undefined.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.C is the non-atomic type corresponding to A.\n\nParameters\nobj   -   pointer to the atomic object to access\norder   -   the memory synchronization ordering for this operation\n\n\nReturn value\n   The current value of the atomic variable pointed to by obj.\n", "url": "https://devdocs.io/c/atomic/atomic_load\n"}, {"name": "atomic_signal_fence", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nvoid atomic_signal_fence( memory_order order );\n    (since C11)\n\n   Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by order, between a thread and a signal handler executed on the same thread. This is equivalent to atomic_thread_fence, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as order instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.\n\nParameters\norder   -   the memory ordering executed by this fence\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/atomic/atomic_signal_fence\n"}, {"name": "atomic_store, atomic_store_explicit", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nvoid atomic_store( volatile A* obj , C desired);\n  (1)   (since C11)\nvoid atomic_store_explicit( volatile A* obj, C desired, memory_order order );\n  (2)   (since C11)\n\n   Atomically replaces the value of the atomic variable pointed to by obj with desired. The operation is atomic write operation.\n   The first version orders memory accesses according to memory_order_seq_cst, the second version orders memory accesses according to order. order must be one of memory_order_relaxed, memory_order_release or memory_order_seq_cst. Otherwise the behavior is undefined.\n   This is a generic function defined for all atomic object types A. The argument is pointer to a volatile atomic type to accept addresses of both non-volatile and volatile (e.g. memory-mapped I/O) atomic variables.C is the non-atomic type corresponding to A.\n\nParameters\nobj   -   pointer to the atomic object to modify\norder   -   the memory synchronization ordering for this operation\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/atomic/atomic_store\n"}, {"name": "atomic_thread_fence", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nvoid atomic_thread_fence( memory_order order );\n    (since C11)\n\n   Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by order, without an associated atomic operation. For example, all non-atomic and relaxed atomic stores that happen before a memory_order_release fence in thread A will be synchronized with non-atomic and relaxed atomic loads from the same locations made in thread B after an memory_order_acquire fence.\n\nParameters\norder   -   the memory ordering executed by this fence\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/atomic/atomic_thread_fence\n"}, {"name": "ATOMIC_VAR_INIT", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\n#define ATOMIC_VAR_INIT(value) /* unspecified */\n    (since C11) (deprecated in C17)\n\n   Expands to an expression that can be used to initialize an atomic variable of the same type as value.\n   The initial value of atomic object of automatic storage duration that is not explicitly initialized using this macro (until C17) is indeterminate. The default (zero) initialization of static and thread-local variables produces a valid value however.\n   When initializing an atomic variable, any concurrent access, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a memory_order_relaxed operation).\n\nNotes\n   This macro was a part of early draft design for C11 atomic types. It is not needed in C11, and is deprecated in C17 with plans to be removed in C2x.\n", "url": "https://devdocs.io/c/atomic/atomic_var_init\n"}, {"name": "kill_dependency", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nA kill_dependency(A y);\n    (since C11)\n\n   Informs the compiler that the dependency tree started by an memory_order_consume atomic load operation does not extend past the return value of kill_dependency; that is, the argument does not carry a dependency into the return value.\n   The function is implemented as a macro. A is the type of y.\n\nParameters\ny   -   the expression whose return value is to be removed from a dependency tree\n\n\nReturn value\n   Returns y, no longer a part of a dependency tree.\n", "url": "https://devdocs.io/c/atomic/kill_dependency\n"}, {"name": "memory_order", "type": "STANDARD LIB", "description": "Defined in header <stdatomic.h>\nenum memory_order {\n    memory_order_relaxed,\n    memory_order_consume,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_acq_rel,\n    memory_order_seq_cst\n};\n    (since C11)\n\n   memory_order specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.\n   The default behavior of all atomic operations in the language and the library provides for sequentially consistent ordering (see discussion below). That default can hurt performance, but the library's atomic operations can be given an additional memory_order argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.\n\nConstants\nDefined in header <stdatomic.h>\nValue   Explanation\nmemory_order_relaxed   Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation's atomicity is guaranteed (see Relaxed ordering below)\nmemory_order_consume   A load operation with this memory order performs a consume operation on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see Release-Consume ordering below)\nmemory_order_acquire   A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)\nmemory_order_release   A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see Release-Consume ordering below).\nmemory_order_acq_rel   A read-modify-write operation with this memory order is both an acquire operation and a release operation. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.\nmemory_order_seq_cst   A load operation with this memory order performs an acquire operation, a store performs a release operation, and read-modify-write performs both an acquire operation and a release operation, plus a single total order exists in which all threads observe all modifications in the same order (see Sequentially-consistent ordering below)\n\n   Atomic operations tagged memory_order_relaxed are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.\n   For example, with x and y initially zero,\n   // Thread 1: r1 = atomic_load_explicit(y, memory_order_relaxed); // A atomic_store_explicit(x, r1, memory_order_relaxed); // B // Thread 2: r2 = atomic_load_explicit(x, memory_order_relaxed); // C atomic_store_explicit(y, 42, memory_order_relaxed); // D.\n   is allowed to produce r1 == r2 == 42 because, although A is sequenced-before B within thread 1 and C is sequenced before D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in thread 1 while the side effect of B on x could be visible to the load C in thread 2. In particular, this may occur if D is completed before C in thread 2, either due to compiler reordering or at runtime.\n   Typical use for relaxed memory ordering is incrementing counters, such as the reference counters , since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor).\n   If an atomic store in thread A is tagged memory_order_release and an atomic load in thread B from the same variable is tagged memory_order_consume, all memory writes (non-atomic and relaxed atomic) that are dependency-ordered-before the atomic store from the point of view of thread A, become visible side-effects within those operations in thread B into which the load operation carries dependency, that is, once the atomic load is completed, those operators and functions in thread B that use the value obtained from the load are guaranteed to see what thread A wrote to memory.\n   The synchronization is established only between the threads releasing and consuming the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.\n   On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain).\n   Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is rcu_dereference.\n   Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.\n   If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a \"release sequence\" is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no memory_order_release semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.\n   If an atomic store in thread A is tagged memory_order_release and an atomic load in thread B from the same variable is tagged memory_order_acquire, all memory writes (non-atomic and relaxed atomic) that happened-before the atomic store from the point of view of thread A, become visible side-effects in thread B. That is, once the atomic load is completed, thread B is guaranteed to see everything thread A wrote to memory.\n   The synchronization is established only between the threads releasing and acquiring the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.\n   On strongly-ordered systems \u2014 x86, SPARC TSO, IBM mainframe, etc. \u2014 release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode; only certain compiler optimizations are affected (e.g., the compiler is prohibited from moving non-atomic stores past the atomic store-release or performing non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions are used.\n   Mutual exclusion locks, such as mutexes or atomic spinlocks, are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.\n   Atomic operations tagged memory_order_seq_cst not only order memory the same way as release/acquire ordering (everything that happened-before a store in one thread becomes a visible side effect in the thread that did a load), but also establish a single total modification order of all atomic operations that are so tagged.\n   Formally,\n   Each memory_order_seq_cst operation B that loads from atomic variable M, observes one of the following:\n   If there was a memory_order_seq_cst atomic_thread_fence operation X sequenced-before B, then B observes one of the following:\n   For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two memory_order_seq_cst atomic_thread_fences X and Y, and if A is sequenced-before X, Y is sequenced-before B, and X appears before Y in the Single Total Order, then B observes either:\n   For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.\n   Note that this means that:\n   Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.\n   Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.\n\nRelationship with volatile\n   Within a thread of execution, accesses (reads and writes) through volatile lvalues cannot be reordered past observable side-effects (including other volatile accesses) that are separated by a sequence point within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.\n   In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).\n   One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (MSDN), and thus volatiles may be used for inter-thread synchronization. Standard volatile semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a signal handler that runs in the same thread when applied to sig_atomic_t variables.\n", "url": "https://devdocs.io/c/atomic/memory_order\n"}, {"name": "C keywords: auto", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/auto\n"}, {"name": "C keywords: break", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/break\n"}, {"name": "C keywords", "type": "STANDARD LIB", "description": "   This is a list of reserved keywords in C. Since they are used by the language, these keywords are not available for re-definition.\nauto break case char const continue default do double else enum extern.\n  float for goto if inline (since C99) int long register restrict (since C99) return short.\n  signed sizeof static struct switch typedef union unsigned void volatile while.\n  _Alignas (since C11) _Alignof (since C11) _Atomic (since C11) _Bool (since C99) _Complex (since C99) _Generic (since C11) _Imaginary (since C99) _Noreturn (since C11) _Static_assert (since C11) _Thread_local (since C11).\n\n   The most common keywords that begin with an underscore are generally used through their convenience macros:\nkeyword  used as  defined in\n_Alignas (since C11)  \nalignas  \nstdalign.h\n_Alignof (since C11)  \nalignof  \nstdalign.h\n_Atomic (since C11)  \natomic_bool, atomic_int, ...  \nstdatomic.h\n_Bool (since C99)  \nbool  \nstdbool.h\n_Complex (since C99)  \ncomplex  \ncomplex.h\n_Generic (since C11)  (no macro)\n_Imaginary (since C99)  \nimaginary  \ncomplex.h\n_Noreturn (since C11)  \nnoreturn  \nstdnoreturn.h\n_Static_assert (since C11)  \nstatic_assert  \nassert.h\n_Thread_local (since C11)  \nthread_local  \nthreads.h\n\n   Also, each name that begins with a double underscore __ or an underscore followed by an uppercase letter is reserved: see identifier for details.\n   Note that digraphs <%, %>, <:, :>, %:, and %:%: provide an alternative way to represent standard tokens.\n   The following tokens are recognized by the preprocessor when they are used within the context of a preprocessor directive:\nif elif else endif defined.\n  ifdef ifndef define undef.\n  include line error pragma.\n\n   The following tokens are recognized by the preprocessor when they are used outside the context of a preprocessor directive:\n_Pragma(since C99).\n\n   The following additional keywords are classified as extensions and conditionally-supported:\nasm fortran.\n\n", "url": "https://devdocs.io/c/keyword\n"}, {"name": "C keywords: case", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/case\n"}, {"name": "C keywords: char", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/char\n"}, {"name": "C keywords: const", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/const\n"}, {"name": "C keywords: continue", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/continue\n"}, {"name": "C keywords: default", "type": "STANDARD LIB", "description": "\nUsage\ntype-generic expression: as the declaration of the default generic association   (since C11)\n\n", "url": "https://devdocs.io/c/keyword/default\n"}, {"name": "C keywords: do", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/do\n"}, {"name": "C keywords: double", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/double\n"}, {"name": "C keywords: else", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/else\n"}, {"name": "C keywords: enum", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/enum\n"}, {"name": "C keywords: extern", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/extern\n"}, {"name": "C keywords: float", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/float\n"}, {"name": "C keywords: for", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/for\n"}, {"name": "C keywords: fortran", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/fortran\n"}, {"name": "C keywords: goto", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/goto\n"}, {"name": "C keywords: if", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/if\n"}, {"name": "C keywords: inline (since C99)\n", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/inline\n"}, {"name": "C keywords: int", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/int\n"}, {"name": "C keywords: long", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/long\n"}, {"name": "C keywords: register", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/register\n"}, {"name": "C keywords: restrict", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/restrict\n"}, {"name": "C keywords: return", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/return\n"}, {"name": "C keywords: short", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/short\n"}, {"name": "C keywords: signed", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/signed\n"}, {"name": "C keywords: sizeof", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/sizeof\n"}, {"name": "C keywords: static", "type": "STANDARD LIB", "description": "\nUsage\nstatic array indices in function parameter declarations.   (since C99)\n\n", "url": "https://devdocs.io/c/keyword/static\n"}, {"name": "C keywords: struct", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/struct\n"}, {"name": "C keywords: switch", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/switch\n"}, {"name": "C keywords: typedef", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/typedef\n"}, {"name": "C keywords: union", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/union\n"}, {"name": "C keywords: unsigned", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/unsigned\n"}, {"name": "C keywords: void", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/void\n"}, {"name": "C keywords: volatile", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/volatile\n"}, {"name": "C keywords: while", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/while\n"}, {"name": "C keywords: _Alignas (since C11)\n", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_alignas\n"}, {"name": "C keywords: _Alignof (since C11)\n", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_alignof\n"}, {"name": "C keywords: _Atomic", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_atomic\n"}, {"name": "C keywords: _Bool", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_bool\n"}, {"name": "C keywords: _Complex", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_complex\n"}, {"name": "C keywords: _Generic", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_generic\n"}, {"name": "C keywords: _Imaginary", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_imaginary\n"}, {"name": "C keywords: _Noreturn (since C11)\n", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_noreturn\n"}, {"name": "C keywords: _Static_assert", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_static_assert\n"}, {"name": "C keywords: _Thread_local (since C11)\n", "type": "STANDARD LIB", "description": "\nUsage\n", "url": "https://devdocs.io/c/keyword/_thread_local\n"}, {"name": "Replacing text macros", "type": "STANDARD LIB", "description": "   The preprocessor supports text macro replacement and function-like text macro replacement.\n\nSyntax\n#define identifier replacement-list(optional)   (1)\n#define identifier( parameters ) replacement-list   (2)\n#define identifier( parameters, ... ) replacement-list   (3)   (since C99)\n#define identifier( ... ) replacement-list   (4)   (since C99)\n#undef  identifier   (5)\n\n\nExplanation\n   The #define directives define the identifier as a macro, that is they instruct the compiler to replace all successive occurrences of identifier with replacement-list, which can be optionally additionally processed. If the identifier is already defined as any type of macro, the program is ill-formed unless the definitions are identical.\n   Object-like macros replace every occurrence of a defined identifier with replacement-list. Version (1) of the #define directive behaves exactly like that.\n   Function-like macros replace each occurrence of a defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.\n   The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a ( as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching ) token, skipping intervening matched pairs of left and right parentheses.\n   The number of arguments must be the same as the number of arguments in the macro definition (parameters) or the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.\n   Version (2) of the #define directive defines a simple function-like macro.\n   Version (3) of the #define directive defines a function-like macro with variable number of arguments. The additional arguments can be accessed using __VA_ARGS__ identifier, which is then replaced with arguments, supplied with the identifier to be replaced.\n   Version (4) of the #define directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments can be accessed only with __VA_ARGS__ identifier, which is then replaced with arguments, supplied with identifier to be replaced.\n   Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (such as macro(array[x = y, x + 1]) or atomic_store (p, (struct S){ a, b });), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.\n   In function-like macros, a # operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called \"stringification\". If the result of stringification is not a valid string literal, the behavior is undefined.\nWhen # appears before __VA_ARGS__, the entire expanded __VA_ARGS__ is enclosed in quotes:\n#define showlist(...) puts(#__VA_ARGS__)\nshowlist();            // expands to puts(\"\")\nshowlist(1, \"x\", int); // expands to puts(\"1, \\\"x\\\", int\")  (since C99)\n\n   A ## operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers and then concatenates the result. This operation is called \"concatenation\" or \"token pasting\". Only tokens that form a valid token together may be pasted: identifiers that form a longer identifier, digits that form a number, or operators + and = that form a +=. A comment cannot be created by pasting / and * because comments are removed from text before macro substitution is considered. If the result of concatenation is not a valid token, the behavior is undefined.\n   Note: Some compilers offer an extension that allows ## to appear after a comma and before __VA_ARGS__, in which case the ## does nothing when __VA_ARGS__ is non-empty, but removes the comma when __VA_ARGS__ is empty: this makes it possible to define macros such as fprintf (stderr, format, ##__VA_ARGS__).\n   The order of evaluation of # and ## operators is unspecified.\n   The #undef directive undefines the identifier, that is it cancels the previous definition of the identifier by #define directive. If the identifier does not have an associated macro, the directive is ignored.\n\nPredefined macros\n   The following macro names are predefined in any translation unit:\n__STDC__   expands to the integer constant 1. This macro is intended to indicate a conforming implementation  (macro constant)\n__STDC_VERSION__\n(C95)   expands to an integer constant of type long whose value increases with each version of the C standard: \n 199409L (C95) \n 199901L (C99) \n 201112L (C11) \n 201710L (C17)  (macro constant)\n__STDC_HOSTED__\n(C99)   expands to the integer constant 1 if the implementation is hosted (runs under an OS), \u200b0\u200b if freestanding (runs without an OS)  (macro constant)\n__FILE__   expands to the name of the current file, as a character string literal, can be changed by the #line directive  (macro constant)\n__LINE__   expands to the source file line number, an integer constant, can be changed by the #line directive  (macro constant)\n__DATE__   expands to the date of translation, a character string literal of the form \"Mmm dd yyyy\". The name of the month is as if generated by asctime and the first character of \"dd\" is a space if the day of the month is less than 10  (macro constant)\n__TIME__   expands to the time of translation, a character string literal of the form \"hh:mm:ss\", as in the time generated by asctime()  (macro constant)\n\n   The following additional macro names may be predefined by an implementation:\n__STDC_ISO_10646__\n(C99)   expands to an integer constant of the form yyyymmL, if wchar_t uses Unicode; the date indicates the latest revision of Unicode supported  (macro constant)\n__STDC_IEC_559__\n(C99)   expands to 1 if IEC 60559 is supported  (macro constant)\n__STDC_IEC_559_COMPLEX__\n(C99)   expands to 1 if IEC 60559 complex arithmetic is supported  (macro constant)\n__STDC_UTF_16__\n(C11)   expands to 1 if char16_t use UTF-16 encoding  (macro constant)\n__STDC_UTF_32__\n(C11)   expands to 1 if char32_t use UTF-32 encoding  (macro constant)\n__STDC_MB_MIGHT_NEQ_WC__\n(C99)   expands to 1 if 'x' == L'x' might be false for a member of the basic character set, such as on EBCDIC-based systems that use Unicode for wchar_t  (macro constant)\n__STDC_ANALYZABLE__\n(C11)   expands to 1 if analyzability is supported  (macro constant)\n__STDC_LIB_EXT1__\n(C11)   expands to an integer constant 201112L if bounds-checking interfaces are supported  (macro constant)\n__STDC_NO_ATOMICS__\n(C11)   expands to 1 if atomic types and atomic operations library are not supported  (macro constant)\n__STDC_NO_COMPLEX__\n(C11)   expands to 1 if complex types and complex math library are not supported  (macro constant)\n__STDC_NO_THREADS__\n(C11)   expands to 1 if multithreading is not supported  (macro constant)\n__STDC_NO_VLA__\n(C11)   expands to 1 if variable-length arrays are not supported  (macro constant)\n\n   The values of these macros (except for __FILE__ and __LINE__) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.\nThe predefined variable __func__ (see function definition for details) is not a preprocessor macro, even though it is sometimes used together with __FILE__ and __LINE__, e.g. by assert.\n (since C99)\n\n", "url": "https://devdocs.io/c/preprocessor/replace\n"}, {"name": "Conditional inclusion", "type": "STANDARD LIB", "description": "   The preprocessor supports conditional compilation of parts of a source file. This behavior is controlled by #if, #else, #elif, #ifdef, #ifndef and #endif directives.\n\nSyntax\n#if expression\n#ifdef identifier\n#ifndef identifier\n#elif expression\n#else\n#endif\n\n\nExplanation\n   The conditional preprocessing block starts with #if, #ifdef or #ifndef directive, then optionally includes any number of #elif directives, then optionally includes at most one #else directive and is terminated with the #endif directive. Any inner conditional preprocessing blocks are processed separately.\n   Each of #if, #elif, #else, #ifdef and #ifndef directives control a code block until the first #elif, #else, #endif directive not belonging to any inner conditional preprocessing blocks.\n   #if, #ifdef and #ifndef directives test the specified condition (see below), and if it evaluates to true, compiles the controlled code block. In that case subsequent #else and #elif directives are ignored. Otherwise, if the specified condition evaluates false, the controlled code block is skipped and the subsequent #else or #elif directive (if any) is processed. In the former case, the code block controlled by the #else directive is unconditionally compiled. In the latter case, the #elif directive acts as if it were a #if directive: checks for condition, compiles or skips the controlled code block based on the result, and in the latter case processes subsequent #elif and #else directives. The conditional preprocessing block is terminated by the #endif directive.\n\nConditional evaluation\n   The expression is a constant expression, using only constants and identifiers, defined using  #define directive. Any identifier, which is not literal, non defined using  #define directive, evaluates to 0.\n   The expression may contain unary operators in form defined identifier or defined (identifier) which return 1 if the identifier was defined using  #define directive and 0 otherwise. If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise. If any used identifier is not a constant, it is replaced with \u200b0\u200b.\nNote: #if cond1 ... #elif cond2 is different from #if cond1 ... #else followed by #if cond3 because if cond1 is true, the second #if is skipped and cond3 does not need to be well-formed, while #elif's cond2 must be a valid expression.\n (until C11)\n\n   Checks if the identifier was defined using  #define directive.\n   #ifdef identifier is essentially equivalent to #if defined identifier.\n   #ifndef identifier is essentially equivalent to #if\u00a0!defined identifier.\n", "url": "https://devdocs.io/c/preprocessor/conditional\n"}, {"name": "Error directive", "type": "STANDARD LIB", "description": "   Shows the given error message and renders the program ill-formed.\n\nSyntax\n#error error_message\n\n\nExplanation\n   After encountering the #error directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).\n   error_message can consist of several words not necessarily in quotes.\n", "url": "https://devdocs.io/c/preprocessor/error\n"}, {"name": "Source file inclusion", "type": "STANDARD LIB", "description": "   Includes another source file into the current source file at the line immediately after the directive.\n\nSyntax\n#include <filename>   (1)\n#include \"filename\"   (2)\n\n\nExplanation\n   Includes source file, identified by filename, into the current source file at the line immediately after the directive.\n   1) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files under control of the implementation. Typical implementations search only standard include directories. The standard C++ library and the standard C library are implicitly included in these standard include directories. The standard include directories usually can be controlled by the user through compiler options.\n   2) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files that are not controlled by the implementation. Typical implementations first search the directory where the current file resides and, only if the file is not found, search the standard include directories as with (1).\n   In the case the file is not found, the program is ill-formed.\n", "url": "https://devdocs.io/c/preprocessor/include\n"}, {"name": "Filename and line information", "type": "STANDARD LIB", "description": "   Changes the current line number and file name in the preprocessor.\n\nSyntax\n#line lineno   (1)\n#line lineno \"filename\"   (2)\n\n\nExplanation\n   Any preprocessing tokens (macro constants or expressions) are permitted as arguments to #line as long as they expand to a valid decimal integer optionally following a valid character string.\n   lineno must be a sequence of at least one decimal digit (the program is ill-formed, otherwise) and is always interpreted as decimal (even if it starts with 0).\n   If lineno is 0 or greater than 32767 (until C99)2147483647 (since C99), the behavior is undefined.\n\nNotes\n   This directive is used by some automatic code generation tools which produce C source files from a file written in another language. In that case, #line directives may be inserted in the generated C file referencing line numbers and the file name of the original (human-editable) source file.\n   The line number following the directive #line __LINE__ is implementation-defined (there are two possible values that __LINE__ can expand to in this case: number of endlines seen so far, or number of endlines seen so far plus the endline that ends the #line directive).\n", "url": "https://devdocs.io/c/preprocessor/line\n"}, {"name": "Implementation defined behavior control", "type": "STANDARD LIB", "description": "   Implementation defined behavior is controlled by #pragma directive.\n\nSyntax\n#pragma pragma_params   (1)\n_Pragma ( string-literal )   (2)   (since C99)\n\n\nExplanation\n   The pragma directive controls implementation-specific behavior of the compiler, such as disabling compiler warnings or changing alignment requirements. Any pragma that is not recognized is ignored.\n\nStandard pragmas\n   The following three pragmas are defined by the language standard:\n#pragma STDC FENV_ACCESS arg   (1)\n#pragma STDC FP_CONTRACT arg   (2)\n#pragma STDC CX_LIMITED_RANGE arg   (3)\n\n   where arg is either ON or OFF or DEFAULT.\n   Note: compilers that do not support these pragmas may provide equivalent compile-time options, such as gcc's -fcx-limited-range and -ffp-contract.\n\nNon-standard pragmas\n   #pragma once is a non-standard pragma that is supported by the vast majority of modern compilers. If it appears in a header file, it indicates that it is only to be parsed once, even if it is (directly or indirectly) included multiple times in the same source file.\n   Standard approach to preventing multiple inclusion of the same header is by using include guards:\n   So that all but the first inclusion of the header in any translation unit are excluded from compilation. All modern compilers record the fact that a header file uses an include guard and do not re-parse the file if it is encountered again, as long as the guard is still defined. (see e.g. gcc).\n   With #pragma once, the same header appears as.\n   Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with #pragma once files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.\n", "url": "https://devdocs.io/c/preprocessor/impl\n"}, {"name": "alignas", "type": "STANDARD LIB", "description": "   Appears in the declaration syntax as one of the type specifiers to modify the alignment requirement of the object being declared.\n\nSyntax\n_Alignas ( expression )   (1)   (since C11)\n_Alignas ( type )   (2)   (since C11)\n\nexpression   -   any integer constant expression whose value is a valid alignment or zero\ntype   -   any type name\n\n   This keyword is also available as convenience macro alignas, available in the header <stdalign.h>.\n\nExplanation\n   The alignas specifier can only be used when declaring objects that aren't bit fields, and don't have the register storage class. It cannot be used in function parameter declarations, and cannot be used in a typedef.\n   When used in a declaration, the declared object will have its alignment requirement set to.\n   except when this would weaken the alignment the type would have had naturally.\n   If expression evaluates to zero, this specifier has no effect.\n   When multiple alignas specifiers appear in the same declaration, the strictest one is used.\n   Alignas specifier only needs to appear on the definition of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.\n\nNotes\n   As initially published, C11 does not allow alignas specifiers in structure and union members; this was corrected by DR 444.\n   In C++, the alignas specifier may also be applied to the declarations of class/struct/union types and enumerations. This is not supported in C, but the alignment of a struct type can be controlled by using alignas in a member declaration (as of DR 444).\n\nKeywords\n   _Alignas.\n", "url": "https://devdocs.io/c/language/alignas\n"}, {"name": "Alternative operators and tokens", "type": "STANDARD LIB", "description": "   C source code may be written in any 8-bit character set that includes the ISO 646:1983 invariant character set, even non-ASCII ones. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: {, }, [, ], #, \\, ^, |, ~. To be able to use character encodings where some or all of these symbols do not exist (such as the German DIN 66003), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.\n   There are alternative spellings for the operators that use non-ISO646 characters, defined in <iso646.h> as macros:\nDefined in header <iso646.h>\nPrimary   Alternative\n&&   and  (operator macro)\n&=   and_eq  (operator macro)\n&   bitand  (operator macro)\n|   bitor  (operator macro)\n~   compl  (operator macro)\n!   not  (operator macro)\n!=   not_eq  (operator macro)\n||   or  (operator macro)\n|=   or_eq  (operator macro)\n^   xor  (operator macro)\n^=   xor_eq  (operator macro)\n\n   The characters & and ! are invariant under ISO-646, but alternatives are provided for the operators that use these characters anyway to accommodate even more restrictive historical charsets.\n   There is no alternative spelling (such as eq) for the equality operator == because the character = was present in all supported charsets.\n   The following alternative tokens are part of the core language, and, in all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the stringification operator can make the spelling visible). The two-letter alternative tokens are sometimes called \"digraphs\"\nPrimary   Alternative\n{   <%\n}   %>\n[   <:\n]   :>\n#   %:\n##   %:%:\n\n   The following three-character groups (trigraphs) are parsed before comments and string literals are recognized, and each appearance of a trigraph is replaced by the corresponding primary character:\nPrimary   Trigraph\n{   ??<\n}   ??>\n[   ??(\n]   ??)\n#   ??=\n\\   ??/\n^   ??'\n|   ??!\n~   ??-\n\n   Because trigraphs are processed early, a comment such as // Will the next line be executed?????/ will effectively comment out the following line, and the string literal such as \"What's going on??!\" is parsed as \"What's going on|\".\n\nSee also\n", "url": "https://devdocs.io/c/language/operator_alternative\n"}, {"name": "Analyzability", "type": "STANDARD LIB", "description": "   This optional extension to the C language limits the potential results of executing some forms of undefined behavior, which improves the effectiveness of static analysis of such programs. Analyzability is only guaranteed to be enabled if the predefined macro constant __STDC_ANALYZABLE__(C11) is defined by the compiler.\n   If the compiler supports analyzability, any language or library construct whose behavior is undefined is further classified between critical and bounded undefined behavior, and the behavior of all bounded UB cases is limited as specified below.\n\nCritical undefined behavior\n   Critical UB is undefined behavior that might perform a memory write or a volatile memory read out of bounds of any object. A program that has critical undefined behavior may be susceptible to security exploits.\n   Only the following undefined behaviors are critical:\n\nBounded undefined behavior\n   Bounded UB is undefined behavior that cannot perform an illegal memory write, although it may trap and may produce or store indeterminate values.\n\nNotes\n   Bounded undefined behavior disables certain optimizations: compilation with analyzability enabled preserves source-code causality, which may be violated by undefined behavior otherwise.\n   Analyzability extension permits, as a form of implementation-defined behavior, for the runtime constraint handler to be invoked when a trap occurs.\n", "url": "https://devdocs.io/c/language/analyzability\n"}, {"name": "Arithmetic operators", "type": "STANDARD LIB", "description": "   Arithmetic operators apply standard mathematical operations to their operands.\nOperator   Operator name   Example   Result\n+   unary plus   +a   the value of a after promotions\n-   unary minus   -a   the negative of a\n+   addition   a + b   the addition of a and b\n-   subtraction   a - b   the subtraction of b from a\n*   product   a * b   the product of a and b\n/   division   a / b   the division of a by b\n%   modulo   a % b   the remainder of a divided by b\n~   bitwise NOT   ~a   the bitwise NOT of a\n&   bitwise AND   a & b   the bitwise AND of a and b\n|   bitwise OR   a | b   the bitwise OR of a and b\n^   bitwise XOR   a ^ b   the bitwise XOR of a and b\n<<   bitwise left shift   a << b   a left shifted by b\n>>   bitwise right shift   a >> b   a right shifted by b\n\n\nOverflows\n   Unsigned integer arithmetic is always performed modulo 2n where n is the number of bits in that particular integer. E.g. for unsigned int, adding one to UINT_MAX gives \u200b0\u200b, and subtracting one from \u200b0\u200b gives UINT_MAX.\n   When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. -ftrapv in GCC and Clang), or may be completely optimized out by the compiler.\n   If  #pragma STDC FENV_ACCESS is set to ON, all floating-point arithmetic operators obey the current floating-point rounding direction and report floating-point arithmetic errors as specified in math_errhandling unless part of a static initializer (in which case floating-point exceptions are not raised and the rounding mode is to nearest).\n   Unless  #pragma STDC FP_CONTRACT is set to OFF, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is optimizations that omit rounding errors and floating-point exceptions that would be observed if the expression was evaluated exactly as written. For example, allows the implementation of (x*y) + z with a single fused multiply-add CPU instruction or optimization of a = x*x*x*x; as tmp = x*x; a = tmp*tmp.\n   Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see FLT_EVAL_METHOD.\n\nUnary arithmetic\n   The unary arithmetic operator expressions have the form.\n+ expression   (1)\n- expression   (2)\n\n   Both unary plus and unary minus first apply integral promotions to their operand, and then.\n   The type of the expression is the type after promotion, and the value category is non-lvalue.\n   The unary minus invokes undefined behavior due to signed integer overflow when applied to INT_MIN, LONG_MIN, or LLONG_MIN, on typical (2's complement) platforms.\n   In C++, unary operator + can also be used with other built-in types such as arrays and functions, not so in C.\n\nAdditive operators\n   The binary additive arithmetic operator expressions have the form.\nlhs + rhs   (1)\nlhs - rhs   (2)\n\n   If both operands have arithmetic types, then.\n   Complex and imaginary addition and subtraction are defined as follows (note the result type is imaginary if both operands are imaginary and complex if one operand is real and the other imaginary, as specified by the usual arithmetic conversions):\n+ or -   u   iv   u + iv\nx   x \u00b1 u   x \u00b1 iv   (x \u00b1 u) \u00b1 iv\niy   \u00b1u + iy   i(y \u00b1 v)   \u00b1u + i(y \u00b1 v)\nx + iy   (x \u00b1 u) + iy   x + i(y \u00b1 v)   (x \u00b1 u) + i(y \u00b1 v)\n\n   The behavior is defined only if both the original pointer and the result pointer are pointing at elements of the same array or one past the end of that array. Note that executing p-1 when p points at the first element of an array is undefined behavior and may fail on some platforms.\n   The behavior is defined only if the result fits in ptrdiff_t.\n   For the purpose of pointer arithmetic, a pointer to an object that is not an element of any array is treated as a pointer to the first element of an array of size 1.\n\nMultiplicative operators\n   The binary multiplicative arithmetic operator expressions have the form.\nlhs * rhs   (1)\nlhs / rhs   (2)\nlhs % rhs   (3)\n\n   The binary operator * performs multiplication of its operands (after usual arithmetic conversions) following the usual arithmetic definitions, except that.\n   Because in C, any complex value with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex multiplication. Other combinations of floating operands follow the following table:\n*   u   iv   u + iv\nx   xu   i(xv)   (xu) + i(xv)\niy   i(yu)   \u2212yv   (\u2212yv) + i(yu)\nx + iy   (xu) + i(yu)   (\u2212yv) + i(xv)   special rules\n\n   Besides infinity handling, complex multiplication is not allowed to overflow intermediate results, except when  #pragma STDC CX_LIMITED_RANGE is set to ON, in which case the value may be calculated as if by (x+iy)\u00d7(u+iv) = (xu-yv)+i(yu+xv), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.\n   Despite disallowing undue overflow, complex multiplication may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).\n   The binary operator / divides the first operand by the second (after usual arithmetic conversions) following the usual arithmetics definitions, except that.\n   result of the / operator is a complex infinity.\n   result of the / operator is a zero.\n   Because in C, any complex value with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex division. Other combinations of floating operands follow the following table:\n/   u   iv\nx   x/u   i(\u2212x/v)\niy   i(y/u)   y/v\nx + iy   (x/u) + i(y/u)   (y/v) + i(\u2212x/v)\n\n   Besides infinity handling, complex division is not allowed to overflow intermediate results, except when  #pragma STDC CX_LIMITED_RANGE is set to ON, in which case the value may be calculated as if by (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u2+v2), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.\n   Despite disallowing undue overflow, complex division may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).\n   If the second operand is zero, the behavior is undefined, except that if the IEEE floating-point arithmetic is supported, and the floating-point division is taking place, then.\n   The binary operator % yields the remainder of the division of the first operand by the second (after usual arithmetic conversions).\n   The sign of the remainder is defined in such a way that if the quotient a/b is representable in the result type, then (a/b)*b + a%b == a.\n   If the second operand is zero, the behavior is undefined.\n   If the quotient a/b is not representable in the result type, the behavior of both a/b and a%b is undefined (that means INT_MIN%-1 is undefined on 2's complement systems).\n   Note: the remainder operator does not work on floating-point types, the library function fmod provides that functionality.\n\nBitwise logic\n   The bitwise arithmetic operator expressions have the form.\n~ rhs   (1)\nlhs & rhs   (2)\nlhs | rhs   (3)\nlhs ^ rhs   (4)\n\n   First, operators &, ^, and | perform usual arithmetic conversions on both operands and the operator ~ performs integer promotions on its only operand.\n   Then, the corresponding binary logic operators are applied bitwise; that is, each bit of the result is set or cleared according to the logic operation (NOT, AND, OR, or XOR), applied to the corresponding bits of the operands.\n   Note: bitwise operators are commonly used to manipulate bit sets and bit masks.\n   Note: for unsigned types (after promotion), the expression ~E is equivalent to the maximum value representable by the result type minus the original value of E.\n\nShift operators\n   The bitwise shift operator expressions have the form.\nlhs << rhs   (1)\nlhs >> rhs   (2)\n\n   First, integer promotions are performed, individually, on each operand (Note: this is unlike other binary arithmetic operators, which all perform usual arithmetic conversions). The type of the result is the type of lhs after promotion.\n   For unsigned lhs, the value of LHS << RHS is the value of LHS * 2RHS, reduced modulo maximum value of the return type plus 1 (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded). For signed lhs with nonnegative values, the value of LHS << RHS is LHS * 2RHS if it is representable in the promoted type of lhs, otherwise the behavior is undefined.\n   For unsigned lhs and for signed lhs with nonnegative values, the value of LHS >> RHS is the integer part of LHS / 2RHS. For negative LHS, the value of LHS >> RHS is implementation-defined where in most implementations, this performs arithmetic right shift (so that the result remains negative). Thus in most implementations, right shifting a signed LHS fills the new higher-order bits with the original sign bit (i.e. with 0 if it was non-negative and 1 if it was negative).\n   In any case, the behavior is undefined if rhs is negative or is greater or equal the number of bits in the promoted lhs.\n", "url": "https://devdocs.io/c/language/operator_arithmetic\n"}, {"name": "Arithmetic types", "type": "STANDARD LIB", "description": "   (See also type for type system overview and  the list of type-related utilities that are provided by the C library).\nBoolean type  _Bool (also accessible as the macro bool) - type, capable of holding one of the two values: 1 and 0 (also accessible as the macros true and false).  Note that conversion to _Bool does not work the same as conversion to other integer types: (bool)0.5 evaluates to 1, whereas (int)0.5 evaluates to \u200b0\u200b.\n (since C99)\n\n\nCharacter types\n   Note that the standard library also defines typedef names wchar_t , char16_t, and char32_t (since C11) to represent wide characters.\n\nInteger types\nlong long int (also accessible as long long) \n\nunsigned long long int (also accessible as unsigned long long) \n  (since C99)\n\n   Note: as with all type specifiers, any order is permitted: unsigned long long int and long int unsigned long name the same type.\n   The following table summarizes all available integer types and their properties:\nType specifier   Equivalent type   Width in bits by data model\nC standard   LP32   ILP32   LLP64   LP64\nshort   short int   at least 16   16   16   16   16\nshort int\nsigned short\nsigned short int\nunsigned short   unsigned short int\nunsigned short int\nint   int   at least 16   16   32   32   32\nsigned\nsigned int\nunsigned   unsigned int\nunsigned int\nlong   long int   at least 32   32   32   32   64\nlong int\nsigned long\nsigned long int\nunsigned long   unsigned long int\nunsigned long int\nlong long   long long int  (C99)   at least 64   64   64   64   64\nlong long int\nsigned long long\nsigned long long int\nunsigned long long   unsigned long long int  (C99)\nunsigned long long int\n\n   Besides the minimal bit counts, the C Standard guarantees that  1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long).\n   Note: this allows the extreme case in which bytes are sized 64 bits, all types (including char) are 64 bits wide, and sizeof returns 1 for every type.\n   Note: integer arithmetic is defined differently for the signed and unsigned integer types. See arithmetic operators, in particular integer overflows.\n   The choices made by each implementation about the sizes of the fundamental types are collectively known as data model. Four data models found wide acceptance:\n   32 bit systems:\n   64 bit systems:\n   Other models are very rare. For example, ILP64 (8/8/8: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).\n   Note that exact-width integer types are available in <stdint.h> since C99.\n\nReal floating types\n   C has three types for representing real floating-point values:\n   Floating-point types may support special values:\n   Real floating-point numbers may be used with arithmetic operators + - / * and various mathematical functions from math.h. Both built-in operators and library functions may raise floating-point exceptions and set errno as described in math_errhandling.\n   Floating-point expressions may have greater range and precision than indicated by their types, see FLT_EVAL_METHOD. Assignment, return, and cast force the range and precision to the one associated with the declared type.\n   Floating-point expressions may also be contracted, that is, calculated as if all intermediate values have infinite range and precision, see #pragma STDC FP_CONTRACT.\n   Some operations on floating-point numbers are affected by and modify the state of the floating-point environment (most notably, the rounding direction).\n   Implicit conversions are defined between real floating types and integer, complex, and imaginary types.\n   See Limits of floating point types and the math.h library for additional details, limits, and properties of the floating-point types.\nComplex floating types Complex floating types model the mathematical complex numbers, that is the numbers that can be written as a sum of a real number and a real number multiplied by the imaginary unit: a + bi.\nThe three complex types are.\n\n float _Complex (also available as float complex if <complex.h> is included) \n double _Complex (also available as double complex if <complex.h> is included) \n long double _Complex (also available as long double complex if <complex.h> is included) \n Note: as with all type specifiers, any order is permitted: long double complex, complex long double, and even double complex long name the same type.\n#include <complex.h>\n#include <stdio.h>\nint main(void)\n{\n    double complex z = 1 + 2*I;\n    z = 1/z;\n    printf(\"1/(1.0+2.0i) = %.1f%+.1fi\\n\", creal(z), cimag(z));\n} Output:\n1/(1.0+2.0i) = 0.2-0.4i  \n If the macro constant __STDC_NO_COMPLEX__(C11) is defined by the implementation, the complex types (as well as the library header <complex.h>) are not provided. (since C11)\n  Each complex type has the same object representation and alignment requirements as an array of two elements of the corresponding real type (float for float complex, double for double complex, long double for long double complex). The first element of the array holds the real part, and the second element of the array holds the imaginary component.\nfloat a[4] = {1, 2, 3, 4};\nfloat complex z1, z2;\nmemcpy(&z1, a, sizeof z1); // z1 becomes 1.0 + 2.0i\nmemcpy(&z2, a+2, sizeof z2); // z2 becomes 3.0 + 4.0i Complex numbers may be used with arithmetic operators + - * and /, possibly mixed with imaginary and real numbers. There are many mathematical functions defined for complex numbers in complex.h. Both built-in operators and library functions may raise floating-point exceptions and set errno as described in math_errhandling.\nIncrement and decrement are not defined for complex types.\nRelational operators are not defined for complex types (there is no notion of \"less than\")  Implicit conversions are defined between complex types and other arithmetic types.\nIn order to support the one-infinity model of complex number arithmetic, C regards any complex value with at least one infinite part as an infinity even if its other part is a NaN, guarantees that all operators and functions honor basic properties of inifinities and provides cproj to map all infinities to the canonical one (see arithmetic operators for the exact rules).\n#include <stdio.h>\n#include <complex.h>\n#include <math.h>\nint main(void)\n{\n   double complex z = (1 + 0*I) * (INFINITY + I*INFINITY);\n// textbook formula would give\n// (1+i0)(\u221e+i\u221e) \u21d2 (1\u00d7\u221e \u2013 0\u00d7\u221e) + i(0\u00d7\u221e+1\u00d7\u221e) \u21d2 NaN + I*NaN\n// but C gives a complex infinity\n   printf(\"%f + i*%f\\n\", creal(z), cimag(z));\n \n// textbook formula would give\n// cexp(\u221e+iNaN) \u21d2 exp(\u221e)\u00d7(cis(NaN)) \u21d2 NaN + I*NaN\n// but C gives  \u00b1\u221e+i*nan\n   double complex y = cexp(INFINITY + I*NAN);\n   printf(\"%f + i*%f\\n\", creal(y), cimag(y));\n \n} Possible output:\ninf + i*inf \ninf + i*nan C also treats multiple infinities so as to preserve directional information where possible, despite the inherent limitations of the Cartesian representation:\nmultiplying the imaginary unit by real infinity gives the correctly-signed imaginary infinity: i \u00d7 \u221e = i\u221e. Also, i \u00d7 (\u221e \u2013 i\u221e) = \u221e + i\u221e indicates the reasonable quadrant.\n Imaginary floating types Imaginary floating types model the mathematical imaginary numbers, that is numbers that can be written as a real number multiplied by the imaginary unit: bi The three imaginary types are.\n\n float _Imaginary (also available as float imaginary if <complex.h> is included) \n double _Imaginary (also available as double imaginary if <complex.h> is included) \n long double _Imaginary (also available as long double imaginary if <complex.h> is included) \n Note: as with all type specifiers, any order is permitted: long double imaginary, imaginary long double, and even double imaginary long name the same type.\n#include <complex.h>\n#include <stdio.h>\nint main(void)\n{\n    double imaginary z = 3*I;\n    z = 1/z;\n    printf(\"1/(3.0i) = %+.1fi\\n\", cimag(z));\n} Output:\n1/(3.0i) = -0.3i  \n A compiler that defines __STDC_IEC_559_COMPLEX__ is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro _Imaginary_I is defined to identify imaginary number support.\n \n(since C99)(until C11)\n\n \n Imaginary numbers are supported if __STDC_IEC_559_COMPLEX__ is defined.\n (since C11)\n  Each of the three imaginary types has the same object representation and alignment requirement as its corresponding real type (float for float imaginary, double for double imaginary, long double for long double imaginary).\nNote: despite that, imaginary types are distinct and not compatible with their corresponding real types, which prohibits aliasing.\nImaginary numbers may be used with arithmetic operators + - * and /, possibly mixed with complex and real numbers. There are many mathematical functions defined for imaginary numbers in complex.h. Both built-in operators and library functions may raise floating-point exceptions and set errno as described in math_errhandling.\nIncrement and decrement are not defined for imaginary types  Implicit conversions are defined between imaginary types and other arithmetic types.\nThe imaginary numbers make it possible to express all complex numbers using the natural notation x + I*y (where I is defined as _Imaginary_I). Without imaginary types, certain special complex values cannot be created naturally. For example, if I is defined as _Complex_I, then writing 0.0 + I*INFINITY gives NaN as the real part, and CMPLX(0.0, INFINITY) must be used instead. Same goes for the numbers with the negative zero imaginary component, which are meaningful when working with the library functions with branch cuts, such as csqrt: 1.0 - 0.0*I results in the positive zero imaginary component if I is defined as _Complex_I and the negative zero imaginary part requires the use of CMPLX or conj.\nImaginary types also simplify implementations; multiplication of an imaginary by a complex can be implemented straightforwardly with two multiplications if the imaginary types are supported, instead of four multiplications and two additions.\n (since C99)\nIf the macro constant __STDC_NO_COMPLEX__(C11) is defined by the implementation, the complex types (as well as the library header <complex.h>) are not provided. (since C11)\nA compiler that defines __STDC_IEC_559_COMPLEX__ is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro _Imaginary_I is defined to identify imaginary number support.\n \n(since C99)(until C11)\nImaginary numbers are supported if __STDC_IEC_559_COMPLEX__ is defined.\n (since C11)\n\n\nKeywords\n   char, int, short, long, signed, unsigned, float, double. _Bool, _Complex, _Imaginary.\n\nRange of values\n   The following table provides a reference for the limits of common numeric representations. As the C Standard allows any signed integer representation, the table gives both the minimum guaranteed requirements (which correspond to the limits of one's complement or sign-and-magnitude) and the limits of the most commonly used implementation, two's complement. All popular data models (including all of ILP32, LP32, LP64, LLP64) use two's complement representation, though.\nType   Size in bits   Format   Value range\nApproximate   Exact\ncharacter   8   signed (one's complement)   -127 to 127\nsigned (two's complement)   -128 to 127\nunsigned   0 to 255\nintegral   16   signed (one's complement)   \u00b1 3.27 \u00b7 104   -32767 to 32767\nsigned (two's complement)   -32768 to 32767\nunsigned   0 to 6.55 \u00b7 104   0 to 65535\n32   signed (one's complement)   \u00b1 2.14 \u00b7 109   -2,147,483,647 to 2,147,483,647\nsigned (two's complement)   -2,147,483,648 to 2,147,483,647\nunsigned   0 to 4.29 \u00b7 109   0 to 4,294,967,295\n64   signed (one's complement)   \u00b1 9.22 \u00b7 1018   -9,223,372,036,854,775,807 to 9,223,372,036,854,775,807\nsigned (two's complement)   -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\nunsigned   0 to 1.84 \u00b7 1019   0 to 18,446,744,073,709,551,615\nfloating point   32   IEEE-754   \nmin subnormal:\u00b1 1.401,298,4 \u00b7 10-45 \nmin normal:\u00b1 1.175,494,3 \u00b7 10-38 \nmax:\u00b1 3.402,823,4 \u00b7 1038 \n   \nmin subnormal:\u00b10x1p-149 \nmin normal:\u00b10x1p-126 \nmax:\u00b10x1.fffffep+127\n64   IEEE-754   \nmin subnormal:\u00b1 4.940,656,458,412 \u00b7 10-324 \nmin normal:\u00b1 2.225,073,858,507,201,4 \u00b7 10-308 \nmax:\u00b1 1.797,693,134,862,315,7 \u00b7 10308 \n   \nmin subnormal:\u00b10x1p-1074 \nmin normal:\u00b10x1p-1022 \nmax:\u00b10x1.fffffffffffffp+1023\n\n   Note: actual (as opposed to guaranteed minimal) ranges are available in the library headers <limits.h> and <float.h>\n\nSee also\n", "url": "https://devdocs.io/c/language/arithmetic_types\n"}, {"name": "Array declaration", "type": "STANDARD LIB", "description": "   Array is a type consisting of a contiguously allocated nonempty sequence of objects with a particular element type. The number of those objects (the array size) never changes during the array lifetime.\n\nSyntax\n   In the declaration grammar of an array declaration, the type-specifier sequence designates the element type (which must be a complete object type), and the declarator has the form:\n[ static(optional) qualifiers(optional) expression(optional) ]   (1)\n[ qualifiers(optional) static(optional) expression(optional) ]   (2)\n[ qualifiers(optional) * ]   (3)\n\nexpression   -   any expression other than comma operator, designates the number of elements in the array\nqualifiers   -   any combination of const, restrict, or volatile qualifiers, only allowed in function parameter lists; this qualifies the pointer type to which this array parameter is transformed\n\n\nExplanation\n   There are several variations of array types: arrays of known constant size, variable-length arrays, and arrays of unknown size.\n   If expression in an array declarator is an integer constant expression with a value greater than zero and the element type is a type with a known constant size (that is, elements are not VLA) (since C99), then the declarator declares an array of constant known size:\n   Arrays of constant known size can use array initializers to provide their initial values:\nIn function parameter lists, additional syntax elements are allowed within the array declarators: the keyword static and qualifiers, which may appear in any order before the size expression (they may also appear even when the size expression is omitted).\nIn each function call to a function where a parameter of array type uses the keyword static between [ and ], the value of the actual parameter must be a valid pointer to the first element of an array with at least as many elements as specified by expression:\nvoid fadd(double a[static 10], const double b[static 10])\n{ \n    for (int i = 0; i < 10; i++) {\n        if (a[i] < 0.0) return;\n        a[i] += b[i];\n    }\n}\n// a call to fadd performs compile-time bounds checking\n// and also permits optimizations such as prefetching 10 doubles \nint main(void)\n{\n    double a[10] = {0}, b[20] = {0};\n    fadd(a, b); // OK\n    double x[5] = {0};\n    fadd(x, b); // error: array argument is too small\n} If qualifiers are present, they qualify the pointer type to which the array parameter type is transformed:\nint f(const int a[20])\n{\n // in this function, a has type const int* (pointer to const int)\n}\nint g(const int a[const 20])\n{\n // in this function, a has type const int* const (const pointer to const int)\n} This is commonly used with the restrict type qualifier:\nvoid fadd(double a[static restrict 10],\n          const double b[static restrict 10])\n{\n    for (int i = 0; i < 10; i++) { // loop can be unrolled and reordered\n        if (a[i] < 0.0) break;\n        a[i] += b[i];\n    }\n}  Variable-length arrays If expression is not an integer constant expression, the declarator is for an array of variable size.\nEach time the flow of control passes over the declaration, expression is evaluated (and it must always evaluate to a value greater than zero), and the array is allocated (correspondingly, lifetime of a VLA ends when the declaration goes out of scope). The size of each VLA instance does not change during its lifetime, but on another pass over the same code, it may be allocated with a different size.\n{\n   int n = 1;\nlabel:\n   int a[n]; // re-allocated 10 times, each with a different size\n   printf(\"The array has %zu elements\\n\", sizeof a / sizeof *a);\n   if (n++ < 10) goto label; // leaving the scope of a VLA ends its lifetime\n} If the size is *, the declaration is for a VLA of unspecified size. Such declaration may only appear in a function prototype scope, and declares an array of a complete type. In fact, all VLA declarators in function prototype scope are treated as if expression were replaced by *.\nvoid foo(size_t x, int a[*]);\nvoid foo(size_t x, int a[x]) \n{\n    printf(\"%zu\\n\", sizeof a); // same as sizeof(int*)\n} Variable-length arrays and the types derived from them (pointers to them, etc) are commonly known as \"variably-modified types\" (VM). Objects of any variably-modified type may only be declared at block scope or function prototype scope.\nextern int n;\nint A[n];            // Error: file scope VLA\nextern int (*p2)[n]; // Error: file scope VM\nint B[100];          // OK: file-scope array of constant known size\nvoid fvla(int m, int C[m][m]); // OK: prototype-scope VLA VLA must have automatic storage duration. Pointers to VLA, but not VLA themselves may also have static storage duration. No VM type may have linkage.\nvoid fvla(int m, int C[m][m]) // OK: block scope/auto duration pointer to VLA\n{\n    typedef int VLA[m][m]; // OK: block scope VLA\n    int D[m];              // OK: block scope/auto duration VLA\n//  static int E[m]; // Error: static duration VLA\n//  extern int F[m]; // Error: VLA with linkage\n    int (*s)[m];     // OK: block scope/auto duration VM\n//  extern int (*r)[m]; // Error: VM with linkage\n    static int (*q)[m] = &B; // OK: block scope/static duration VM}\n} Variably-modified types cannot be members of structs or unions.\nstruct tag {\n    int z[n]; // Error: VLA struct member\n    int (*y)[n]; // Error: VM struct member\n};  (since C99)\nIf the compiler defines the macro constant __STDC_NO_VLA__ to integer constant 1, then VLA and VM types are not supported.\n (since C11)\n\n   If expression in an array declarator is omitted, it declares an array of unknown size. Except in function parameter lists (where such arrays are transformed to pointers) and when an initializer is available, such type is an incomplete type (note that VLA of unspecified size, declared with * as the size, is a complete type) (since C99):\nWithin a struct definition, an array of unknown size may appear as the last member (as long as there is at least one other named member), in which case it is a special case known as flexible array member. See struct for details:\nstruct s { int n; double d[]; }; // s.d is a flexible array member \nstruct s *s1 = malloc(sizeof (struct s) + (sizeof (double) * 8)); // as if d was double d[8]  (since C99)\n\n\nQualifiers\n   If an array type is declared with a const, volatile, restrict (since C99), or _Atomic (since C11) qualifier (which is possible through the use of typedef), the array type is not qualified, but its element type is:\n   Objects of array type are not modifiable lvalues, and although their address may be taken, they cannot appear on the left hand side of an assignment operator. However, structs with array members are modifiable lvalues and can be assigned:\n   Any lvalue expression of array type, when used in any context other than.\nas the operand of _Alignof   (since C11)\n\n   undergoes an implicit conversion to the pointer to its first element. The result is not an lvalue.\n   If the array was declared register, the behavior of the program that attempts such conversion is undefined.\n   When an array type is used in a function parameter list, it is transformed to the corresponding pointer type: int f(int a[2]) and int f(int* a) declare the same function. Since the function's actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:\n   When the element type of an array is another array, it is said that the array is multidimensional:\n   Note that when array-to-pointer conversion is applied, a multidimensional array is converted to a pointer to its first element, e.g., pointer to the first row:\nMultidimensional arrays may be variably modified in every dimension:\nint n = 10;\nint a[n][2*n];  (since C99)\n\n\nNotes\n   Zero-length array declarations are not allowed, even though some compilers offer them as extensions (typically as a pre-C99 implementation of flexible array members).\n   If the size expression of a VLA has side effects, they are guaranteed to be produced except when it is a part of a sizeof expression whose result doesn't depend on it:\n", "url": "https://devdocs.io/c/language/array\n"}, {"name": "Array initialization", "type": "STANDARD LIB", "description": "   When initializing an object of array type, the initializer must be either a string literal (optionally enclosed in braces) or be a brace-enclosed list of initialized for array members:\n= string_literal   (1)\n= {  expression , ... }  = {  designator(optional) expression , ... } \n  (2)   (until C99)(since C99)\n\n   Arrays of known size and arrays of unknown size may be initialized, but not VLAs. (since C99).\n   All array elements that are not initialized explicitly are initialized implicitly the same way as objects that have static storage duration.\n\nInitialization from strings\n   string literal (optionally enclosed in braces) may be used as the initializer for an array of matching type:\nu-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications) char16_t \n U-prefixed wide string literals can be used to initialize arrays of any type compatible with (ignoring cv-qualifications char32_t \n  (since C11)\n\n   Successive bytes of the string literal or wide characters of the wide string literal, including the terminating null byte/character, initialize the elements of the array:\n   If the size of the array is known, it may be one less than the size of the string literal, in which case the terminating null character is ignored:\n   Note that the contents of such array are modifiable, unlike when accessing a string literal directly with char* str = \"abc\";.\n\nInitialization from brace-enclosed lists\n   When an array is initialized with a brace-enclosed list of initializers, the first initializer in the list initializes the array element at index zero (unless a designator is specified) (since C99), and each subsequent initializer without a designator  (since C99)initializes the array element at index one greater than the one initialized by the previous initializer.\n   It's an error to provide more initializers than elements when initializing an array of known size (except when initializing character arrays from string literals).\nA designator causes the following initializer to initialize of the array element described by the designator. Initialization then continues forward in order, beginning with the next element after the one described by the designator.\nint n[5] = {[4]=5,[0]=1,2,3,4} // holds 1,2,3,4,5\n \nint a[MAX] = { // starts initializing a[0] = 1, a[1] = 3, ...\n    1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0\n}\n// for MAX=6,  array holds 1,8,6,4,2,0\n// for MAX=13, array holds 1,3,5,7,9,0,0,0,8,6,4,2,0 (\"sparse array\")  (since C99)\n\n   When initializing an array of unknown size, the largest subscript for which an initializer is specified determines the size of the array being declared.\n\nNested arrays\n   If the elements of an array are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:\n   If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding array element:\n   If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the sub-array, struct or union; any remaining initializers are left to initialize the next array element:\nArray designators may be nested; the bracketed constant expression for nested arrays follows the bracketed constant expression for the outer array:\nint y[4][3] = {[0][0]=1, [1][1]=1, [2][0]=1};  // row 0 initialized to {1, 0, 0}\n                                               // row 1 initialized to {0, 1, 0}\n                                               // row 2 initialized to {1, 0, 0}\n                                               // row 3 initialized to {0, 0, 0}  (since C99)\n\n\nNotes\n   The order of evaluation of subexpressions in an array initializer is indeterminately sequenced in C (but not in C++ since c++11):\n   In C, the braced list of an initializer cannot be empty. C++ allows empty list:\n   As with all other initialization, every expression in the initializer list must be a constant expression when initializing arrays of static or thread-local storage duration:\n", "url": "https://devdocs.io/c/language/array_initialization\n"}, {"name": "ASCII Chart", "type": "STANDARD LIB", "description": "   The following chart contains all 128 ASCII decimal (dec), octal (oct), hexadecimal (hex) and character (ch) codes.\ndec   oct   hex   ch     dec   oct   hex   ch     dec   oct   hex   ch     dec   oct   hex   ch\n0\n  0\n 00 \nNUL (null)   32\n 40 20 (space)   64\n 100 40 \n@    96\n 140 60 \n`\n1\n  1\n 01 \nSOH (start of header)   33\n 41 21 \n!   65\n 101 41 \nA    97\n 141 61 \na\n2\n  2\n 02 \nSTX (start of text)   34\n 42 22 \n\"   66\n 102 42 \nB    98\n 142 62 \nb\n3\n  3\n 03 \nETX (end of text)   35\n 43 23 \n#   67\n 103 43 \nC    99\n 143 63 \nc\n4\n  4\n 04 \nEOT (end of transmission)   36\n 44 24 \n$   68\n 104 44 \nD   100\n 144 64 \nd\n5\n  5\n 05 \nENQ (enquiry)   37\n 45 25 \n%   69\n 105 45 \nE   101\n 145 65 \ne\n6\n  6\n 06 \nACK (acknowledge)   38\n 46 26 \n&   70\n 106 46 \nF   102\n 146 66 \nf\n7\n  7\n 07 \nBEL (bell)   39\n 47 27 \n'   71\n 107 47 \nG   103\n 147 67 \ng\n8\n 10 08 \nBS (backspace)   40\n 50 28 \n(   72\n 110 48 \nH   104\n 150 68 \nh\n9\n 11 09 \nHT (horizontal tab)   41\n 51 29 \n)   73\n 111 49 \nI   105\n 151 69 \ni\n10\n 12 0a \nLF (line feed - new line)   42\n 52 2a \n*   74\n 112 4a \nJ   106\n 152 6a \nj\n11\n 13 0b \nVT (vertical tab)   43\n 53 2b \n+   75\n 113 4b \nK   107\n 153 6b \nk\n12\n 14 0c \nFF (form feed - new page)   44\n 54 2c \n,   76\n 114 4c \nL   108\n 154 6c \nl\n13\n 15 0d \nCR (carriage return)   45\n 55 2d \n-   77\n 115 4d \nM   109\n 155 6d \nm\n14\n 16 0e \nSO (shift out)   46\n 56 2e \n.   78\n 116 4e \nN   110\n 156 6e \nn\n15\n 17 0f \nSI (shift in)   47\n 57 2f \n/   79\n 117 4f \nO   111\n 157 6f \no\n16\n 20 10 \nDLE (data link escape)   48\n 60 30 \n0   80\n 120 50 \nP   112\n 160 70 \np\n17\n 21 11 \nDC1 (device control 1)   49\n 61 31 \n1   81\n 121 51 \nQ   113\n 161 71 \nq\n18\n 22 12 \nDC2 (device control 2)   50\n 62 32 \n2   82\n 122 52 \nR   114\n 162 72 \nr\n19\n 23 13 \nDC3 (device control 3)   51\n 63 33 \n3   83\n 123 53 \nS   115\n 163 73 \ns\n20\n 24 14 \nDC4 (device control 4)   52\n 64 34 \n4   84\n 124 54 \nT   116\n 164 74 \nt\n21\n 25 15 \nNAK (negative acknowledge)   53\n 65 35 \n5   85\n 125 55 \nU   117\n 165 75 \nu\n22\n 26 16 \nSYN (synchronous idle)   54\n 66 36 \n6   86\n 126 56 \nV   118\n 166 76 \nv\n23\n 27 17 \nETB (end of transmission block)   55\n 67 37 \n7   87\n 127 57 \nW   119\n 167 77 \nw\n24\n 30 18 \nCAN (cancel)   56\n 70 38 \n8   88\n 130 58 \nX   120\n 170 78 \nx\n25\n 31 19 \nEM (end of medium)   57\n 71 39 \n9   89\n 131 59 \nY   121\n 171 79 \ny\n26\n 32 1a \nSUB (substitute)   58\n 72 3a \n:   90\n 132 5a \nZ   122\n 172 7a \nz\n27\n 33 1b \nESC (escape)   59\n 73 3b \n;   91\n 133 5b \n[   123\n 173 7b \n{\n28\n 34 1c \nFS (file separator)   60\n 74 3c \n<   92\n 134 5c \n\\    124\n 174 7c \n|\n29\n 35 1d \nGS (group separator)   61\n 75 3d \n=   93\n 135 5d \n]   125\n 175 7d \n}\n30\n 36 1e \nRS (record separator)   62\n 76 3e \n>   94\n 136 5e \n^   126\n 176 7e \n~\n31\n 37 1f \nUS (unit separator)   63\n 77 3f \n?   95\n 137 5f \n_   127\n 177 7f \nDEL (delete)\n\n   Note: in Unicode, the ASCII character block is known as U+0000..U+007F Basic Latin.\n\nSee also\n", "url": "https://devdocs.io/c/language/ascii\n"}, {"name": "Assignment operators", "type": "STANDARD LIB", "description": "   Assignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right.\nOperator   Operator name   Example   Description   Equivalent of\n=   basic assignment   a = b   a becomes equal to b   N/A\n+=   addition assignment   a += b   a becomes equal to the addition of a and b   a = a + b\n-=   subtraction assignment   a -= b   a becomes equal to the subtraction of b from a   a = a - b\n*=   multiplication assignment   a *= b   a becomes equal to the product of a and b   a = a * b\n/=   division assignment   a /= b   a becomes equal to the division of a by b   a = a / b\n%=   modulo assignment   a %= b   a becomes equal to the remainder of a divided by b   a = a % b\n&=   bitwise AND assignment   a &= b   a becomes equal to the bitwise AND of a and b   a = a & b\n|=   bitwise OR assignment   a |= b   a becomes equal to the bitwise OR of a and b   a = a | b\n^=   bitwise XOR assignment   a ^= b   a becomes equal to the bitwise XOR of a and b   a = a ^ b\n<<=   bitwise left shift assignment   a <<= b   a becomes equal to a left shifted by b   a = a << b\n>>=   bitwise right shift assignment   a >>= b   a becomes equal to a right shifted by b   a = a >> b\n\n\nSimple assignment\n   The simple assignment operator expressions have the form.\nlhs = rhs\n\n   where.\nlhs   -   modifiable lvalue expression of any complete object type\nrhs   -   expression of any type implicitly convertible to lhs or compatible with lhs\n\n   Assignment performs implicit conversion from the value of rhs to the type of rhs and then replaces the value in the object designated by lhs with the converted value of rhs.\n   Assignment also returns the same value as what was stored in lhs (so that expressions such as a = b = c are possible). The value category of the assignment operator is non-lvalue (so that expressions such as (a=b)=c are invalid).\n   rhs and lhs must satisfy one of the following:\n   If rhs and lhs overlap in memory (e.g. they are members of the same union), the behavior is undefined unless the overlap is exact and the types are compatible.\n   Although arrays are not assignable, an array wrapped in a struct is assignable to another object of the same (or compatible) struct type.\n   The side effect of updating lhs is sequenced after the value computations, but not the side effects of lhs and rhs themselves and the evaluations of the operands are, as usual, unsequenced relative to each other (so the expressions such as i=++i; are undefined).\n   Assignment strips extra range and precision from floating-point expressions (see FLT_EVAL_METHOD).\n   In C++, assignment operators are lvalue expressions, not so in C.\n\nCompound assignment\n   The compound assignment operator expressions have the form.\nlhs op rhs\n\n   where.\nop   -   one of *=, /= %=, += -=, <<=, >>=, &=, ^=, |=\nlhs, rhs   -   expressions with arithmetic types (where lhs may be qualified or atomic), except when op is += or -=, which also accept pointer types with the same restrictions as + and -\n\n   The expression lhs @= rhs is exactly the same as lhs = lhs @ ( rhs ), except that lhs is evaluated only once.\nIf lhs has atomic type, the operation behaves as a single atomic read-modify-write operation with memory order memory_order_seq_cst.\nFor integer atomic types, the compound assignment @= is equivalent to:\nT1* addr = &lhs;\nT2 val = rhs;\nT1 old = *addr;\nT1 new;\ndo { new = old @ val } while (!atomic_compare_exchange_strong(addr, &old, new);  (since C11)\n\n", "url": "https://devdocs.io/c/language/operator_assignment\n"}, {"name": "atomic types", "type": "STANDARD LIB", "description": "\nSyntax\n_Atomic ( type-name )   (1)   (since C11)\n_Atomic type-name   (2)   (since C11)\n\ntype-name   -   any type other than array or function. For (1), type-name also cannot be atomic or cvr-qualified\n\n   The header <stdatomic.h> defines 37 convenience macros, from atomic_bool to atomic_uintmax_t, which simplify the use of this keyword with built-in and library types.\n\nExplanation\n   Objects of atomic types are the only objects that are free from data races, that is, they may be modified by two threads concurrently or modified by one and read by another.\n   Each atomic object has its own associated modification order, which is a total order of modifications made to that object. If, from some thread's point of view, modification A of some atomic M happens-before modification B of the same atomic M, then in the modification order of M, A occurs before B.\n   Note that although each atomic object has its own modification order, it is not a total order; different threads may observe modifications to different atomic objects in different orders.\n   There are four coherences that are guaranteed for all atomic operations:\n   Some atomic operations are also synchronization operations; they may have additional release semantics, acquire semantics, or sequentially-consistent semantics. See memory_order.\n   Built-in increment and decrement operators and compound assignment are read-modify-write atomic operations with total sequentially consistent ordering (as if using memory_order_seq_cst). If less strict synchronization semantics are desired, the standard library functions may be used instead.\n   Atomic properties are only meaningful for lvalue expressions. Lvalue-to-rvalue conversion (which models a memory read from an atomic location to a CPU register) strips atomicity along with other qualifiers.\n\nNotes\n   If the macro constant __STDC_NO_ATOMICS__(C11) is defined by the compiler, the keyword _Atomic as well as the header <stdatomic.h>, is not provided.\n   Accessing a member of an atomic struct/union is undefined behavior.\n   The library type sig_atomic_t does not provide inter-thread synchronization or memory ordering, only atomicity.\n   The volatile types do not provide inter-thread synchronization, memory ordering, or atomicity.\n\nKeywords\n   _Atomic.\n", "url": "https://devdocs.io/c/language/atomic\n"}, {"name": "Basic concepts", "type": "STANDARD LIB", "description": "   This section provides definitions for the specific terminology and the concepts used when describing the C programming language.\n   A C program is a sequence of text files (typically header and source files) that contain declarations. They undergo translation to become an executable program, which is executed when the OS calls its main function (unless it is itself the OS or another freestanding program, in which case the entry point is implementation-defined).\n   Certain words in a C program have special meaning, they are keywords. Others can be used as identifiers, which may be used to identify objects, functions, struct, union, or enumeration tags, their members, typedef names, labels, or macros.\n   Each identifier (other than macro) is only valid within a part of the program called its scope and belongs to one of four kinds of name spaces. Some identifiers have linkage which makes them refer to the same entities when they appear in different scopes or translation units.\n   Definitions of functions include sequences of statements and declarations, some of which include expressions, which specify the computations to be performed by the program.\n   Declarations and expressions create, destroy, access, and manipulate objects. Each object, function, and expression in C is associated with a type.\n\nSee also\n", "url": "https://devdocs.io/c/language/basic_concepts\n"}, {"name": "Bit fields", "type": "STANDARD LIB", "description": "   Declares a member with explicit width, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.\n   A bit field declaration is a struct or union member declaration which uses the following declarator:\nidentifier(optional) : width\n\nidentifier   -   the name of the bit field that is being declared. The name is optional: nameless bit fields introduce the specified number of bits of padding\nwidth   -   an integer constant expression with a value greater or equal to zero and less or equal the number of bits in the underlying type. When greater than zero, this is the number of bits that this bit field will occupy. The value zero is only allowed for nameless bit fields and has special meaning: it specifies that the next bit field in the class definition will begin at an allocation unit's boundary.\n\n\nExplanation\n   Bit fields can have only one of four types (possibly const or volatile qualified):\n   Additional implementation-defined types may be acceptable. It is also implementation-defined whether a bit field may have atomic type. (since C11) The number of bits in a bit field (width) sets the limit to the range of values it can hold:\n   Multiple adjacent bit fields are permitted to be (and usually are) packed together:\n   The special unnamed bit field of width zero breaks up padding: it specifies that the next bit field begins at the beginning of the next allocation unit:\n   Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers to bit fields are not possible. Bit fields cannot be used with sizeof and alignas  (since C11).\n\nNotes\n   The following properties of bit fields are undefined:\n   The following properties of bit fields are unspecified:\n   The following properties of bit fields are implementation-defined:\n   Even though the number of bits in the object representation of _Bool is at least CHAR_BIT, the width of the bit field of type _Bool cannot be greater than 1.\n   In the C++ programming language, the width of a bit field can exceed the width of the underlying type.\n", "url": "https://devdocs.io/c/language/bit_field\n"}, {"name": "break statement", "type": "STANDARD LIB", "description": "   Causes the enclosing for, while or do-while loop or  switch statement to terminate.\n   Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.\n\nSyntax\nbreak ;\n\n   Appears only within the statement of a loop body (while, do, for) or within the statement of a switch.\n\nExplanation\n   After this statement the control is transferred to the statement or declaration immediately following the enclosing loop or switch, as if by goto.\n\nKeywords\n   break.\n\nNotes\n   A break statement cannot be used to break out of multiple nested loops. The goto statement may be used for this purpose.\n", "url": "https://devdocs.io/c/language/break\n"}, {"name": "C language", "type": "STANDARD LIB", "description": "   This is a reference of the core C language constructs.\nBasic concepts.\n Comments  ASCII chart  Translation phases  Identifier  -  Scope -  Lifetime  Lookup and Name Spaces  Type -  Arithmetic types  Objects and Alignment   The main function  As-if rule  Undefined behavior  Memory model and Data races.\n Keywords.\n Preprocessor.\n #if - #ifdef - #ifndef  #define - # - ##  #include -  #pragma  #line -  #error.\n Statements.\nif - switch for while - do-while continue - break goto - return.\n   Expressions.\n Value categories  Evaluation order and sequencing  Constants and literals  Integer constants  Floating constants  Character constants  String literals  Compound literals(C99)  Constant expressions  Implicit conversions  Operators  Member access and indirection  Logical -  Comparison  Arithmetic -  Assignment  Increment and Decrement  Call, Comma, Ternary sizeof - _Alignof(C11)  Cast operators  Operator precedence  Generic selection(C11).\n Initialization.\n Scalar  Array  Structure/Union \n   Declarations.\n Pointers -  Arrays  Enumerations  Storage duration and Linkage  const - volatile - restrict(C99) struct - union -  Bit fields _Alignas(C11) - typedef _Static_assert(C11)  Atomic types(C11)  External and tentative definitions.\n Functions.\n Function declaration  Function definition inline(C99) - _Noreturn(C11)  Variadic arguments.\nMiscellaneous.\n History of C  Conformance  Inline assembly  Signal handling   Analyzability(C11).\n\n\nSee also\n", "url": "https://devdocs.io/c/language\n"}, {"name": "C Operator Precedence", "type": "STANDARD LIB", "description": "   The following table lists the precedence and associativity of C operators. Operators are listed top to bottom, in descending precedence.\nPrecedence   Operator   Description   Associativity\n1   ++ --   Suffix/postfix increment and decrement   Left-to-right\n()   Function call\n[]   Array subscripting\n.   Structure and union member access\n->   Structure and union member access through pointer\n(type){list}   Compound literal(C99)\n2   ++ --   Prefix increment and decrement[note 1]   Right-to-left\n+ -   Unary plus and minus\n! ~   Logical NOT and bitwise NOT\n(type)   Type cast\n*   Indirection (dereference)\n&   Address-of\nsizeof   Size-of[note 2]\n_Alignof   Alignment requirement(C11)\n3   * / %   Multiplication, division, and remainder   Left-to-right\n4   + -   Addition and subtraction\n5   << >>   Bitwise left shift and right shift\n6   < <=   For relational operators < and \u2264 respectively\n> >=   For relational operators > and \u2265 respectively\n7   == !=   For relational = and \u2260 respectively\n8   &   Bitwise AND\n9   ^   Bitwise XOR (exclusive or)\n10   |   Bitwise OR (inclusive or)\n11   &&   Logical AND\n12   ||   Logical OR\n13   ?:   Ternary conditional[note 3]   Right-to-Left\n14[note 4]   =   Simple assignment\n+= -=   Assignment by sum and difference\n*= /= %=   Assignment by product, quotient, and remainder\n<<= >>=   Assignment by bitwise left shift and right shift\n&= ^= |=   Assignment by bitwise AND, XOR, and OR\n15   ,   Comma   Left-to-right\n\n   When parsing an expression, an operator which is listed on some row will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it. For example, the expression *p++ is parsed as *(p++), and not as (*p)++.\n   Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same precedence, in the given direction. For example, the expression a=b=c is parsed as a=(b=c), and not as (a=b)=c because of right-to-left associativity.\n\nNotes\n   Precedence and associativity are independent from order of evaluation.\n   The standard itself doesn't specify precedence levels. They are derived from the grammar.\n   In C++, the conditional operator has the same precedence as assignment operators, and prefix ++ and -- and assignment operators don't have the restrictions about their operands.\n   Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (sizeof ++*p is sizeof(++(*p))) and unary postfix operators always associate left-to-right (a[1][2]++ is ((a[1])[2])++). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: a.b++ is parsed (a.b)++ and not a.(b++).\n", "url": "https://devdocs.io/c/language/operator_precedence\n"}, {"name": "cast operator", "type": "STANDARD LIB", "description": "   Performs explicit type conversion.\n\nSyntax\n( type-name ) expression\n\n   where.\ntype-name   -   either the type void or any scalar type\nexpression   -   any expression of scalar type (unless type-name is void, in which case it can be anything)\n\n\nExplanation\n   If type-name is void, then expression is evaluated for its side-effects and its returned value is discarded, same as when expression is used on its own, as an expression statement.\n   Otherwise, if type-name is exactly the type of expression, nothing is done (except that if expression has floating type and is represented with greater range and precision than its type indicates -- see below).\n   Otherwise, the value of expression is converted to the type named by type-name, as follows:\n   Every implicit conversion as if by assignment is allowed.\n   In addition to the implicit conversions, the following conversions are allowed:\n   In any case (both when executing an implicit conversion and in the same-type cast), if expression and type-name are floating types and expression is represented with greater range and precision than its type indicates (see FLT_EVAL_METHOD, the range and precision are stripped off to match the target type.\n   The value category of the cast expression is always non-lvalue.\n\nNotes\n   Because const, volatile, restrict, and atomic qualifiers have effect on lvalues only, a cast to a cvr-qualified or atomic type is exactly equivalent to the cast to the corresponding unqualified type.\n   The cast to void is sometimes useful to silence compiler warnings about unused results.\n   The conversions not listed here are not allowed. In particular,\n", "url": "https://devdocs.io/c/language/cast\n"}, {"name": "character constant", "type": "STANDARD LIB", "description": "\nSyntax\n' c-char '   (1)\nu ' c-char ' (since C11)   (2)\nU ' c-char ' (since C11)   (3)\nL ' c-char '   (4)\n' c-char-sequence '   (5)\n\n   where.\nuniversal character name, \\u... or \\U... as defined in escape sequences.   (since C99)\n\n\nNotes\n   Multicharacter constants were inherited by C from the B programming language. Although not specified by the C standard, compilers implement multicharacter constants as specified in B: the values of each char in the constant initialize successive bytes of the resulting integer, in big-endian zero-padded right-adjusted order, e.g. the value of '\\1' is 0x00000001 and the value of '\\1\\2\\3\\4' is 0x01020304.\n   In C++, ordinary character constants have type char, rather than int.\n   Unlike integer constants, a character constant may have a negative value if char is signed: on such implementations '\\xFF' is an int with the value -1.\n   When used in a controlling expression of #if or #elif, character constants may be interpreted in terms of the source character set, the execution character set, or some other implementation-defined character set.\n", "url": "https://devdocs.io/c/language/character_constant\n"}, {"name": "Comments", "type": "STANDARD LIB", "description": "   Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code.\n\nSyntax\n/* comment */   (1)\n// comment   (2)   (since C99)\n\n   All comments are removed from the program at translation phase 3 by replacing each comment with a single whitespace character.\n\nC-style\n   C-style comments are usually used to comment large blocks of text or small fragments of code; however, they can be used to comment single lines. To insert text as a C-style comment, simply surround the text with /* and */. C-style comments tell the compiler to ignore all content between /* and */. Although it is not part of the C standard, /** and */ are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment.\n   Except within a character constant, a string literal, or a comment, the characters /* introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters */ that terminate the comment. C-style comments cannot be nested.\nC++-style C++-style comments are usually used to comment single lines of text or code; however, they can be placed together to form multi-line comments. To insert text as a C++-style comment, simply precede the text with // and follow the text with the new line character. C++-style comments tell the compiler to ignore all content between // and a new line.\nExcept within a character constant, a string literal, or a comment, the characters // introduce a comment that includes all multibyte characters up to, but not including, the next new-line character. The contents of such a comment are examined only to identify multibyte characters and to find the new-line character that terminates the comment. C++-style comments can be nested:\n//  y = f(x);   // invoke algorithm A C-style comment may appear within a C++-style comment:\n//  y = f(x);   /* invoke algorithm */ A C++-style comment may appear within a C-style comment; this is a mechanism for excluding a small block of source code:\n/*\n    y = f(x);   // invoke algorithms\n    z = g(x);\n*/  (since C99)\n\n\nNotes\n   Because comments are removed before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.\n   Besides commenting out, other mechanisms used for source code exclusion are:\n   and.\n   The introduction of // comments in C99 was a breaking change in some rare circumstances:\n", "url": "https://devdocs.io/c/comment\n"}, {"name": "Comparison operators", "type": "STANDARD LIB", "description": "   Comparison operators are binary operators that test a condition and return 1 if that condition is logically true and 0 if that condition is false.\nOperator   Operator name   Example   Description\n==   equal to   a == b   a is equal to b\n!=   not equal to   a != b   a is not equal to b\n<   less than   a < b   a is less than b\n>   greater than   a > b   a is greater than b\n<=   less than or equal to   a <= b   a is less than or equal to b\n>=   greater than or equal to   a >= b   a is greater than or equal to b\n\n\nRelational operators\n   The relational operator expressions have the form.\nlhs < rhs   (1)\nlhs > rhs   (2)\nlhs <= rhs   (3)\nlhs >= rhs   (4)\n\n   The type of any relational operator expression is int, and its value (which is not an lvalue) is 1 when the specified relationship holds true and \u200b0\u200b when the specified relationship does not hold.\n   If lhs and rhs are expressions of any real type, then.\n   Note that complex and imaginary numbers cannot be compared with these operators.\n   If lhs and rhs are expressions of pointer type, they must be both pointers to objects of compatible types, except that qualifications of the pointed-to objects are ignored.\n\nEquality operators\n   The equality operator expressions have the form.\nlhs == rhs   (1)\nlhs != rhs   (2)\n\n   The type of any equality operator expression is int, and its value (which is not an lvalue) is 1 when the specified relationship holds true and \u200b0\u200b when the specified relationship does not hold.\n   (as with relational operators, pointers to objects that aren't elements of any array behave as pointers to elements of arrays of size 1).\n   Objects of struct type do not compare equal automatically, and comparing them with memcmp is not reliable because the padding bytes may have any values.\n   Because pointer comparison works with pointers to void, the macro NULL may be defined as (void*)0 in C, although that would be invalid in C++ where void pointers do not implicitly convert to typed pointers.\n   Care must be taken when comparing floating-point values for equality, because the results of many operations cannot be represented exactly and must be rounded. In practice, floating-point numbers are usually compared allowing for the difference of one or more units of the last place.\n", "url": "https://devdocs.io/c/language/operator_comparison\n"}, {"name": "compound literals", "type": "STANDARD LIB", "description": "   Constructs an unnamed object of specified type in-place, used when a variable of array, struct, or union type would be needed only once.\n\nSyntax\n( type ) {  initializer-list }      (since C99)\n\n   where.\ntype   -   a type name specifying any complete object type or an array of unknown size, but not a VLA\ninitializer-list   -   list of initializers suitable for initialization of an object of type\n\n\nExplanation\n   The compound literal expression constructs an unnamed object of the type specified by type and initializes it as specified by initializer-list.\n   The type of the compound literal is type (except when type is an array of unknown size; its size is deduced from the initializer-list as in array initialization).\n   The value category of a compound literal is lvalue (its address can be taken).\n   The unnamed object to which the compound literal evaluates has static storage duration if the compound literal occurs at file scope and automatic storage duration if the compound literal occurs at block scope (in which case the object's lifetime ends at the end of the enclosing block).\n\nNotes\n   Compound literals of const-qualified character or wide character array types may share storage with string literals.\n   Each compound literal creates only a single object in its scope:\n   Because compound literals are unnamed, a compound literal cannot reference itself (a named struct can include a pointer to itself).\n   Although the syntax of a compound literal is similar to a cast, the important distinction is that a cast is a non-lvalue expression while a compound literal is an lvalue.\n", "url": "https://devdocs.io/c/language/compound_literal\n"}, {"name": "Conformance", "type": "STANDARD LIB", "description": "   Conformance has a three-fold definition:\n\nExplanation\n   The standard does not define any minimum implementation limit on translation units. A hosted environment has an operating system; a freestanding environment does not. A program running in a hosted environment may use all features described in the library clause (clause 7); a program running in a freestanding environment may use a subset of library features required by clause 4.\n", "url": "https://devdocs.io/c/language/conformance\n"}, {"name": "const type qualifier", "type": "STANDARD LIB", "description": "   Each individual type in the C type system has several qualified versions of that type, corresponding to one, two, or all three of the const, volatile, and, for pointers to object types, restrict qualifiers. This page describes the effects of the const qualifier.\n   Objects declared with const-qualified types may be placed in read-only memory by the compiler, and if the address of a const object is never taken in a program, it may not be stored at all.\n   const semantics apply to lvalue expressions only; whenever a const lvalue expression is used in context that does not require an lvalue, its const qualifier is lost (note that volatile qualifier, if present, isn't lost).\n   The lvalue expressions that designate objects of const-qualified type and the lvalue expressions that designate objects of struct or union type with at least one member of const-qualified type (including members of recursively contained aggregates or unions), are not modifiable lvalues. In particular, they are not assignable:\n   A member of a const-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the . operator or the -> operator).\n   If an array type is declared with the const type qualifier (through the use of typedef), the array type is not const-qualified, but its element type is. If a function type is declared with the const type qualifier (through the use of typedef), the behavior is undefined.\nconst-qualified compound literals do not necessarily designate distinct objects; they may share storage with other compound literals and with string literals that happen to have the same or overlapping representation.\nconst int* p1 = (const int[]){1, 2, 3};\nconst int* p2 = (const int[]){2, 3, 4}; // the value of p2 may equal p1+1\n_Bool b = \"foobar\" + 3 == (const char[]){\"bar\"}; // the value of b may be 1  (since C99)\n\n   A pointer to an non-const type can be implicitly converted to a pointer to const-qualified version of the same or compatible type. The reverse conversion can be performed with a cast expression.\n   Note that pointer to pointer to T is not convertible to pointer to pointer to const T; for two types to be compatible, their qualifications must be identical.\n   Any attempt to modify an object whose type is const-qualified results in undefined behavior.\nIn a function declaration, the keyword const may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.\nThe following two declarations declare the same function:\nvoid f(double x[const], const double y[const]);\nvoid f(double * const x, const double * const y);  (since C99)\n\n\nKeywords\n   const.\n\nNotes\n   C adopted the const qualifier from C++, but unlike in C++, expressions of const-qualified type in C are not constant expressions; they may not be used as case labels or to initialize static and thread storage duration objects, enumerators, or bit field sizes. When they are used as array sizes, the resulting arrays are VLAs.\n", "url": "https://devdocs.io/c/language/const\n"}, {"name": "Constant expressions", "type": "STANDARD LIB", "description": "   Several varieties of expressions are known as constant expressions.\n\nPreprocessor constant expression\n   The expression following #if or #elif must expand to.\n   Character constants, when evaluated in #if-expressions, may be interpreted in the source character set, the execution character set, or some other implementation-defined character set.\nInteger arithmetic in #if-expressions is performed using the semantics of intmax_t for signed types and uintmax_t for unsigned types.\n (since C99)\n\n\nInteger constant expression\n   An integer constant expression is an expression that consists only of.\n_Alignof operators   (since C11)\n\n   Integer constant expressions are evaluated at compile time. The following contexts require expressions that are known as integer constant expressions':\nThe index in an array designator   (since C99)\n\nThe first argument of _Static_assert \n The integer argument of _Alignas \n  (since C11)\n\n\nStatic initializer\n   Expressions that are used in the initializers of objects with static and thread_local storage duration must be expressions that may be one of the following.\n_Alignof operators   (since C11)\n\n   Unlike with integer constant expressions, static initializer expressions are not required to be evaluated at compile time; the compiler is at liberty to turn such initializers into executable code which is invoked prior to program startup.\n   The value of a floating-point static initializer is never less accurate than the value of the same expression executed at run time, but it may be better.\n\nFloating-point constant expressions\n   Arithmetic constant expressions of floating-point types that are not used in static initializers are always evaluated as-if during run-time and are affected by the current rounding (if FENV_ACCESS is on) and report errors as specified in math_errhandling.\n\nNotes\n   If an expression evaluates to a value that is not representable by its type, it cannot be used as a constant expression.\n", "url": "https://devdocs.io/c/language/constant_expression\n"}, {"name": "continue statement", "type": "STANDARD LIB", "description": "   Causes the remaining portion of the enclosing for, while or  do-while loop body to be skipped.\n   Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.\n\nSyntax\ncontinue ;\n\n\nExplanation\n   The continue statement causes a jump, as if by goto, to the end of the loop body (it may only appear within the loop body of for, while, and do-while loops).\n   For while loop, it acts as.\n   For do-while loop, it acts as:\n   For for loop, it acts as:\n\nKeywords\n   continue.\n", "url": "https://devdocs.io/c/language/continue\n"}, {"name": "Declarations", "type": "STANDARD LIB", "description": "   A declaration is a C language construct that introduces one or more identifiers into the program and specifies their meaning and properties.\n   Declarations may appear in any scope. Each declaration ends with a semicolon (just like a statement) and consists of two distinct parts:\nspecifiers-and-qualifiers declarators-and-initializers ;\n\n   where.\nspecifiers-and-qualifiers   -   whitespace-separated list of, in any order, \n type specifiers: \n\n void \n the name of an arithmetic type \n the name of an atomic type \n a name earlier introduced by a typedef declaration \n struct, union, or enum specifier \n\n zero or one storage-class specifiers: typedef, auto, register, static, extern, thread_local \n zero or more type qualifiers: const, volatile, restrict, _Atomic \n (only when declaring functions), zero or more function specifiers: inline, _Noreturn \n zero or more alignment specifiers: _Alignas\ndeclarators-and-initializers   -   comma-separated list of declarators (each declarator provides additional type information and/or the identifier to declare). Declarators may be accompanied by initializers. The enum, struct, and union declarations may omit declarators, in which case they only introduce the enumeration constants and/or tags.\n\n   For example,\n   The type of each identifier introduced in a declaration is determined by a combination of the type specified by the type specifier and the type modifications applied by its declarator.\n\nDeclarators\n   Each declarator is one of the following:\nidentifier   (1)\n( declarator )   (2)\n* qualifiers(optional) declarator   (3)\nnoptr-declarator [ static(optional) qualifiers(optional) expression ] noptr-declarator [ qualifiers(optional) * ]\n  (4)\nnoptr-declarator ( parameters-or-identifiers )   (5)\n\n   The reasoning behind this syntax is that when the identifier declared by the declarator appears in an expression of the same form as the declarator, it would have the type specified by the type specifier sequence.\n   The end of every declarator that is not part of another declarator is a sequence point.\n\nDefinitions\n   A definition is a declaration that provides all information about the identifiers it declares.\n   Every declaration of an enum or a typedef is a definition.\n   For functions, a declaration that includes the function body is a function definition:\n   For objects, a declaration that allocates storage (automatic or static, but not extern) is a definition, while a declaration that does not allocate storage (external declaration) is not.\n   For structs and unions, declarations that specify the list of members are definitions:\n\nRedeclaration\n   A declaration cannot introduce an identifier if another declaration for the same identifier in the same scope appears earlier, except that.\n   These rules simplify the use of header files.\n\nNotes\nIn C89, declarations within any compound statement (block scope) must appear in the beginning of the block, before any statements.\nAlso, in C89, functions returning int may be implicitly declared by the function call operator and function parameters of type int do not have to be declared when using old-style function definitions.\n (until C99)\n\n   Empty declarators are prohibited; a declaration must be a static_assert declaration or  (since C11) have at least one declarator or declare at least one struct/union/enum tag, or introduce at least one enumeration constant.\nIf any part of a declarator is a VLA array declarator, the entire declarator's type is known as \"variably-modified type\". Types defined from variably-modified types are also variably modified (VM).\nDeclarations of any variably-modified types may appear only at block scope or function prototype scope and cannot be members of structs or unions. Although VLA can only have automatic storage duration, a VM type such as a pointer to a VLA may be static. There are other restrictions on the use of VM types, see goto, switch. longjmp.\n (since C99)\n\nstatic_asserts are considered to be declarations from the point of view of the C grammar (so that they may appear anywhere a declaration may appear), but they do not introduce any identifiers and do not follow the declaration syntax.\n (since C11)\n\n", "url": "https://devdocs.io/c/language/declarations\n"}, {"name": "do-while loop", "type": "STANDARD LIB", "description": "   Executes a statement repeatedly until the value of condition becomes false. The test takes place after each iteration.\n\nSyntax\ndo statement while ( expression ) ;\n\nexpression   -   any expression of scalar type. This expression is evaluated after each iteration, and if it compares equal to zero, the loop is exited.\nstatement   -   any statement, typically a compound statement, which is the body of the loop\n\n\nExplanation\n   A do-while statement causes the statement (also called the loop body) to be executed repeatedly until the expression (also called controlling expression) compares equal to 0. The repetition occurs regardless of whether the loop body is entered normally or by a goto into the middle of statement.\n   The evaluation of expression takes place after each execution of statement (whether entered normally or by a goto). If the controlling expression needs to be evaluated before the loop body, the while loop or the for loop may be used.\n   If the execution of the loop needs to be terminated at some point,  break statement can be used as terminating statement.\n   If the execution of the loop needs to be continued at the end of the loop body,  continue statement can be used as a shortcut.\n   A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; do {...} while(true); is always an endless loop.\nAs with all other selection and iteration statements, the do-while statement establishes block scope: any identifier introduced in the expression goes out of scope after the statement.\n (since C99)\n\n\nNotes\n   Boolean and pointer expressions are often used as loop controlling expressions. The boolean value false and the null pointer value of any pointer type compare equal to zero.\n\nKeywords\n   do, while.\n", "url": "https://devdocs.io/c/language/do\n"}, {"name": "Enumerations", "type": "STANDARD LIB", "description": "   An enumerated type is a distinct type whose value is a value of its underlying type (see below), which includes the values of explicitly named constants (enumeration constants).\n\nSyntax\n   Enumerated type is declared using the following enumeration specifier as the type specifier in the declaration grammar:\nenum identifier(optional) { enumerator-list }\n\n   where enumerator-list is a comma-separated list (with trailing comma permitted) (since C99) of enumerators, each of which has the form:\nenumerator   (1)\nenumerator = constant-expression   (2)\n\n   where.\nidentifier, enumerator   -   identifiers that are introduced by this declaration\nconstant-expression   -   integer constant expression whose value is representable as a value of type int\n\n   As with struct or union, a declaration that introduced an enumerated type and one or more enumeration constants may also declare one or more objects of that type or type derived from it.\n\nExplanation\n   Each enumerator that appears in the body of an enumeration specifier becomes an integer constant with type int in the enclosing scope and can be used whenever integer constants are required (e.g. as a case label or as a non-VLA array size).\n   If enumerator is followed by = constant-expression, its value is the value of that constant expression. If enumerator is not followed by = constant-expression, its value is the value one greater than the value of the previous enumerator in the same enumeration. The value of the first enumerator (if it does not use = constant-expression) is zero.\n   The identifier itself, if used, becomes the name of the enumerated type in the tags name space and requires the use of the keyword enum (unless typedef'd into the ordinary name space).\n   Each enumerated type is compatible with one of: char, a signed integer type, or an unsigned integer type. It is implementation-defined which type is compatible with any given enumerated type, but whatever it is, it must be capable of representing all enumerator values of that enumeration.\n   Enumerated types are integer types, and as such can be used anywhere other integer types can, including in implicit conversions and arithmetic operators.\n\nNotes\n   Unlike struct or union, there are no forward-declared enums in C:\n   Enumerations permit the declaration of named constants in a more convenient and structured fashion than does #define; they are visible in the debugger, obey scope rules, and participate in the type system.\n   or.\n", "url": "https://devdocs.io/c/language/enum\n"}, {"name": "Escape sequences", "type": "STANDARD LIB", "description": "   Escape sequences are used to represent certain special characters within string literals and character constants.\n   The following escape sequences are available. ISO C requires a diagnostic if the backslash is followed by any character not listed here:\nEscape sequence   Description   Representation\n\\'   single quote   byte 0x27 (in ASCII encoding)\n\\\"   double quote   byte 0x22 (in ASCII encoding)\n\\?   question mark   byte 0x3f (in ASCII encoding)\n\\\\   backslash   byte 0x5c (in ASCII encoding)\n\\a   audible bell   byte 0x07 (in ASCII encoding)\n\\b   backspace   byte 0x08 (in ASCII encoding)\n\\f   form feed - new page   byte 0x0c (in ASCII encoding)\n\\n   line feed - new line   byte 0x0a (in ASCII encoding)\n\\r   carriage return   byte 0x0d (in ASCII encoding)\n\\t   horizontal tab   byte 0x09 (in ASCII encoding)\n\\v   vertical tab   byte 0x0b (in ASCII encoding)\n\\nnn   arbitrary octal value   byte nnn\n\\xnn   arbitrary hexadecimal value   byte nn\n\\unnnn(since C11)    Unicode character that is not in the basic character set.May result in several characters.   code point U+nnnn\n\\Unnnnnnnn(since C11)    Unicode character that is not in the basic character set.May result in several characters.   code point U+nnnnnnnn\n\n\nNotes\n   Of the octal escape sequences, \\0 is the most useful because it represents the terminating null character in null-terminated strings.\n   The new-line character \\n has special meaning when used in text mode I/O: it is converted to the OS-specific newline byte or byte sequence.\n   Octal escape sequences have a length limit of three octal digits but terminate at the first character that is not a valid octal digit if encountered sooner.\n   Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal or character constant (char, char16_t, char32_t, or wchar_t), the result is unspecified.\n   A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. \\U0001f34c is 4 char code units in UTF-8 (\\xF0\\x9F\\x8D\\x8C) and 2 char16_t code units in UTF-16 (\\uD83C\\uDF4C).\n   The question mark escape sequence \\? is used to prevent trigraphs from being interpreted inside string literals: a string such as \"??/\" is compiled as \"\\\", but if the second question mark is escaped, as in \"?\\?/\", it becomes \"??/\"\n", "url": "https://devdocs.io/c/language/escape\n"}, {"name": "Expressions", "type": "STANDARD LIB", "description": "   An expression is a sequence of operators and their operands, that specifies a computation.\n   Expression evaluation may produce a result (e.g., evaluation of 2+2 produces the result 4), may generate side-effects (e.g. evaluation of printf(\"%d\",4) sends the character '4' to the standard output stream), and may designate objects or functions.\n\nOperators\nCommon operators\nassignment    incrementdecrement    arithmetic    logical    comparison    memberaccess    other\na = b a += b a -= b a *= b a /= b a %= b a &= b a |= b a ^= b a <<= b a >>= b.\n  ++a --a a++ a--\n  +a -a a + b a - b a * b a / b a % b ~a a & b a | b a ^ b a << b a >> b.\n  !a a && b a || b.\n  a == b a != b a < b a > b a <= b a >= b.\n  a[b] *a &a a->b a.b.\n  a(...) a, b (type) a ? : sizeof _Alignof (since C11).\n\n\nPrimary expressions\n   The operands of any operator may be other expressions or they may be primary expressions (e.g. in 1+2*3, the operands of operator+ are the subexpression 2*3 and the primary expression 1).\n   Primary expressions are any of the following:\n   Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator.\n   Constant values of certain types may be embedded in the source code of a C program using specialized expressions known as literals (for lvalue expressions) and constants (for non-lvalue expressions).\n\nUnevaluated expressions\n   The operands of the sizeof operator , the _Alignof operator, and the controlling expression of a generic selection, (since C11) are expressions that are not evaluated (unless they are VLAs) (since C99). Thus, size_t n = sizeof(printf(\"%d\", 4)); does not perform console output.\n", "url": "https://devdocs.io/c/language/expressions\n"}, {"name": "External and tentative definitions", "type": "STANDARD LIB", "description": "   At the top level of a translation unit (that is, a source file with all the #includes after the preprocessor), every C program is a sequence of declarations, which declare functions and objects with external linkage. These declarations are known as external declarations because they appear outside of any function.\n   Objects declared with an external declaration have static storage duration, and as such cannot use auto or register specifiers. The identifiers introduced by external declarations have file scope.\n\nTentative definitions\n   A tentative definition is an external declaration without an initializer, and either without a storage-class specifier or with the specifier static.\n   A tentative definition is a declaration that may or may not act as a definition. If an actual external definition is found earlier or later in the same translation unit, then the tentative definition just acts as a declaration.\n   If there are no definitions in the same translation unit, then the tentative definition acts as an actual definition with the initializer = 0 (or, for array, structure, and union types, = {0}).\n   Unlike the extern declarations, which don't change the linkage of an identifier if a previous declaration established it, tentative definitions may disagree in linkage with another declaration of the same identifier. If two declarations for the same identifier are in scope and have different linkage, the behavior is undefined:\n   A tentative definition with internal linkage must have complete type.\n\nOne definition rule\n   Each translation unit may have zero or one external definition of every identifier with internal linkage (a static global).\n   If an identifier with internal linkage is used in any expression other than a non-VLA (since C99), sizeof, or alignof  (since C11), there must be one and only one external definition for that identifier in the translation unit.\n   The entire program may have zero or one external definition of every identifier (other than an inline function) (since C99) with external linkage.\n   If an identifier with external linkage is used in any expression other than a non-VLA (since C99), sizeof, or alignof  (since C11), there must be one and only one external definition for that identifier somewhere in the entire program.\n\nNotes\n   See inline for the details on the inline function definitions.\n   See storage duration and linkage for the meaning of the keyword extern with declarations at file scope.\n   See definitions for the distinction between declarations and definitions.\n   Tentative definitions were invented to standardize various pre-C89 approaches to forward declaring identifiers with internal linkage.\n", "url": "https://devdocs.io/c/language/extern\n"}, {"name": "File scope", "type": "STANDARD LIB", "description": "   If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit.\n   So, placement of an identifier's declaration (in a declarator or type specifier) outside any block or list of parameters means that the identifier has file scope. File scope of an identifier extends from the declaration to the end of the translation unit in which the declaration appears.\n", "url": "https://devdocs.io/c/language/file_scope\n"}, {"name": "floating constant", "type": "STANDARD LIB", "description": "   Allows values of floating type to be used directly in expressions.\n\nSyntax\n   A floating constant is a non-lvalue expression having the form:\nsignificand exponent(optional) suffix(optional)\n\n   Where the significand has the form.\nwhole-number(optional) .(optional) fraction(optional)\n\n   The exponent has the form.\ne | E exponent-sign(optional) digit-sequence   (1)\np | P exponent-sign(optional) digit-sequence   (2)   (since C99)\n\n\nExplanation\nIf the significand begins with the character sequence 0x or 0X, the floating constant is a hexadecimal floating constant. Otherwise, it is a decimal floating constant.\nFor a hexadecimal floating constant, the significand is interpreted as a hexadecimal rational number, and the digit-sequence of the exponent is interpreted as the integer power of 2 to which the significand has to be scaled.\ndouble d = 0x1.2p3; // hex fraction 1.2 (decimal 1.125) scaled by 2^3, that is 9.0  (since C99)\n\n   For a decimal floating constant, the significand is interpreted as a decimal rational number, and the digit-sequence of the exponent is interpreted as the integer power of 10 to which the significand has to be scaled.\n   An unsuffixed floating constant has type double. If suffix is the letter f or F, the floating constant has type float. If suffix is the letter l or L, the floating constant has type long double.\n   The result of evaluating a floating constant is either the nearest representable value or the larger or smaller representable value immediately adjacent to the nearest representable value, chosen in an implementation-defined manner (in other words, default rounding direction during translation is implementation-defined).\nFloating-point constants may convert to more range and precision than is indicated by their type, if indicated by FLT_EVAL_METHOD. For example, the constant 0.1f may act as if it were 0.1L in an expression.\n (since C99)\n\nThe result of evaluating a hexadecimal floating constant, if FLT_RADIX is 2, is the exact value represented by the floating constant, correctly rounded to the target type.\n (since C99)\n\n   If the exponent is present and fractional part is not used, the decimal separator may be omitted:\n   For decimal floating constants, the exponent part is optional. If it is omitted, the period is not optional, and either the whole-number or the fraction must be present.\nFor hexadecimal floating constants, the exponent is not optional to avoid ambiguity resulting from an f suffix being mistaken as a hexadecimal digit.\n (since C99)\n\n\nNotes\n   Default rounding direction and precision are in effect when the floating constants are converted into internal representations, and floating-point exceptions are not raised even if  #pragma STDC FENV_ACCESS is in effect (for execution-time conversion of character strings, strtod can be used). Note that this differs from arithmetic constant expressions of floating type.\n   Letters in the floating constants are case-insensitive: 0x1.ep+3 and 0X1.EP+3 represent the same floating-point value 15.0.\n   The decimal point specified by setlocale has no effect on the syntax of floating constants: the decimal point character is always the period.\n   Unlike integers, not every floating value can be represented directly by decimal or even hexadecimal constant syntax: macros NAN and INFINITY as well as functions such as nan offer ways to generate those special values. Note that 0x1.FFFFFEp128f, which might appear to be an IEEE float NaN, in fact overflows to an infinity in that format.\n   There are no negative floating constants; an expression such as -1.2 is the arithmetic operator unary minus applied to the floating constant 1.2. Note that the special value negative zero may be constructed with -0.0.\n", "url": "https://devdocs.io/c/language/floating_constant\n"}, {"name": "for loop", "type": "STANDARD LIB", "description": "   Executes a loop.\n   Used as a shorter equivalent of while loop.\n\nSyntax\nfor ( init_clause ; cond_expression ; iteration_expression ) loop_statement\n\n\nExplanation\n   Behaves as follows:\n   init_clause, cond_expression, and iteration_expression are all optional:\n   loop_statement is not optional, but it may be a null statement:\n   If the execution of the loop needs to be terminated at some point, a  break statement can be used anywhere within the loop_statement.\n   The  continue statement used anywhere within the loop_statement transfers control to iteration_expression.\n   A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its cond_expression, iteration_expression or loop_statement. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where cond_expression is omitted or is a constant expression; for(;;) is always an endless loop.\nAs with all other selection and iteration statements, the for statement establishes block scope: any identifier introduced in the init_clause, cond_expression, or iteration_expression goes out of scope after the loop_statement.\n (since C99)\n\n\nKeywords\n   for.\n\nNotes\n   The expression statement used as loop_statement establishes its own block scope, distinct from the scope of init_clause, unlike in C++:\n   It is possible to enter the body of a loop using goto. In this case, init_clause and cond_expression are not executed.\n", "url": "https://devdocs.io/c/language/for\n"}, {"name": "Function declarations", "type": "STANDARD LIB", "description": "   A function declaration introduces an identifier that designates a function and, optionally, specifies the types of the function parameters (the prototype). Function declarations (unlike definitions) may appear at block scope as well as file scope.\n\nSyntax\n   In the declaration grammar of a function declaration, the type-specifier sequence, possibly modified by the declarator, designates the return type (which may be any type other than array or function type), and the declarator has one of two forms:\nnoptr-declarator ( parameter-list )   (1)\nnoptr-declarator ( identifier-list(optional) )   (2)\n\n   where.\nnoptr-declarator   -   any declarator except unparenthesized pointer declarator. The identifier that is contained in this declarator is the identifier that becomes the function designator.\nparameter-list   -   either the single keyword void or a comma-separated list of parameters, which may end with an ellipsis parameter\nidentifier-list   -   comma-separated list of identifiers (only if this declarator is used as part of old-style function definition), must be omitted for old-style declarations that are not definitions.\n\n\nExplanation\n   The return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in declarations, must be a complete non-array object type or the type void.\nThe return type of a function cannot be cvr-qualified: any qualified return type is adjusted to its unqualified version for the purpose of constructing the function type:\ndouble const foo(void) { return 0.; } // declares function of type double(void)\ndouble (*foop)(void) = foo;           // OK: foop is a pointer to double(void)\ndouble const (*foopc)(void) = foop;   // OK: foopc is also a pointer to double(void)  (since C17)\n\n   Function declarators can be combined with other declarators as long as they can share their type specifiers and qualifiers.\n   If a function declaration appears outside of any function, the identifier it introduces has file scope and external linkage, unless static is used or an earlier static declaration is visible. If the declaration occurs inside another function, the identifier has block scope (and also either internal or external linkage).\n   The parameters in a declaration that is not part of a function definition do not need to be named:\n   Each parameter in a parameter-list is a declaration that introduced a single variable, with the following additional properties:\n   See function call operator for other details on the mechanics of a function call and return for returning from functions.\n\nNotes\n   Unlike in C++, the declarators f() and f(void) have different meaning: the declarator f(void) is a new-style (prototype) declarator that declares a function that takes no parameters. The declarator f() is an old-style (K&R) declarator that declares a function that takes unspecified number of parameters (unless used in an old-style function definition).\n   Unlike in a function definition, the parameter list may be inherited from a typedef.\nIn C89, specifiers-and-qualifiers was optional, and if omitted, the return type of the function defaulted to int (possibly amended by the declarator).\n*f() { // function returning int*\n   return NULL;\n}  (until C99)\n\n", "url": "https://devdocs.io/c/language/function_declaration\n"}, {"name": "Function definitions", "type": "STANDARD LIB", "description": "   A function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list. Unlike function declaration, function definitions are allowed at file scope only (there are no nested functions).\n   C supports two different forms of function definitions:\nspecifiers-and-qualifiers parameter-list-declarator function-body   (1)\nspecifiers-and-qualifiers identifier-list-declarator declaration-list function-body   (2)\n\n   where.\nspecifiers-and-qualifiers   -   a combination of \n type specifiers that, possibly modified by the declarator, form the return type \n storage class specifiers, which determine the linkage of the identifier (static, extern, or none) \n function specifiers inline, _Noreturn, or none\nparameter-list-declarator   -   a declarator for a function type which uses a parameter list to designate function parameters\nidentifier-list-declarator   -   a declarator for a function type which uses a identifier list to designate function parameters\ndeclaration-list   -   sequence of declarations that declare every identifier in identifier-list-declarator. These declarations cannot use initializers and the only storage-class specifier allowed is register.\nfunction-body   -   a compound statement, that is a brace-enclosed sequence of declarations and statements, that is executed whenever this function is called\n\n\nExplanation\n   As with function declarations, the return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in declarations, must be a complete non-array object type or the type void.\nAs with function declarations, if the return type would be cvr-qualified, it is adjusted to its unqualified version for the purpose of constructing the function type.\n (since C17)\n\n   As with function declarations, the types of the parameters are adjusted from functions to pointers and from arrays to pointers for the purpose of constructing the function type and the top-level cvr-qualifiers of all parameter types are ignored for the purpose of determining compatible function type.\n   Unlike function declarations, unnamed formal parameters are not allowed, they must be named even if they are not used within the function. The only exception is the special parameter list (void).\n   Within the function body, every parameter is an lvalue expression, they have automatic storage duration and block scope. The layout of the parameters in memory (or if they are stored in memory at all) is unspecified: it is a part of the calling convention.\n   See function call operator for other details on the mechanics of a function call and return for returning from functions.\n__func__ Within every function-body, the special predefined variable __func__ with block scope and static storage duration is available, as if defined immediately after the opening brace by.\nstatic const char __func__[] = \"function name\"; This special identifier is sometimes used in combination with the predefined macro constants __FILE__ and __LINE__, for example, by assert.\n (since C99)\n\n\nNotes\n   The argument list must be explicitly present in the declarator, it cannot be inherited from a typedef.\nIn C89, specifiers-and-qualifiers was optional, and if omitted, the return type of the function defaulted to int (possibly amended by the declarator).\nIn addition, old-style definition didn't require a declaration for every parameter in declaration-list. Any parameter whose declaration was missing had type int.\nmax(a, b) // a and b have type int, return type is int\n{\n    return a>b?a:b;\n}  (until C99)\n\n", "url": "https://devdocs.io/c/language/function_definition\n"}, {"name": "Functions", "type": "STANDARD LIB", "description": "   A function is a C language construct that associates a compound statement (the function body) with an identifier (the function name). Every C program begins execution from the main function, which either terminates, or invokes other, user-defined or library functions.\n   Functions may accept zero or more parameters, which are initialized from the arguments of a function call operator, and may return a value to its caller by means of the return statement.\n   The body of a function is provided in a function definition. Each function must be defined only once in a program, unless the function is inline.\n   There are no nested functions (except where allowed through non-standard compiler extensions): each function definition must appear at file scope, and functions have no access to the local variables from the caller:\n", "url": "https://devdocs.io/c/language/functions\n"}, {"name": "Generic selection", "type": "STANDARD LIB", "description": "   Provides a way to choose one of several expressions at compile time, based on a type of a controlling expression.\n\nSyntax\n_Generic ( controlling-expression , association-list )     (since C11)\n\n   where association-list is a comma-separated list of associations, each of which has the syntax.\ntype-name : expression\ndefault : expression\n\n   where.\ntype-name   -   any complete object type that isn't variably-modified (that is, not VLA or pointer to VLA).\ncontrolling-expression   -   any expression (except for the comma operator) whose type must be compatible with one of the type-names if the default association is not used\nexpression   -   any expression (except for the comma operator) of any type and value category\n\n   No two type-names in the association-list may specify compatible types. There may be only one association that uses the keyword default. If default is not used and none of the type-names are compatible with the type of the controlling expression, the program will not compile.\n\nExplanation\n   First, the type of controlling-expression undergoes lvalue conversions. The conversion is performed in type domain only: it discards the top-level cvr-qualifiers and atomicity and applies array-to-pointer/function-to-pointer transformations to the type of the controlling expression, without initiating any side-effects or calculating any values.\n   The type after conversion is compared with type-names from the list of associations.\n   If the type is compatible with the type-name of one of the associations, then the type, value, and value category of the generic selection are the type, value, and value category of the expression that appears after the colon for that type-name.\n   If none of the type-names are compatible with the type of the controlling-expression, and the default association is provided, then the type, value, and value category of the generic selection are the type, value, and value category of the expression after the default\u00a0: label.\n\nNotes\n   The controlling-expression and the expressions of the selections that are not chosen are never evaluated.\n   Because of the lvalue conversions, \"abc\" matches char* and not char[4] and (int const){0} matches int, and not const int. This was specified by the C17 DR 481 (which applies retroactively to C11).\n   All value categories, including function designators and void expressions, are allowed as expressions in a generic selection, and if selected, the generic selection itself has the same value category.\n   The type-generic math macros from <tgmath.h>, introduced in C99, were implemented in compiler-specific manner. Generic selections, introduced in C11, gave the programmers the ability to write similar type-dependent code.\n   Generic selection is similar to overloading in C++ (where one of several functions is chosen at compile time based on the types of the arguments), except that it makes the selection between arbitrary expressions.\n\nKeywords\n   _Generic, default.\n", "url": "https://devdocs.io/c/language/generic\n"}, {"name": "goto statement", "type": "STANDARD LIB", "description": "   Transfers control unconditionally to the desired location.\n   Used when it is otherwise impossible to transfer control to the desired location using conventional constructs.\n\nSyntax\ngoto label ;\nlabel : statement\n\n\nExplanation\n   The goto statement causes an unconditional jump (transfer of control) to the statement prefixed by the named label (which must appear in the same function as the goto statement), except when this jump would enter the scope of a variable-length array or another variably-modified type. (since C99).\n   A label is an identifier followed by a colon (:) and a statement. Labels are the only identifiers that have function scope: they can be used (in a goto statement) anywhere in the same function in which they appear. There may be multiple labels before any statement.\nEntering the scope of a non-variably modified variable is permitted:\ngoto lab1; // OK: going into the scope of a regular variable\n    int n = 5;\nlab1:; // Note, n is uninitialized, as if declared by int n;\n \n//   goto lab2;   // Error: going into the scope of two VM types\n     double a[n]; // a VLA\n     int (*p)[n]; // a VM pointer\nlab2: If goto leaves the scope of a VLA, it is deallocated (and may be reallocated if its initialization is executed again):\n{\n   int n = 1;\nlabel:;\n   int a[n]; // re-allocated 10 times, each with a different size\n   if (n++ < 10) goto label; // leaving the scope of a VM\n}  (since C99)\n\n\nKeywords\n   goto.\n\nNotes\n   Because declarations are not statements, a label before a declaration must use a null statement (a semicolon immediately after the colon). Same applies to a label before the end of a block.\n   C++ imposes additional limitations on the goto statement, but allows labels before declarations (which are statements in C++).\n", "url": "https://devdocs.io/c/language/goto\n"}, {"name": "Identifier", "type": "STANDARD LIB", "description": "   An identifier is an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters, and Unicode characters specified using \\u and \\U escape notation (since C99). A valid identifier must begin with a non-digit character (Latin letter, underscore, or Unicode non-digit character (since C99)). Identifiers are case-sensitive (lowercase and uppercase letters are distinct).\nIt is implementation-defined if raw (not escaped) Unicode characters are allowed in identifiers:\nchar *\\U0001f431 = \"cat\"; // supported\nchar *\ud83d\udc31 = \"cat\"; // implementation-defined (e.g. works with Clang, but not GCC)  (since C99)\n\n   Identifiers can denote the following types of entities:\n   Every identifier other than macro name or macro parameter name has scope, belongs to a name space, and may have linkage. The same identifier can denote different entities at different points in the program, or may denote different entities at the same point if the entities are in different name spaces.\n\nReserved identifiers\n   The following identifiers are reserved and may not be declared in a program (doing so invokes undefined behavior):\n   All other identifiers are available, with no fear of unexpected collisions when moving programs from one compiler and library to another.\n   Note: in C++, identifiers with a double underscore anywhere are reserved everywhere; in C, only the ones that begin with a double underscore are reserved.\n\nTranslation limits\n   Even though there is no specific limit on the length of identifiers, early compilers had limits on the number of significant initial characters in identifiers and the linkers imposed stricter limits on the names with external linkage. C requires that at least the following limits are supported by any standard-compliant implementation:\n31 significant initial characters in an internal identifier or a macro name \n6 significant initial characters in an external identifier \n511 external identifiers in one translation unit \n127 identifiers with block scope declared in one block \n1024 macro identifiers simultaneously defined in one preprocessing translation unit \n  (until C99)\n63 significant initial characters in an internal identifier or a macro name \n31 significant initial characters in an external identifier \n4095 external identifiers in one translation unit \n511 identifiers with block scope declared in one block \n4095 macro identifiers simultaneously defined in one preprocessing translation unit \n  (since C99)\n\n", "url": "https://devdocs.io/c/language/identifier\n"}, {"name": "if statement", "type": "STANDARD LIB", "description": "   Conditionally executes code.\n   Used where code needs to be executed only if some condition is true.\n\nSyntax\nif ( expression ) statement_true   (1)\nif ( expression ) statement_true else statement_false   (2)\n\n\nExplanation\n   expression must be an expression of any scalar type.\n   If expression compares not equal to the integer zero, statement_true is executed.\n   In the form (2), if expression compares equal to the integer zero, statement_false is executed.\nAs with all other selection and iteration statements, the entire if-statement has its own block scope:\nenum {a, b};\nint different(void)\n{\n    if (sizeof(enum {b, a}) != sizeof(int))\n        return a; // a == 1\n    return b; // b == 0 in C89, b == 1 in C99\n}  (since C99)\n\n\nNotes\n   The else is always associated with the closest preceding if (in other words, if statement_true is also an if statement, then that inner if statement must contain an else part as well):\n   If statement_true is entered through a goto, statement_false is not executed.\n\nKeywords\n   if, else.\n", "url": "https://devdocs.io/c/language/if\n"}, {"name": "Implicit conversions", "type": "STANDARD LIB", "description": "   When an expression is used in the context where a value of a different type is expected, conversion may occur:\n   Conversions take place in the following situations:\n\nConversion as if by assignment\n   Note that actual assignment, in addition to the conversion, also removes extra range and precision from floating-point types and prohibits overlaps; those characteristics do not apply to conversion as if by assignment.\n\nDefault argument promotions\n   In a function call expression when the call is made to.\n   Each argument of integer type undergoes integer promotion (see below), and each argument of type float is implicitly converted to the type double.\n   Note that float complex and float imaginary are not promoted to double complex and double imaginary in this context.\n\nUsual arithmetic conversions\n   The arguments of the following arithmetic operators undergo implicit conversions for the purpose of obtaining the common real type, which is the type in which the calculation is performed:\n   The result type is determined as follows:\n   As always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see FLT_EVAL_METHOD).\n   Note: real and imaginary operands are not implicitly converted to complex because doing so would require extra computation, while producing undesirable results in certain cases involving infinities, NaNs and signed zeros. For example, if reals were converted to complex, 2.0\u00d7(3.0+i\u221e) would evaluate as (2.0+i0.0)\u00d7(3.0+i\u221e) \u21d2 (2.0\u00d73.0\u20130.0\u00d7\u221e) + i(2.0\u00d7\u221e+0.0\u00d73.0) \u21d2 NaN+i\u221e rather than the correct 6.0+i\u221e. If imaginaries were converted to complex, i2.0\u00d7(\u221e+i3.0) would evaluate as (0.0+i2.0) \u00d7 (\u221e+i3.0) \u21d2 (0.0\u00d7\u221e \u2013 2.0\u00d73.0) + i(0.0\u00d73.0 + 2.0\u00d7\u221e) \u21d2 NaN + i\u221e instead of \u20136.0 + i\u221e.\n   Note: regardless of usual arithmetic conversions, the calculation may always be performed in a narrower type than specifier by these rules under the as-if rule.\n\nValue transformations\n   Any lvalue expression of any non-array type, when used in any context other than.\n   undergoes lvalue conversion: the type remains the same, but loses const/volatile/restrict-qualifiers and atomic properties, if any. The value remains the same, but loses its lvalue properties (the address may no longer be taken).\n   If the lvalue has incomplete type, the behavior is undefined.\n   If the lvalue designates an object of automatic storage duration whose address was never taken and if that object was uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.\n   This conversion models the memory load of the value of the object from its location.\n   Any lvalue expression of array type, when used in any context other than.\n   undergoes a conversion to the non-lvalue pointer to its first element.\n   If the array was declared register, the behavior is undefined.\n   Any function designator expression, when used in any context other than.\n   undergoes a conversion to the non-lvalue pointer to the function designated by the expression.\n\nImplicit conversion semantics\n   Implicit conversion, whether as if by assignment or a usual arithmetic conversion, consists of two stages:\n   Conversion of a value of any type to any compatible type is always a no-op and does not change the representation.\n   Integer promotion is the implicit conversion of a value of any integer type with rank less or equal to rank of int or of a bit field of type _Bool, int, signed int, unsigned int, to the value of type int or unsigned int.\n   If int can represent the entire range of values of the original type (or the range of values of the original bit field), the value is converted to type int. Otherwise the value is converted to unsigned int.\n   Integer promotions preserve the value, including the sign:\n   rank above is a property of every integer type and is defined as follows:\n   Note: integer promotions are applied only.\n   A value of any scalar type can be implicitly converted to _Bool. The values that compare equal to zero are converted to \u200b0\u200b, all other values are converted to 1.\n   A value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:\n   A finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:\n   A value of any integer type can be implicitly converted to any real floating type.\n   The result of this conversion may have greater range and precision than its target type indicates (see FLT_EVAL_METHOD.\n   If control over FE_INEXACT is needed in floating-to-integer conversions, rint and nearbyint may be used.\n   A value of any real floating type can be implicitly converted to any other real floating type.\n   The result of this conversion may have greater range and precision than its target type indicates (see FLT_EVAL_METHOD.\n   A value of any complex type can be implicitly converted to any other complex type. The real part and the imaginary part individually follow the conversion rules for the real floating types.\n   A value of any imaginary type can be implicitly converted to any other imaginary type. The imaginary part follows the conversion rules for the real floating types.\n   A value of any real floating type can be implicitly converted to any complex type.\n   A value of any complex type can be implicitly converted to any real floating type.\n   Note: in complex-to-real conversion, a NaN in the imaginary part will not propagate to the real result.\n   A value of any imaginary type can be implicitly converted to any real type (integer or floating-point). The result is always a positive (or unsigned) zero, except when the target type is _Bool, in which case boolean conversion rules apply.\n   A value of any real type can be implicitly converted to any imaginary type. The result is always a positive imaginary zero.\n   A value of any imaginary type can be implicitly converted to any complex type.\n   A value of any complex type can be implicitly converted to any imaginary type.\n   A pointer to void can be implicitly converted to and from any pointer to object type with the following semantics:\n   A pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, const, volatile, and restrict qualifiers can be added. The original pointer and the result compare equal.\n   Any integer constant expression with value \u200b0\u200b as well as integer pointer expression with value zero cast to the type void* can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void* expression is known as null pointer constant and the standard library provides one definition of this constant as the macro NULL .\n\nNotes\n   Although signed integer overflow in any arithmetic operator is undefined behavior, overflowing a signed integer type in an integer conversion is merely unspecified behavior.\n   On the other hand, although unsigned integer overflow in any arithmetic operator (and in integer conversion) is a well-defined operation and follows the rules of modulo arithmetic, overflowing an unsigned integer in a floating-to-integer conversion is undefined behavior: the values of real floating type that can be converted to unsigned integer are the values from the open interval (-1; Unnn_MAX+1).\n   Conversions between pointers and integers (except from pointer to _Bool and from integer constant expression with the value zero to pointer), between pointers to objects (except where either to or from is a pointer to void) and conversions between pointers to functions (except when the functions have compatible types) are never implicit and require a cast operator.\n   There are no conversions (implicit or explicit) between pointers to functions and pointers to objects (including void*) or integers.\n", "url": "https://devdocs.io/c/language/conversion\n"}, {"name": "Increment/decrement operators", "type": "STANDARD LIB", "description": "   Increment/decrement operators are unary operators that increment/decrement the value of a variable by 1.\n   They can have postfix form:\nexpr ++\nexpr --\n\n   As well as the prefix form:\n++ expr\n-- expr\n\n   The operand expr of both prefix and postfix increment or decrement must be a modifiable lvalue of integer type (including _Bool and enums), real floating type, or a pointer type. It may be cvr-qualified, unqualified, or atomic.\n   The result of the postfix increment and decrement operators is the value of expr.\n   The result of the prefix increment operator is the result of adding the value 1 to the value of expr: the expression ++e is equivalent to e+=1. The result of the prefix decrement operator is the result of subtracting the value 1 from the value of expr: the expression --e is equivalent to e-=1.\n   Increment operators initiate the side-effect of adding the value 1 of appropriate type to the operand. Decrement operators initiate the side-effect of subtracting the value 1 of appropriate type from the operand. As with any other side-effects, these operations complete at or before the next sequence point. int a = 1; int b = a++; // stores 1+a (which is 2) to a // returns the value of a (which is 1) // After this line, b == 1 and a == 2 a = 1; int c = ++a; // stores 1+a (which is 2) to a // returns 1+a (which is 2) // after this line, c == 2 and a == 2.\nPost-increment or post-decrement on any atomic variable is an atomic read-modify-write operation with memory order memory_order_seq_cst.\n (since C11)\n\n   See arithmetic operators for limitations on pointer arithmetic, as well as for implicit conversions applied to the operands.\n\nNotes\n   Because of the side-effects involved, increment and decrement operators must be used with care to avoid undefined behavior due to violations of sequencing rules.\n   Increment/decrement operators are not defined for complex or imaginary types: the usual definition of adding/subtracting the real number 1 would have no effect on imaginary types, and making it add/subtract i for imaginaries but 1 for complex numbers would have made it handle 0+yi different from yi.\n   Unlike C++ (and some implementations of C), the increment/decrement expressions are never themselves lvalues: &++a is invalid.\n", "url": "https://devdocs.io/c/language/operator_incdec\n"}, {"name": "Initialization", "type": "STANDARD LIB", "description": "   A declaration of an object may provide its initial value through the process known as initialization.\n   For each declarator, the initializer, if not omitted, may be one of the following:\n= expression   (1)\n= {  initializer-list }    (2)\n\n   where initializer-list is a non-empty comma-separated list of initializers (with an optional trailing comma), where each initializer has one of three possible forms:\nexpression   (1)\n{  initializer-list }    (2)\ndesignator-list = initializer   (3)   (since C99)\n\nwhere designator-list is a list of either array designators of the form [ constant-expression ] or struct/union member designators of the form . identifier; see array initialization and struct initialization.\nNote: besides initializers, brace-enclosed initializer-list may appear in compound literals, which are expressions of the form:\n   ( type ) {  initializer-list }      \n\n  (since C99)\n( type ) {  initializer-list }\n\n\nExplanation\n   The initializer specifies the initial value stored in an object.\n   If an initializer is provided, see.\n   If an initializer is not provided:\n\nNotes\n   When initializing an object of static or thread-local storage duration, every expression in the initializer must be a constant expression or string literal.\n   Initializers cannot be used in declarations of objects of incomplete type, VLAs, and block-scope objects with linkage.\n   The initial values of function parameters are established as if by assignment from the arguments of a function call, rather than by initialization.\n   If an indeterminate value is used as an argument to any standard library call, the behavior is undefined. Otherwise, the result of any expression involving indeterminate values is an indeterminate value (e.g. int n;, n may not compare equal to itself and it may appear to change its value on subsequent reads).\n", "url": "https://devdocs.io/c/language/initialization\n"}, {"name": "inline function specifier", "type": "STANDARD LIB", "description": "   Declares an inline function.\n\nSyntax\ninline function_declaration     (since C99)\n\n\nExplanation\n   The intent of the inline specifier is to serve as a hint for the compiler to perform optimizations, such as function inlining, which require the definition of a function to be visible at the call site. The compilers can (and usually do) ignore presence or absence of the inline specifier for the purpose of optimization.\n   If the compiler performs function inlining, it replaces a call of that function with its body, avoiding the overhead of a function call (placing data on stack and retrieving the result), which may result in a larger executable as the code for the function has to be repeated multiple times. The result is similar to function-like macros, except that identifiers and macros used in the function refer to the definitions visible at the point of definition, not at the point of call.\n   Regardless of whether inlining takes place, the following semantics of inline functions are guaranteed:\n   Any function with internal linkage may be declared static inline with no other restrictions.\n   A non-static inline function cannot define a non-const function-local static and cannot refer to a file-scope static.\n   If a non-static function is declared inline, then it must be defined in the same translation unit. The inline definition that does not use extern is not externally visible and does not prevent other translation units from defining the same function. This makes the inline keyword an alternative to static for defining functions inside header files, which may be included in multiple translation units of the same program.\n   If a function is declared inline in some translation units, it does not need to be declared inline everywhere: at most one translation unit may also provide a regular, non-inline non-static function, or a function declared extern inline. This one translation unit is said to provide the external definition. One external definition must exist in the program if the name of the function with external linkage is used in an expression, see one definition rule.\n   If the external definition exists in the program, the address of the function is always the address of the external function, but when this address is used to make a function call, it's unspecified whether the inline definition (if present in the translation unit) or the external definition is called. The static objects defined within an inline definition are distinct from the static objects defined within the external definition:\n   A valid C program must not depend on whether the inline version or the external version of a function is called.\n\nKeywords\n   inline.\n\nNotes\n   The inline keyword was adopted from C++, but in C++, if a function is declared inline, it must be declared inline in every translation unit, and also every definition of an inline function must be exactly the same (in C, the definitions may be different, as long as the behavior of the program does not depend on the differences). On the other hand, C++ allows non-const function-local statics and all function-local statics from different definitions of an inline function are the same in C++ but distinct in C.\n", "url": "https://devdocs.io/c/language/inline\n"}, {"name": "integer constant", "type": "STANDARD LIB", "description": "   Allows values of integer type to be used in expressions directly.\n\nSyntax\n   An integer constant is a non-lvalue expression of the form.\ndecimal-constant integer-suffix(optional)   (1)\noctal-constant integer-suffix(optional)   (2)\nhex-constant integer-suffix(optional)   (3)\n\n   where.\n\nExplanation\n   The following variables are initialized to the same value:\n\nThe type of the integer constant\n   The type of the integer constant is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.\nTypes allowed for integer constants\nsuffix   decimal bases   hexadecimal or octal bases\nno suffix   int long int unsigned long int (until C99) long long int (since C99).\n  int unsigned int long int unsigned long int long long int(since C99) unsigned long long int(since C99).\nu or U   unsigned int unsigned long int unsigned long long int(since C99).\n  unsigned int unsigned long int unsigned long long int(since C99).\nl or L   long int unsigned long int(until C99) long long int(since C99).\n  long int unsigned long int long long int(since C99) unsigned long long int(since C99).\nboth l/L and u/U   unsigned long int unsigned long long int(since C99).\n  unsigned long int unsigned long long int(since C99).\nll or LL   long long int(since C99)   long long int(since C99) unsigned long long int(since C99).\nboth ll/LL and u/U   unsigned long long int(since C99)   unsigned long long int(since C99)\n\n   If the value of the integer constant is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as __int128), the constant may be given the extended integer type; otherwise, the program is ill-formed.\n\nNotes\n   Letters in the integer constants are case-insensitive: 0xDeAdBaBeU and 0XdeadBABEu represent the same number (one exception is the long-long-suffix, which is either ll or LL, never lL or Ll).\n   There are no negative integer constants. Expressions such as -1 apply the unary minus operator to the value represented by the constant, which may involve implicit type conversions.\n   When used in a controlling expression of #if or #elif, all signed integer constants act as if they have type intmax_t and all unsigned integer constants act as if they have type uintmax_t.\n   Integer constants may be used in integer constant expressions.\n   Due to maximal munch, hexadecimal integer constants ending in e and E, when followed by the operators + or -, must be separated from the operator with whitespace or parentheses in the source:\n   Otherwise, a single invalid preprocessing number token is formed, which causes further analysis to fail.\n", "url": "https://devdocs.io/c/language/integer_constant\n"}, {"name": "Lifetime", "type": "STANDARD LIB", "description": "   Every object in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate), and, for VLA, retains its size (since C99) over a portion of program execution known as this object's lifetime.\n   For the objects that are declared with automatic, static, and thread storage duration, lifetime equals their storage duration (note the difference between non-VLA and VLA automatic storage duration).\n   For the objects with allocated storage duration, the lifetime begins when the allocation function returns (including the return from realloc) and ends when the realloc or deallocation function is called. Note that since allocated objects have no declared type, the type of the lvalue expression first used to access this object becomes its effective type.\n   Accessing an object outside of its lifetime is undefined behavior.\n   A pointer to an object (or one past the object) whose lifetime ended has indeterminate value.\n\nTemporary lifetime\n   Struct and union objects with array members (either direct or members of nested struct/union members) that are designated by non-lvalue expressions, have temporary lifetime. Temporary lifetime begins when the expression that refers to such object is evaluated and ends at the next sequence point (until C11)when the containing full expression or full declarator ends (since C11).\n   Any attempt to modify an object with temporary lifetime results in undefined behavior.\n", "url": "https://devdocs.io/c/language/lifetime\n"}, {"name": "Logical operators", "type": "STANDARD LIB", "description": "   Logical operators apply standard boolean algebra operations to their operands.\nOperator   Operator name   Example   Result\n!   logical NOT   !a   the logical negation of a\n&&   logical AND   a && b   the logical AND of a and b\n||   logical OR   a || b   the logical OR of a and b\n\n\nLogical NOT\n   The logical NOT expression has the form.\n! expression\n\n   where.\nexpression   -   an expression of any scalar type\n\n   The logical NOT operator has type int. Its value is \u200b0\u200b if expression evaluates to a value that compares unequal to zero. Its value is 1 if expression evaluates to a value that compares equal to zero. (so !E is the same as (0==E)).\n\nLogical AND\n   The logical AND expression has the form.\nlhs && rhs\n\n   where.\nlhs   -   an expression of any scalar type\nrhs   -   an expression of any scalar type, which is only evaluated if lhs does not compare equal to \u200b0\u200b\n\n   The logical-AND operator has type int and the value 1 if both lhs and rhs compare unequal to zero. It has the value \u200b0\u200b otherwise (if either lhs or rhs or both compare equal to zero).\n   There is a sequence point after the evaluation of lhs. If the result of lhs compares equal to zero, then rhs is not evaluated at all (so-called short-circuit evaluation).\n\nLogical OR\n   The logical OR expression has the form.\nlhs || rhs\n\n   where.\nlhs   -   an expression of any scalar type\nrhs   -   an expression of any scalar type, which is only evaluated if lhs compares equal to \u200b0\u200b\n\n   The logical-OR operator has type int and the value 1 if either lhs or rhs compare unequal to zero. It has value \u200b0\u200b otherwise (if both lhs and rhs compare equal to zero).\n   There is a sequence point after the evaluation of lhs. If the result of lhs compares unequal to zero, then rhs is not evaluated at all (so-called short-circuit evaluation).\n", "url": "https://devdocs.io/c/language/operator_logical\n"}, {"name": "Lookup and name spaces", "type": "STANDARD LIB", "description": "   When an identifier is encountered in a C program, a lookup is performed to locate the declaration that introduced that identifier and that is currently in scope. C allows more than one declaration for the same identifier to be in scope simultaneously if these identifiers belong to different categories, called name spaces:\n   At the point of lookup, the name space of an identifier is determined by the manner in which it is used:\n\nNotes\n   The names of macros are not part of any name space because they are replaced by the preprocessor prior to semantic analysis.\n   It is common practice to inject struct/union/enum names into the name space of the ordinary identifiers using a typedef declaration:\n   A well-known example of the same identifier being used across two name spaces is the identifier stat from the POSIX header sys/stat.h. It names a function when used as an ordinary identifier and indicates a struct when used as a tag.\n   Unlike in C++, enumeration constants are not struct members, and their name space is the name space of ordinary identifiers, and since there is no struct scope in C, their scope is the scope in which the struct declaration appears:\n", "url": "https://devdocs.io/c/language/name_space\n"}, {"name": "Main function", "type": "STANDARD LIB", "description": "   Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function called main, which is the designated start of the program.\nint main (void) { body }    (1)\nint main (int argc, char *argv[]) { body }    (2)\n/* another implementation-defined signature */ (since C99)   (3)\n\n\nParameters\nargc   -   Non-negative value representing the number of arguments passed to the program from the environment in which the program is run.\nargv   -   Pointer to the first element of an array of argc + 1 pointers, of which the last one is null and the previous ones, if any, point to strings that represent the arguments passed to the program from the host environment. If argv[0] is not a null pointer (or, equivalently, if argc > 0), it points to a string that represents the program name, which is empty if the program name is not available from the host environment.\n\n   The names argc and argv are arbitrary, as well as the representation of the types of the parameters: int main(int ac, char** av) is equally valid.\n   A common implementation-defined form of main is int main(int argc, char *argv[], char *envp[]), where a third argument, of type char*[], points at an array of pointers to the host environment variables.\n\nReturn value\n   If the return statement is used, the return value is used as the argument to the implicit call to exit() (see below for details). The values zero and EXIT_SUCCESS indicate successful termination, the value EXIT_FAILURE indicates unsuccessful termination.\n\nExplanation\n   The main function is called at program startup, after all objects with static storage duration are initialized. It is the designated entry point to a program that is executed in hosted environment (that is, with an operating system). The name and type of the entry point to any freestanding program (boot loaders, OS kernels, etc) are implementation-defined.\n   The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as command line arguments). The pointers argv[1] .. argv[argc-1] point at the first characters in each of these strings. argv[0] is the pointer to the initial character of a null-terminated multibyte strings that represents the name used to invoke the program itself (or, if this is not supported by the host environment, argv[0][0] is guaranteed to be zero).\n   If the host environment cannot supply both lowercase and uppercase letters, the command line arguments are converted to lowercase.\n   The strings are modifiable, and any modifications made persist until program termination, although these modifications do not propagate back to the host environment: they can be used, for example, with strtok.\n   The size of the array pointed to by argv is at least argc+1, and the last element, argv[argc], is guaranteed to be a null pointer.\n   The main function has several special properties:\n", "url": "https://devdocs.io/c/language/main_function\n"}, {"name": "Member access operators", "type": "STANDARD LIB", "description": "   Member access operators allow access to the members of their operands.\nOperator   Operator name   Example   Description\n[]   array subscript   a[b]   access the bth element of array a\n*   pointer dereference   *a   dereference the pointer a to access the object or function it refers to\n&   address of   &a   create a pointer that refers to the object or function a\n.   member access   a.b   access member b of struct or union a\n->   member access through pointer   a->b   access member b of struct or union pointed to by a\n\n\nSubscript\n   The array subscrpt expression has the form.\npointer-expression [ integer-expression ]   (1)\ninteger-expression [ pointer-expression ]   (2)\n\n   where.\npointer-expression   -   an expression of type pointer to complete object\ninteger-expression   -   an expression of integer type\n\n   The subscript operator expression is an lvalue expression whose type is the type of the object pointed to by pointer-expression.\n   By definition, the subscript operator E1[E2] is exactly identical to *((E1)+(E2)). If pointer-expression is an array expression, it undergoes lvalue-to-rvalue conversion and becomes a pointer to the first element of the array.\n   Due to the definition of the addition between a pointer and an integer, the result is the element of the array with the index equal to the result of integer-expression (or, if pointer-expression was pointing at ith element of some array, the index of the result is i plus the result of integer-expression).\n   Note: see array for the details on multidimensional arrays.\n\nDereference\n   The dereference or indirection expression has the form.\n* pointer-expression\n\n   where.\npointer-expression   -   an expression of any pointer type\n\n   If pointer-expression is a pointer to function, the result of the dereference operator is a function designator for that function.\n   If pointer-expression is a pointer to object, the result is an lvalue expression that designates the pointed-to object.\n   Dereferencing a null pointer, a pointer to an object outside of its lifetime (a dangling pointer), a misaligned pointer, or a pointer with indeterminate value is undefined behavior, except when the dereference operator is nullified by applying the address-of operator to its result, as in &*E.\n\nAddress of\n   The address-of expression has the form.\n& function   (1)\n& lvalue-expression   (2)\n& * expression   (3)\n& expression [ expression ]   (4)\n\n   The address-of operator produces the non-lvalue address of its operand, suitable for initializing a pointer to the type of the operand. If the operand is a function designator ((1)), the result is a pointer to function. If the operand is an object ((2)), the result is a pointer to object.\n   If the operand is the dereference operator, no action is taken (so it's okay to apply &* to a null pointer), except that the result is not an lvalue.\n   If the operand is an array index expression, no action is taken other than the array-to-pointer conversion and the addition, so &a[N] is valid for an array of size N (obtaining a pointer one past the end is okay, dereferencing it is not, but dereference cancels out in this expression).\n\nMember access\n   The member access expression has the form.\nexpression . member-name\n\n   where.\nexpression   -   an expression of struct or union type\nmember-name   -   an identifier that names a member of the struct or union designated by expression\n\n   The member access expression designates the named member of the struct or union designated by its left operand. It has the same value category as its left operand.\n   If the left operand is const or volatile qualified, the result is also qualified. If the left operand is atomic, the behavior is undefined.\n   Note: besides identifiers that name objects of struct or union type, the following expressions may have struct or union types: assignment, function call, comma operator, conditional operator, and compound literal.\n\nMember access through pointer\n   The member access expression has the form.\nexpression -> member-name\n\n   where.\nexpression   -   an expression of type pointer to struct or union\nmember-name   -   an identifier that names a member of the struct or union pointed by expression\n\n   The member access through pointer expression designates the named member of the struct or union type pointed to by its left operand. Its value category is always lvalue.\n   If the type pointed to by the left operand is const or volatile qualified, the result is also qualified. If the type pointed to by the left operand is atomic, the behavior is undefined.\n", "url": "https://devdocs.io/c/language/operator_member_access\n"}, {"name": "Memory model", "type": "STANDARD LIB", "description": "   Defines the semantics of computer memory storage for the purpose of the C abstract machine.\n   The data storage (memory) available to a C program is one or more contiguous sequences of bytes. Each byte in memory has a unique address.\n\nByte\n   A byte is the smallest addressable unit of memory. It is defined as a contiguous sequence of bits, large enough to hold any member of the basic execution character set (the 96 characters that are required to be single-byte). C supports bytes of sizes 8 bits and greater.\n   The types char, unsigned char, and signed char use one byte for both storage and value representation. The number of bits in a byte is accessible as CHAR_BIT.\n   For use of bytes to representation values of other fundamental types (including big-endian and little-endian memory layouts), see object representation.\n\nMemory location\n   A memory location is.\nThreads and data races A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by thrd_create or other means.\nAny thread can potentially access any object in the program (objects with automatic and thread-local storage duration may still be accessed by another thread through a pointer).\nDifferent threads of execution are always allowed to access (read and modify) different memory locations concurrently, with no interference and no synchronization requirements. (note that it is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (non-zero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be).\nWhen an evaluation of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to conflict. A program that has two conflicting evaluations has a data race unless either.\n\n both conflicting evaluations are atomic operations \n one of the conflicting evaluations happens-before another (see memory_order) \n If a data race occurs, the behavior of the program is undefined.  (in particular, mtx_unlock is.\nsynchronized-with, and therefore, happens-before mtx_lock of the same mutex by another thread, which makes it possible to use mutex locks to guard against data races)   Memory order When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See memory_order for details on the order in which writes made from threads become visible to other threads.\n (since C11)\n\n", "url": "https://devdocs.io/c/language/memory_model\n"}, {"name": "Objects and alignment", "type": "STANDARD LIB", "description": "   C programs create, destroy, access, and manipulate objects.\n   An object, in C, is region of data storage in the execution environment, the contents of which can represent values (a value is the meaning of the contents of an object, when interpreted as having a specific type).\n   Every object has.\n   Objects are created by declarations, allocation functions, string literals, compound literals, and by non-lvalue expressions that return structures or unions with array members.\n\nObject representation\n   Except for bit fields, objects are composed of contiguous sequences of one or more bytes, each consisting of CHAR_BIT bits, and can be copied with memcpy into an object of type unsigned char[n], where n is the size of the object. The contents of the resulting array are known as object representation.\n   If two objects have the same object representation, they compare equal (except if they are floating-point NaNs). The opposite is not true: two objects that compare equal may have different object representations because not every bit of the object representation needs to participate in the value. Such bits may be used for padding to satisfy alignment requirement, for parity checks, to indicate trap representations, etc.\n   If an object representation does not represent any value of the object type, it is known as trap representation. Accessing a trap representation in any way other than reading it through an lvalue expression of character type is undefined behavior. The value of a structure or union is never a trap representation even if any particular member is one.\n   For the objects of type char, signed char, and unsigned char, every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).\n   When objects of integer types (short, int, long, long long) occupy multiple bytes, the use of those bytes is implementation-defined, but the two dominant implementations are big-endian (POWER, Sparc, Itanium) and little-endian (x86, x86_64): a big-endian platform stores the most significant byte at the lowest address of the region of storage occupied by the integer, a little-endian platform stores the least significant byte at the lowest address. See Endianness for detail. See also example below.\n   Although most implementations do not allow trap representations, padding bits, or multiple representations for integer types, there are exceptions; for example a value of an integer type on Itanium may be a trap representation.\n\nEffective type\n   Every object has an effective type, which determines which lvalue accesses are valid and which violate the strict aliasing rules.\n   If the object was created by a declaration, the declared type of that object is the object's effective type.\n   If the object was created by an allocation function (including realloc), it has no declared type. Such object acquires an effective type as follows:\n\nStrict aliasing\n   Given an object with effective type T1, using an lvalue expression (typically, dereferencing a pointer) of a different type T2 is undefined behavior, unless:\n   These rules control whether a function that receives two pointers must re-read one after writing through another:\n   Note that restrict qualifier can be used to indicate that two pointers do not alias even if the rules above permit them to be.\n   Note that type-punning may also be performed through the inactive member of a union.\n\nAlignment\n   Every complete object type has a property called alignment requirement, which is an integer value of type size_t representing the number of bytes between successive addresses at which objects of this type can be allocated. The valid alignment values are non-negative integral powers of two.\nThe alignment requirement of a type can be queried with alignof.\n (since C11)\n\n   In order to satisfy alignment requirements of all members of a struct, padding may be inserted after some of its members.\n   Each object type imposes its alignment requirement on every object of that type. The strictest (largest) fundamental alignment of any type is the alignment of max_align_t. The weakest (smallest) alignment is the alignment of the types char, signed char, and unsigned char, and equals 1.\nIf an object's alignment is made stricter (larger) than max_align_t using alignas, it has extended alignment requirement. A struct or union type whose member has extended alignment is an over-aligned type. It is implementation-defined if over-aligned types are supported, and their support may be different in each kind of storage duration.  (since C11)\n\n", "url": "https://devdocs.io/c/language/object\n"}, {"name": "Order of evaluation", "type": "STANDARD LIB", "description": "   Order of evaluation of the operands of any C operator, including the order of evaluation of function arguments in a function-call expression, and the order of evaluation of the subexpressions within any expression is unspecified (except where noted below). The compiler will evaluate them in any order, and may choose another order when the same expression is evaluated again.\n   There is no concept of left-to-right or right-to-left evaluation in C, which is not to be confused with left-to-right and right-to-left associativity of operators: the expression f1() + f2() + f3() is parsed as (f1() + f2()) + f3() due to left-to-right associativity of operator+, but the function call to f3 may be evaluated first, last, or between f1() or f2() at run time.\n\nDefinitions\n   There are two kinds of evaluations performed by the compiler for each expression or subexpression (both of which are optional):\n   If no side effects are produced by an expression and the compiler can determine that the value is not used, the expression may not be evaluated.\n   \"sequenced-before\" is an asymmetric, transitive, pair-wise relationship between evaluations within the same thread (it may extend across threads if atomic types and memory barriers are involved).\nIf evaluation A is sequenced before evaluation B, then evaluation of A will be complete before evaluation of B begins. \n If A is not sequenced before B and B is sequenced before A, then evaluation of B will be complete before evaluation of A begins. \n If A is not sequenced before B and B is not sequenced before A, then two possibilities exist: \n evaluations of A and B are unsequenced: they may be performed in any order and may overlap (within a single thread of execution, the compiler may interleave the CPU instructions that comprise A and B) \n evaluations of A and B are indeterminably-sequenced: they may be performed in any order but may not overlap: either A will be complete before B, or B will be complete before A. The order may be the opposite the next time the same expression is evaluated. \n \n  (since C11)\n\n\nRules\n5) There is a sequence point at the end of a full declarator. 6) There is a sequence point immediately before the return of a library function. 7) There is a sequence point after the action associated with each conversion specifier in formatted I/O (in particular, it is well-formed for scanf to write different fields into the same variable and for printf to read and modify or modify the same variable more than once using %n) 8) There are sequence points before and immediately after each call to a comparison function made by the library functions qsort and bsearch, as well as between any call to the comparison function and the movement of the associated objects made by qsort  (since C99)\n9) The value computations (but not the side-effects) of the operands to any operator are sequenced before the value computation of the result of the operator (but not its side-effects). 10) The side effect (modification of the left argument) of the direct assignment operator and of all compound assignment operators is sequenced after the value computation (but not the side effects) of both left and right arguments. 11) The value computation of the postincrement and postdecrement operators is sequenced before its side-effect. 12) A function call that is not sequenced before or sequenced after another function call is indeterminately sequenced (CPU instructions that constitute different function calls cannot be interleaved, even if the functions are inlined) 13) In initialization list expressions, all evaluations are indeterminately sequenced 14) With respect to an indeterminately-sequenced function call, the operation of compound assignment operators, and both prefix and postfix forms of increment and decrement operators are single evaluations.  (since C11)\n\n\nUndefined behavior\n\nSee also\n   Operator precedence which defines how expressions are built from their source code representation.\n", "url": "https://devdocs.io/c/language/eval_order\n"}, {"name": "Other operators", "type": "STANDARD LIB", "description": "   A collection of operators that do not fit into any of the other major categories.\nOperator   Operator name   Example   Description\n(...)   function call   f(...)   call the function f(), with zero or more arguments\n,   comma operator   a, b   evaluate expression a, disregard its return value and complete any side-effects, then evaluate expression b, returning the type and the result of this evaluation\n(type)   type cast   (type)a   cast the type of a to type\n? :   conditional operator   a ? b : c   if a is logically true (does not evaluate to zero) then evaluate expression b, otherwise evaluate expression c\nsizeof   sizeof operator   sizeof a   the size in bytes of a\n_Alignof (since C11)   _Alignof operator   _Alignof(type)   the alignment required of type\n\n\nFunction call\n   The function call expression has the form.\nexpression ( argument-list(optional) )\n\n   where.\nexpression   -   any expression of pointer-to-function type (after lvalue conversions)\nargument-list   -   comma-separated list of expressions (which cannot be comma operators) of any complete object type. May be omitted when calling functions that take no arguments.\n\n   The behavior of the function call expression depends on whether the prototype of the function being called is in scope at the point of call.\nAdditionally, for every parameter of array type that uses the keyword static between [ and ], the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter.  (since C99)\n\n   The behavior of a function call to a function without a prototype is undefined if.\n   The evaluations of expression that designates the function to be called and all arguments are unsequenced with respect to each other (but there is a sequence point before the body of the function begins executing).\n   Although function call is only defined for pointers to functions, it works with function designators due to the function-to-pointer implicit conversion.\n   Functions that ignore unused arguments, such as printf, must be called with a prototype in scope (the prototype of such functions necessarily uses the trailing ellipsis parameter) to avoid invoking undefined behavior.\n   A post-C11 defect report DR 427 changes the semantics of preparing function parameters when calling a function with a prototype from assignment to initialization from their corresponding arguments, in order to allow parameters of const-qualified type (which are de-facto allowed). The permitted implicit conversions remain implicit conversions as if by assignment since that's what initialization also uses.\nA function call expression where expression consists entirely of an identifier and that identifier is undeclared acts as though the identifier is declared as.\nextern int identifier(); // returns int and has no prototype So the following complete program is valid C89:\nmain() {\n    int n = atoi(\"123\"); // implicitly declares atoi as int atoi()\n}  (until C99)\n\n\nComma operator\n   The comma operator expression has the form.\nlhs , rhs\n\n   where.\nlhs   -   any expression\nrhs   -   any expression other than another comma operator (in other words, comma operator's associativity is left-to-right)\n\n   First, the left operand, lhs, is evaluated and its result value is discarded.\n   Then, a sequence point takes place, so that all side effects of lhs are complete.\n   Then, the right operand, rhs, is evaluated and its result is returned by the comma operator as a non-lvalue.\n\nNotes\n   The type of the lhs may be void (that is, it may be a call to a function that returns void, or it can be an expression cast to void).\n   The comma operator may be lvalue in C++, but never in C.\n   The comma operator may return a struct (the only other expressions that return structs are compound literals, function calls, assignments, and the conditional operator).\n   In the following contexts, the comma operator cannot appear at the top level of an expression because the comma has a different meaning:\n   If the comma operator has to be used in such context, it must be parenthesized:\n   Top-level comma operator is also disallowed in array bounds.\n   Comma operator is not allowed in constant expressions, regardless of whether it's on the top level or not.\n\nCast operator\n   See cast operator.\n\nConditional operator\n   The conditional operator expression has the form.\ncondition ? expression-true : expression-false\n\n   where.\ncondition   -   an expression of scalar type\nexpression-true   -   the expression that will be evaluated if condition compares unequal to zero\nexpression-false   -   the expression that will be evaluated if condition compares equal to zero\n\n   Only the following expressions are allowed as expression-true and expression-false.\n   The conditional operator is never an lvalue expression, although it may return objects of struct/union type. The only other expressions that may return stucts are assignment, comma, function call, and compound literal.\n   Note that in C++, it may be an lvalue expression.\n   See operator precedence for the details on the relative precedence of this operator and assignment.\n   Conditional operator has right-to-left associativity, which allows chaining.\n\nsizeof operator\n   See sizeof operator.\n\n_Alignof operator\n   See _Alignof operator.\n", "url": "https://devdocs.io/c/language/operator_other\n"}, {"name": "Phases of translation", "type": "STANDARD LIB", "description": "   The C source file is processed by the compiler as if the following phases take place, in this exact order. Actual implementation may combine these actions or process them differently as long as the behavior is the same.\n\nPhase 1\n\nPhase 2\n\nPhase 3\n   If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as maximal munch.\n   The sole exception to the maximal munch rule is:\n\nPhase 4\n\nPhase 5\n   Note: the conversion performed at this stage can be controlled by command line options in some implementations: gcc and clang use -finput-charset to specify the encoding of the source character set, -fexec-charset and -fwide-exec-charset to specify the encodings of the execution character set in the string literals and character constants that don't have an encoding prefix (since C11).\n\nPhase 6\n   Adjacent string literals are concatenated.\n\nPhase 7\n   Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a translation unit.\n\nPhase 8\n   Linking takes place: Translation units and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment (the OS).\n", "url": "https://devdocs.io/c/language/translation_phases\n"}, {"name": "Pointer declaration", "type": "STANDARD LIB", "description": "   Pointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers. Pointer may also refer to nothing, which is indicated by the special null pointer value.\n\nSyntax\n   In the declaration grammar of a pointer declaration, the type-specifier sequence designates the pointed-to type (which may be function or object type and may be incomplete), and the declarator has the form:\n* qualifiers(optional) declarator   (1)\n\n   where declarator may be the identifier that names the pointer being declared, including another pointer declarator (which would indicate a pointer to a pointer):\n   The qualifiers that appear between * and the identifier (or other nested declarator) qualify the type of the pointer that is being declared:\n\nExplanation\n   Pointers are used for indirection, which is a ubiquitous programming technique; they can be used to implement pass-by-reference semantics, to access objects with dynamic storage duration, to implement \"optional\" types (using the null pointer value), aggregation relationship between structs, callbacks (using pointers to functions), generic interfaces (using pointers to void), and much more.\n   A pointer to object can be initialized with the result of the address-of operator applied to an expression of object type (which may be incomplete):\n   Pointers may appear as operands to the indirection operator (unary *), which returns the lvalue identifying the pointed-to object:\n   Pointers to objects of struct and union type may also appear as the left-hand operands of the member access through pointer operator ->.\n   Because of the array-to-pointer implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:\n   Certain addition, subtraction, compound assignment, increment, and decrement operators are defined for pointers to elements of arrays.\n   Comparison operators are defined for pointers to objects in some situations: two pointers that represent the same address compare equal, two null pointer values compare equal, pointers to elements of the same array compare the same as the array indexes of those elements, and pointers to struct members compare in order of declaration of those members.\n   Many implementations also provide strict total ordering of pointers of random origin, e.g. if they are implemented as addresses within continuous (\"flat\") virtual address space.\n   A pointer to function can be initialized with an address of a function. Because of the function-to-pointer conversion, the address-of operator is optional:\n   Unlike functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, passed to other functions as arguments, etc.\n   A pointer to function can be used on the left-hand side of the function call operator; this invokes the pointed-to function:\n   Dereferencing a function pointer yields the function designator for the pointed-to function:\n   Equality comparison operators are defined for pointers to functions (they compare equal if pointing to the same function).\n   Because compatibility of function types ignores top-level qualifiers of the function parameters, pointers to functions whose parameters only differ in their top-level qualifiers are interchangeable:\n   Pointer to object of any type can be implicitly converted to pointer to void (optionally const or volatile-qualified), and vice versa:\n   Pointers to void are used to pass objects of unknown type, which is common in generic interfaces: malloc returns void*, qsort expects a user-provided callback that accepts two const void* arguments. pthread_create expects a user-provided callback that accepts and returns void*. In all cases, it is the caller's responsibility to convert the pointer to the correct type before use.\n\nNull pointers\n   Pointers of every type have a special value known as null pointer value of that type. A pointer whose value is null does not point to an object or a function (dereferencing a null pointer is undefined behavior), and compares equal to all pointers of the same type whose value is also null.\n   To initialize a pointer to null or to assign the null value to an existing pointer, a null pointer constant (NULL, or any other integer constant with the value zero) may be used. static initialization also initializes pointers to their null values.\n   Null pointers can indicate the absence of an object or can be used to indicate other types of error conditions. In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, free does nothing when a null pointer is passed).\n\nNotes\n   Although any pointer to object can be cast to pointer to object of a different type, dereferencing a pointer to the type different from the declared type of the object is almost always undefined behavior. See strict aliasing for details.\nIt is possible to indicate to a function that accesses objects through pointers that those pointers do not alias. See restrict for details.\n (since C99)\n\n   lvalue expressions of array type, when used in most contexts, undergo an implicit conversion to the pointer to the first element of the array. See array for details.\n   Pointers to char are often used to represent strings. To represent a valid byte string, a pointer must be pointing at a char that is an element of an array of char, and there must be a char with the value zero at some index greater or equal to the index of the element referenced by the pointer.\n", "url": "https://devdocs.io/c/language/pointer\n"}, {"name": "Preprocessor", "type": "STANDARD LIB", "description": "   The preprocessor is executed at translation phase 4, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.\n\nDirectives\n   The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:\n   The null directive (# followed by a line break) is allowed and has no effect.\n\nCapabilities\n   The preprocessor has the source file translation capabilities:\n   The following aspects of the preprocessor can be controlled:\n\nFootnotes\n", "url": "https://devdocs.io/c/preprocessor\n"}, {"name": "restrict type qualifier", "type": "STANDARD LIB", "description": "   Each individual type in the C type system has several qualified versions of that type, corresponding to one, two, or all three of the const, volatile, and, for pointers to object types, restrict qualifiers. This page describes the effects of the restrict qualifier.\n   Only pointers to object types may be restrict-qualified (in particular, int restrict *p and float (* restrict f9)(void) are errors).\n   restrict semantics apply to lvalue expressions only; for example, a cast to restrict-qualified pointer or a function call returning a restrict-qualified pointer are not lvalues and the qualifier has no effect.\n   During each execution of a block in which a restricted pointer P is declared (typically each execution of a function body in which P is a function parameter), if some object that is accessible through P (directly or indirectly) is modified, by any means, then all accesses to that object (both reads and writes) in that block must occur through P (directly or indirectly), otherwise the behavior is undefined:\n   If the object is never modified, it may be aliased and accessed through different restrict-qualified pointers (note that if the objects pointed to by aliased restrict-qualified pointers are, in turn, pointers, this aliasing can inhibit optimization).\n   Assignment from one restricted pointer to another is undefined behavior, except when assigning from a pointer to an object in some outer block to a pointer in some inner block (including using a restricted pointer argument when calling a function with a restricted pointer parameter) or when returning from a function (and otherwise when the block of the from-pointer ended):\n   Restricted pointers can be assigned to unrestricted pointers freely, the optimization opportunities remain in place as long as the compiler is able to analyze the code:\n   If an array type is declared with the restrict type qualifier (through the use of typedef), the array type is not restrict-qualified, but its element type is:\n   In a function declaration, the keyword restrict may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed:\n\nNotes\n   The intended use of the restrict qualifier (like the register storage class) is to promote optimization, and deleting all instances of the qualifier from all preprocessing translation units composing a conforming program does not change its meaning (i.e., observable behavior).\n   The compiler is free to ignore any or all aliasing implications of uses of restrict.\n   To avoid undefined behavior, the programmer must ensure that the aliasing assertions made by the restrict-qualified pointers are not violated.\n   Many compilers provide, as a language extension, the opposite of restrict: an attribute indicating that pointers may alias even if their types differ: may_alias (gcc),\n   There are several common usage patterns for restrict-qualified pointers:\n   A file-scope restrict-qualified pointer has to point into a single array object for the duration of the program. That array object may not be referenced both through the restricted pointer and through either its declared name (if it has one) or another restricted pointer.\n   File scope restricted pointers are useful in providing access to dynamically allocated global arrays; the restrict semantics make it possible to optimize references through this pointer as effectively as references to a static array through its declared name:\n   The most popular use case for restrict-qualified pointers is the use as function parameters.\n   In the following example, the compiler may infer that there is no aliasing of modified objects, and so optimize the loop aggressively. Upon entry to f, the restricted pointer a must provide exclusive access to its associated array. In particular, within f neither b nor c may point into the array associated with a, because neither is assigned a pointer value based on a. For b, this is evident from the const-qualifier in its declaration, but for c, an inspection of the body of f is required:\n   Note that it is permitted for c to point into the array associated with b. Note also that, for these purposes, the \"array\" associated with a particular pointer means only that portion of an array object which is actually referenced through that pointer.\n   Note that in the example above, the compiler can infer that a and b do not alias because b's constness guarantees that it cannot become dependent on a in the body of the function. Equivalently, the programmer could write void f(int n, float * a, float const * restrict b), in which case the compiler can reason that objects referenced through b cannot be modified, and so no modified object can be referenced using both b and a. If the programmer were to write void f(int n, float * restrict a, float * b), the compiler would be unable to infer non-aliasing of a and b without examining the body of the function.\n   In general, it is best to explicitly annotate all non-aliasing pointers in a function's prototype with restrict.\n   A block scope restrict-qualified pointer makes an aliasing assertion that is limited to its block. It allows local assertions that apply only to important blocks, such as tight loops. It also makes it possible to convert a function that takes restrict-qualified pointers into a macro:\n   The scope of the aliasing assertion made by a restrict-qualified pointer that is a member of a struct is the scope of the identifier used to access the struct.\n   Even if the struct is declared at file scope, when the identifier used to access the struct has block scope, the aliasing assertions in the struct also have block scope; the aliasing assertions are only in effect within a block execution or a function call, depending on how the object of this struct type was created:\n\nKeywords\n   restrict.\n", "url": "https://devdocs.io/c/language/restrict\n"}, {"name": "return statement", "type": "STANDARD LIB", "description": "   Terminates current function and returns specified value to the caller function.\n\nSyntax\nreturn expression ;   (1)\nreturn ;   (2)\n\n\nExplanation\n   If the type of the expression is different from the return type of the function, its value is converted as if by assignment to an object whose type is the return type of the function, except that overlap between object representations is permitted:\n   If the return type is a real floating type, the result may be represented in greater range and precision than implied by the new type.\n   Reaching the end of a function other than main is equivalent to return;. For main, see main function. Reaching the end of any other value-returning function is undefined behavior, but only if the result of the function is used in an expression.\n   Executing the return statement in a no-return function is undefined behavior.\n\nKeywords\n   return.\n", "url": "https://devdocs.io/c/language/return\n"}, {"name": "Scalar initialization", "type": "STANDARD LIB", "description": "   When initializing an object of scalar type, the initializer must be a single expression.\n   The initializer for a scalar (an object of integer type including booleans and enumerated types, floating type including complex and imaginary, and pointer type including pointer to function) must be a single expression, optionally enclosed in braces:\n= expression   (1)\n= {  expression }    (2)\n\n   The expression is evaluated, and its value, after conversion as if by assignment to the type of the object, becomes the initial value of the object being initialized.\n\nNotes\n   Because of the rules that apply to conversions as if by assignment, const and volatile qualifiers on the declared type are ignored when determining which type to convert the expression to.\n   See initialization for the rules that apply when no initializer is used.\n   As with all other initializations, expression must be a constant expression when initializing objects of static or thread-local storage duration.\n   The expression cannot be a comma operator (unless parenthesized) because the comma at the top level would be interpreted as the beginning of the next declarator.\n   When initializing objects of floating-point type, all computations for the objects with automatic storage duration are done as-if at execution time and are affected by the current rounding; floating-point errors are reported as specified in math_errhandling. For objects of static and thread-local storage duration, computations are done as-if at compile time, and no exceptions are raised:\n", "url": "https://devdocs.io/c/language/scalar_initialization\n"}, {"name": "Scope", "type": "STANDARD LIB", "description": "   Each identifier that appears in a C program is visible (that is, may be used) only in some possibly discontiguous portion of the source code called its scope.\n   Within a scope, an identifier may designate more than one entity only if the entities are in different name spaces.\n   C has four kinds of scopes:\n\nNested scopes\n   If two different entities named by the same identifier are in scope at the same time, and they belong to the same name space, the scopes are nested (no other form of scope overlap is allowed), and the declaration that appears in the inner scope hides the declaration that appears in the outer scope:\n\nBlock scope\n   The scope of any identifier declared inside a compound statement, including function bodies, or in any expression, declaration, or statement appearing in if, switch, for, while, or do-while statement (since C99), or within the parameter list of a function definition begins at the point of declaration and ends at the end of the block or statement in which it was declared.\nUntil C99, selection and iteration statements did not establish their own block scopes (although if a compound statement was used in the statement, it had its usual block scope):\nenum {a, b};\nint different(void)\n{\n    if (sizeof(enum {b, a}) != sizeof(int))\n        return a; // a == 1\n    return b; // b == 0 in C89, b == 1 in C99\n}  (since C99)\n\n   Block-scope variables have no linkage and automatic storage duration by default. Note that storage duration for non-VLA local variables begins when the block is entered, but until the declaration is seen, the variable is not in scope and cannot be accessed.\n\nFile scope\n   The scope of any identifier declared outside of any block or parameter list begins at the point of declaration and ends at the end of the translation unit.\n   File-scope identifiers have external linkage and static storage duration by default.\n\nFunction scope\n   A label (and only a label) declared inside a function is in scope everywhere in that function, in all nested blocks, before and after its own declaration. Note: a label is declared implicitly, by using an otherwise unused identifier before the colon character before any statement.\n\nFunction prototype scope\n   The scope of a name introduced in the parameter list of a function declaration that is not a definition ends at the end of the function declarator.\n   Note that if there are multiple or nested declarators in the declaration, the scope ends at the end of the nearest enclosing function declarator:\n\nPoint of declaration\n   The scope of structure, union, and enumeration tags begins immediately after the appearance of the tag in a type specifier that declares the tag.\n   The scope of enumeration constant begins immediately after the appearance of its defining enumerator in an enumerator list.\n   The scope of any other identifier begins just after the end of its declarator and before the initializer, if any:\n   As a special case, the scope of a type name that is not a declaration of an identifier is considered to begin just after the place within the type name where the identifier would appear were it not omitted.\n\nNotes\n   Prior to C89, identifiers with external linkage had file scope even when introduced within a block, and because of that, a C89 compiler is not required to diagnose the use of an extern identifier that has gone out of scope (such use is undefined behavior).\n   Local variables within a loop body can hide variables declared in the init clause of a for loop in C (their scope is nested), but cannot do that in C++.\n   Unlike C++, C has no struct scope: names declared within a struct/union/enum declaration are in the same scope as the struct declaration (except that data members are in their own member name space):\n", "url": "https://devdocs.io/c/language/scope\n"}, {"name": "sizeof operator", "type": "STANDARD LIB", "description": "   Queries size of the object or type.\n   Used when actual size of the object must be known.\n\nSyntax\nsizeof( type )   (1)\nsizeof expression   (2)\n\n   Both versions return a value of type size_t.\n\nExplanation\n\nNotes\n   Depending on the computer architecture, a byte may consist of 8 or more bits, the exact number provided as CHAR_BIT.\n   sizeof(char), sizeof(signed char), and sizeof(unsigned char) always return 1.\n   sizeof cannot be used with function types, incomplete types (including void), or bit field lvalues.\n   When applied to an operand that has structure or union type, the result is the total number of bytes in such an object, including internal and trailing padding. The trailing padding is such that if the object were an element of an array, the alignment requirement of the next element of this array would be satisfied, in other words, sizeof(T) returns the size of an element of a T[] array.\nIf type is a VLA type and changing the value of its size expression would not affect the result of sizeof, it is unspecified whether or not the size expression is evaluated.\n (since C99)\n\n   Except if the type of expression is a VLA,  (since C99)expression is not evaluated and the sizeof operator may be used in an integer constant expression.\nIf the type of expression is a variable-length array type, expression is evaluated and the size of the array it evaluates to is calculated at run time.\n (since C99)\n\n   Number of elements in any array a including VLA (since C99) may be determined with the expression sizeof a / sizeof a[0]. Note that if a has pointer type (such as after array-to-pointer conversion of function parameter type adjustment), this expression would simply divide the number of bytes in a pointer type by the number of bytes in the pointed type.\n\nKeywords\n   sizeof.\n", "url": "https://devdocs.io/c/language/sizeof\n"}, {"name": "Statements", "type": "STANDARD LIB", "description": "   Statements are fragments of the C program that are executed in sequence. The body of any function is a compound statement, which, in turn is a sequence of statements and declarations:\n   There are five types of statements:\n\nLabels\n   Any statement can be labeled, by providing a name followed by a colon before the statement itself.\nidentifier : statement   (1)\ncase constant_expression : statement   (2)\ndefault : statement   (3)\n\n   Any statement (but not a declaration) may be preceded by any number of labels, each of which declares identifier to be a label name, which must be unique within the enclosing function (in other words, label names have function scope).\n   Label declaration has no effect on its own, does not alter the flow of control, or modify the behavior of the statement that follows in any way.\n\nCompound statements\n   A compound statement, or block, is a brace-enclosed sequence of statements and declarations.\n{ statement | declaration...(optional) }    (1)\n\n   The compound statement allows a set of declarations and statements to be grouped into one unit that can be used anywhere a single statement is expected (for example, in an if statement or an iteration statement):\n   Each compound statement introduces its own block scope.\n   The initializers of the variables with automatic storage duration declared inside a block and the VLA declarators are executed when flow of control passes over these declarations in order, as if they were statements:\n\nExpression statements\n   An expression followed by a semicolon is a statement.\nexpression(optional) ;   (1)\n\n   Most statements in a typical C program are expression statements, such as assignments or function calls.\n   An expression statement without an expression is called a null statement. It is often used to provide an empty body to a for or while loop. It can also be used to carry a label in the end of a compound statement or before a declaration:\n\nSelection statements\n   The selection statements choose between one of several statements depending on the value of an expression.\nif ( expression ) statement   (1)\nif ( expression ) statement else statement   (2)\nswitch ( expression ) statement   (3)\n\n\nIteration statements\n   The iteration statements repeatedly execute a statement.\nwhile ( expression ) statement   (1)\ndo statement while ( expression ) ;   (2)\nfor ( init_clause ; expression(optional) ; expression(optional) ) statement   (3)\n\n\nJump statements\n   The jump statements unconditionally transfer flow control.\nbreak ;   (1)\ncontinue ;   (2)\nreturn expression(optional) ;   (3)\ngoto identifier ;   (4)\n\n", "url": "https://devdocs.io/c/language/statements\n"}, {"name": "static assert declaration", "type": "STANDARD LIB", "description": "\nSyntax\n_Static_assert ( expression , message )     (since C11)\n_Static_assert ( expression )     (since C2x)\n\nexpression   -   any integer constant expression\nmessage   -   any string literal\n\n   This keyword is also available as convenience macro static_assert, available in the header <assert.h>.\n\nExplanation\n   The constant expression is evaluated at compile time and compared to zero. If it compares equal to zero, a compile-time error occurs and the compiler must display message (if provided) as part of the error message (except that characters not in basic source character set aren't required to be displayed).\n   Otherwise, if expression does not equal zero, nothing happens; no code is emitted.\n\nKeywords\n   _Static_assert.\n", "url": "https://devdocs.io/c/language/static_assert\n"}, {"name": "Static storage duration", "type": "STANDARD LIB", "description": "   An object whose identifier is declared without the storage-class specifier _Thread_local, and either with external or internal linkage or with the storage-class specifier static, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.\n\nNotes\n   Since its stored value is initialized only once, an object with static storage duration can profile the invocations of a function.\n   The other use of the keyword static is file scope.\n", "url": "https://devdocs.io/c/language/static_storage_duration\n"}, {"name": "Storage-class specifiers", "type": "STANDARD LIB", "description": "   Specify storage duration and linkage of objects and functions:\n_Thread_local - thread storage duration   (since C11)\n\n\nExplanation\n   Storage-class specifiers appear in declarations. At most one specifier may be used, except that _Thread_local may be combined with static or extern to adjust linkage (since C11). The storage-class specifiers determine two independent properties of the names they declare: storage duration and linkage.\n5) _Thread_local indicates thread storage duration. It cannot be used with function declarations. If it is used on a declaration of an object, it must be present on every declaration of the same object. If it is used on a block-scope declaration, it must be combined with either static or extern to decide linkage.  (since C11)\n\n   If no storage-class specifier is provided, the defaults are:\n   For any struct or union declared with a storage-class specifier, the storage duration (but not linkage) applies to their members, recursively.\n   Function declarations at block scope can use extern or none at all. Function declarations at file scope can use extern or static.\n   Function parameters cannot use any storage-class specifiers other than register. Note that static has special meaning in function parameters of array type.\n\nStorage duration\n   Every object has a property called storage duration, which limits the object lifetime. There are four kinds of storage duration in C:\nthread storage duration. The storage duration is the entire execution of the thread in which it was created, and the value stored in the object is initialized when the thread is started. Each thread has its own, distinct, object. If the thread that executes the expression that accesses this object is not the thread that executed its initialization, the behavior is implementation-defined. All objects declared _Thread_local have this storage duration.   (since C11)\n\n   Linkage refers to the ability of an identifier (variable or function) to be referred to in other scopes. If a variable or function with the same identifier is declared in several scopes, but cannot be referred to from all of them, then several instances of the variable are generated. The following linkages are recognized:\n   If the same identifier appears with both internal and external linkage in the same translation unit, the behavior is undefined. This is possible when tentative definitions are used.\n   Declarations with external linkage are commonly made available in header files so that all translation units that #include the file may refer to the same identifier that are defined elsewhere.\n   Any declaration with internal linkage that appears in a header file results in a separate and distinct object in each translation unit that includes that file.\n   Library interface:\n   Library implementation:\n   Application code:\n\nKeywords\n   auto, register, static, extern, _Thread_local.\n\nNotes\n   The keyword _Thread_local is usually used through the convenience macro thread_local, defined in the header threads.h.\n   The typedef specifier is formally listed as a storage-class specifier in the C language grammar, but it is used to declare type names and does not specify storage.\n   Names at file scope that are const and not extern have external linkage in C (as the default for all file-scope declarations), but internal linkage in C++.\n", "url": "https://devdocs.io/c/language/storage_duration\n"}, {"name": "string literals", "type": "STANDARD LIB", "description": "   Constructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code.\n\nSyntax\n\" s-char-sequence \"   (1)\nu8 \" s-char-sequence \"   (2)   (since C11)\nu \" s-char-sequence \"   (3)   (since C11)\nU \" s-char-sequence \"   (4)   (since C11)\nL \" s-char-sequence \"   (5)\n\n   where.\ns-char-sequence   -   zero or more characters, each of which is either a multibyte character from the source character set (excluding (\"), \\, and newline), or character escape, hex escape, octal escape, or unified character name (since C99) as defined in escape sequences.\n\n\nExplanation\n   First, at translation phase 6 (after macro expansion), the adjacent string literals (that is, string literals separated by whitespace only) are concatenated.\nOnly two narrow or two wide string literals may be concatenated.\n (until C99)\nIf one literal is unprefixed, the resulting string literal has the width/encoding specified by the prefixed literal. If the two string literals have different encoding prefixes, concatenation is implementation-defined.\nL\"\u0394x = %\" PRId16 // at phase 4, PRId16 expands to \"d\"\n                 // at phase 6, L\"\u0394x = %\" and \"d\" form L\"\u0394x = %d\"  (since C99)\n\n   Secondly, at translation phase 7, a terminating null character is added to each string literal, and then each literal initializes an unnamed array with static storage duration and length just enough to contain the contents of the string literal plus one the null terminator.\n   String literals are not modifiable (and in fact may be placed in read-only memory such as .rodata). If a program attempts to modify the static array formed by a string literal, the behavior is undefined.\n   It is neither required nor forbidden for identical string literals to refer to the same location in memory. Moreover, overlapping string literals or string literals that are substrings of other string literals may be combined.\n\nNotes\n   A string literal is not necessarily a string; if a string literal has embedded null characters, it represents an array which contains more than one string:\n   If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence, but string concatenation can be used as a workaround:\n   String literals can be used to initialize arrays, and if the size of the array is one less the size of the string literal, the null terminator is ignored:\n   The encoding of character string literals (1) and wide string literals (5) is implementation-defined. For example, gcc selects them with the commandline options -fexec-charset and -fwide-exec-charset.\n", "url": "https://devdocs.io/c/language/string_literal\n"}, {"name": "Struct and union initialization", "type": "STANDARD LIB", "description": "   When initializing an object of struct or union type, the initializer must be a non-empty, brace-enclosed, comma-separated list of initializers for the members:\n= {  expression , ... }      (until C99)\n= {  designator(optional) expression , ... }      (since C99)\n\n   where the designator is a sequence (whitespace-separated or adjacent) of individual member designators of the form . member and array designators of the form [ index ].\n   All members that are not initialized explicitly are initialized implicitly the same way as objects that have static storage duration.\n\nExplanation\n   When initializing a union, the initializer list must have only one member, which initializes the first member of the union unless a designated initializer is used (since C99).\n   When initializing a struct, the first initializer in the list initializes the first declared member (unless a designator is specified) (since C99), and all subsequent initializers without designators  (since C99)initialize the struct members declared after the one initialized by the previous expression.\nA designator causes the following initializer to initialize the struct member described by the designator. Initialization then continues forward in order of declaration, beginning with the next element declared after the one described by the designator.\nstruct {int sec,min,hour,day,mon,year;} z\n   = {.day=31,12,2014,.sec=30,15,17}; // initializes z to {30,15,17,31,12,2014}  (since C99)\n\n   It's an error to provide more initializers than members.\n\nNested initialization\n   If the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:\n   If the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new current object. The members of the current object are initialized in their natural order, unless designators are used (since C99): array elements in subscript order, struct members in declaration order, only the first declared member of any union. The subobjects within the current object that aren't explicitly initialized by the closing brace are implicitly initialized.\n   If the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:\nWhen designators are nested, the designators for the members follow the designators for the enclosing structs/unions/arrays. Within any nested bracketed initializer list, the outermost designator refers to the current object and selects the subobject to be initialized within the current object only.\nstruct example ex2 = { // current object is ex2, designators are for members of example\n                       .in_u.a8[0]=127, 0, 0, 1, .addr=80}; \nstruct example ex3 = {80, .in_u={ // changes current object to the union ex.in_u\n                           127,\n                           .a8[2]=1 // this designator refers to the member of in_u\n                      } }; If any subobject is explicitly initialized twice (which may happen when designators are used), the initializer that appears later in the list is the one used (the earlier initializer may not be evaluated):\nstruct {int n;} s = {printf(\"a\\n\"), // this may be printed or skipped\n                     .n=printf(\"b\\n\")}; // always printed Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list:\n#include <stdio.h>\ntypedef struct { int k; int l; int a[2]; } T;\ntypedef struct { int i;  T t; } S;\nT x = {.l = 43, .k = 42, .a[1] = 19, .a[0] = 18 };\n // x initialized to {42, 43, {18, 19} }\nint main(void)\n{\n    S l = { 1,          // initializes l.i to 1\n           .t = x,      // initializes l.t to {42, 43, {18, 19} }\n           .t.l = 41,   // changes l.t to {42, 41, {18, 19} }\n           .t.a[1] = 17 // changes l.t to {42, 41, {18, 17} }\n          };\n    printf(\"l.t.k is %d\\n\", l.t.k); // .t = x sets l.t.k to 42 explicitly\n                                    // .t.l = 42 would zero out l.t.k implicitly\n} Output:\nl.t.k is 42 However, when an initializer begins with a left open brace, its current object is fully re-initialized and any prior explicit initializers for any of its subobjects are ignored:\nstruct fred { char s[4]; int n; };\nstruct fred x[ ] = { { { \"abc\" }, 1 }, // inits x[0] to { {'a','b','c','\\0'}, 1 }\n                      [0].s[0] = 'q'   // changes x[0] to { {'q','b','c','\\0'}, 1 }\n                   };\nstruct fred y[ ] = { { { \"abc\" }, 1 }, // inits y[0] to { {'a','b','c','\\0'}, 1 }\n                     [0] = { // current object is now the entire y[0] object\n                             .s[0] = 'q' \n                            } // replaces y[0] with { {'q','\\0','\\0','\\0'}, 0 }\n                    };  (since C99)\n\n\nNotes\n   The initializer list may have a trailing comma, which is ignored.\n   In C, the braced list of initializers cannot be empty (note that C++ allows empty lists, and also note that a struct in C cannot be empty):\nEvery expression in the initializer list must be a constant expression when initializing aggregates of any storage duration.\n (until C99)\nAs with all other initialization, every expression in the initializer list must be a constant expression when initializing aggregates of static or thread-local (since C11) storage duration:\nstatic struct {char* p} s = {malloc(1)}; // error The order of evaluation of the subexpressions in any initializer is indeterminately sequenced:\nint n = 1;\nstruct {int x,y;} p = {n++, n++}; // unspecified, but well-defined behavior:\n                                  // n is incremented twice in arbitrary order\n                                  // p equal {1,2} and {2,1} are both valid  (since C99)\n\n", "url": "https://devdocs.io/c/language/struct_initialization\n"}, {"name": "Struct declaration", "type": "STANDARD LIB", "description": "   A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps).\n   The type specifier for a struct is identical to the  union type specifier except for the keyword used:\n\nSyntax\nstruct name(optional) {  struct-declaration-list }    (1)\nstruct name   (2)\n\nname   -   the name of the struct that's being defined\nstruct-declaration-list   -   any number of variable declarations, bit field declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed (except for the flexible array member described below)\n\n\nExplanation\n   Within a struct object, addresses of its elements (and the addresses of the bit field allocation units) increase in order in which the members were defined. A pointer to a struct can be cast to a pointer to its first member (or, if the member is a bit field, to its allocation unit). Likewise, a pointer to the first member of a struct can be cast to a pointer to the enclosing struct. There may be unnamed padding between any two members of a struct or after the last member, but not before the first member. The size of a struct is at least as large as the sum of the sizes of its members.\nIf a struct defines at least one named member, it is allowed to additionally declare its last member with incomplete array type. When an element of the flexible array member is accessed (in an expression that uses operator . or -> with the flexible array member's name as the right-hand-side operand), then the struct behaves as if the array member had the longest size fitting in the memory allocated for this object. If no additional storage was allocated, it behaves as if an array with 1 element, except that the behavior is undefined if that element is accessed or a pointer one past that element is produced. Initialization, sizeof, and the assignment operator ignore the flexible array member. Structures with flexible array members (or unions who have a recursive-possibly structure member with flexible array member) cannot appear as array elements or as members of other structures.\nstruct s { int n; double d[]; }; // s.d is a flexible array member \n \n    struct s t1 = { 0 };         // OK, d is as if double d[1], but UB to access\n    struct s t2 = { 1, { 4.2 } }; // error: initialization ignores flexible array\n \n    // if sizeof (double) == 8\n    struct s *s1 = malloc(sizeof (struct s) + 64); // as if d was double d[8]\n    struct s *s2 = malloc(sizeof (struct s) + 40); // as if d was double d[5]\n \n    s1 = malloc(sizeof (struct s) + 10); // now as if d was double d[1]. Two bytes excess.\n    double *dp = &(s1->d[0]);    // OK\n    *dp = 42;                    // OK\n    s1->d[1]++;                  // Undefined behavior. 2 excess bytes can't be accessed \n                                 // as double.\n \n    s2 = malloc(sizeof (struct s) + 6);  // same, but UB to access because 2 bytes are\n                                         // missing to complete 1 double\n    dp = &(s2->d[0]);            //  OK, can take address just fine\n    *dp = 42;                    //  undefined behavior\n \n    *s1 = *s2; // only copies s.n, not any element of s.d\n               // except those caught in sizeof (struct s)  (since C99)\n\nSimilar to union, an unnamed member of a struct whose type is a struct without name is known as anonymous struct. Every member of an anonymous struct is considered to be a member of the enclosing struct or union. This applies recursively if the enclosing struct or union is also anonymous.\nstruct v {\n   union { // anonymous union\n      struct { int i, j; }; // anonymous structure\n      struct { long k, l; } w;\n   };\n   int m;\n} v1;\n \nv1.i = 2;   // valid\nv1.k = 3;   // invalid: inner structure is not anonymous\nv1.w.k = 5; // valid Similar to union, the behavior of the program is undefined if struct is defined without any named members (including those obtained via anonymous nested structs or unions).\n (since C11)\n\n\nForward declaration\n   A declaration of the following form.\nstruct name ;\n\n   hides any previously declared meaning for the name name in the tag name space and declares name as a new struct name in current scope, which will be defined later. Until the definition appears, this struct name has incomplete type.\n   This allows structs that refer to each other:\n   Note that a new struct name may also be introduced just by using a struct tag within another declaration, but if a previously declared struct with the same name exists in the tag name space, the tag would refer to that name.\n\nKeywords\n   struct.\n\nNotes\n   See struct initialization for the rules regarding the initializers for structs.\n   Because members of incomplete type are not allowed, and a struct type is not complete until the end of the definition, a struct cannot have a member of its own type. A pointer to its own type is allowed, and is commonly used to implement nodes in linked lists or trees.\n   Because a struct declaration does not establish scope, nested types, enumerations and enumerators introduced by declarations within struct-declaration-list are visible in the surrounding scope where the struct is defined.\n", "url": "https://devdocs.io/c/language/struct\n"}, {"name": "switch statement", "type": "STANDARD LIB", "description": "   Executes code according to the value of an integral argument.\n   Used where one or several out of many branches of code need to be executed according to an integral value.\n\nSyntax\nswitch ( expression ) statement\n\nexpression   -   any expression of integer type (char, signed or unsigned integer, or enumeration)\nstatement   -   any statement (typically a compound statement). case: and default: labels are permitted in statement, and break; statement has special meaning.\n\ncase constant_expression : statement   (1)\ndefault : statement   (2)\n\nconstant_expression   -   any integer constant expression\n\n\nExplanation\n   The body of a switch statement may have an arbitrary number of case: labels, as long as the values of all constant_expressions are unique (after conversion to the promoted type of expression). At most one default: label may be present (although nested switch statements may use their own default: labels or have case: labels whose constants are identical to the ones used in the enclosing switch).\n   If expression evaluates to the value that is equal to the value of one of constant_expressions after conversion to the promoted type of expression, then control is transferred to the statement that is labeled with that constant_expression.\n   If expression evaluates to a value that doesn't match any of the case: labels, and the default: label is present, control is transferred to the statement labeled with the default: label.\n   If expression evaluates to a value that doesn't match any of the case: labels, and the default: label is not present, none of the switch body is executed.\n   The break statement, when encountered anywhere in statement, exits the switch statement:\nAs with all other selection and iteration statements, the switch statement establishes block scope: any identifier introduced in the expression goes out of scope after the statement.\nIf a VLA or another identifier with variably-modified type has a case: or a default: label within its scope, the entire switch statement must be in its scope (in other words, a VLA must be declared either before the entire switch or after the last label):\nswitch (expr)\n{\n    int i = 4; // not a VLA; OK to declare here\n    f(i); // never called\n//  int a[i]; // error: VLA cannot be declared here\n  case 0:\n    i = 17;\ndefault:;\n    int a[i]; // OK to declare VLA here\n    printf(\"%d\\n\", i); // prints 17 if expr == 0, prints indeterminate value otherwise\n}  (since C99)\n\n\nKeywords\n   switch, case, default.\n", "url": "https://devdocs.io/c/language/switch\n"}, {"name": "Thread storage duration", "type": "STANDARD LIB", "description": "   An object whose identifier is declared with the storage-class specifier _Thread_local (since C11) has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.\n", "url": "https://devdocs.io/c/language/thread_storage_duration\n"}, {"name": "Type", "type": "STANDARD LIB", "description": "   (See also arithmetic types for the details on most built-in types and  the list of type-related utilities that are provided by the C library).\n   Objects, functions, and expressions have a property called type, which determines the interpretation of the binary value stored in an object or evaluated by the expression.\n\nType classification\n   The C type system consists of the following types:\n   For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers (where allowed by the qualifier's semantics).\n\nCompatible types\n   In a C program, the declarations referring to the same object or function in different translation units do not have to use the same type. They only have to use sufficiently similar types, formally known as compatible types. Same applies to function calls and lvalue accesses; argument types must be compatible with parameter types and lvalue expression type must be compatible with the object type that is accessed.\n   The types T and U are compatible, if.\n   The type char is not compatible with signed char and not compatible with unsigned char.\n   If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.\n   Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.\n\nComposite types\n   A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:\nOtherwise, if one type is a VLA whose size is specified by an expression that is not evaluated, the behavior is undefined. \nOtherwise, if one type is a VLA whose size is specified, the composite type is a VLA of that size. \nOtherwise, if one type is a VLA of unspecified size, the composite type is a VLA of unspecified size. \n  (since C99)\n\n   These rules apply recursively to the types from which the two types are derived.\n   For an identifier with internal or external linkage declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.\n\nIncomplete types\n   An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.\n   The following types are incomplete:\n\nType names\n   A type may have to be named in context other than the declaration. In these situations, type name is used, which is, grammatically, exactly the same as a list of type-specifiers and type-qualifiers, followed by the declarator (see declarations) as would be used to declare a single object or function of this type, except that the identifier is omitted:\n   Except the redundant parentheses around the identifier are meaningful in a type-name and represent \"function with no parameter specification\":\n   Type names are used in the following situations:\ncompound literal   (since C99)\ngeneric selection \n _Alignof \n _Alignas \n _Atomic (when used as a type specifier) \n  (since C11)\n\n   A type name may introduce a new type:\n", "url": "https://devdocs.io/c/language/compatible_type\n"}, {"name": "Type", "type": "STANDARD LIB", "description": "   (See also arithmetic types for the details on most built-in types and  the list of type-related utilities that are provided by the C library).\n   Objects, functions, and expressions have a property called type, which determines the interpretation of the binary value stored in an object or evaluated by the expression.\n\nType classification\n   The C type system consists of the following types:\n   For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers (where allowed by the qualifier's semantics).\n\nCompatible types\n   In a C program, the declarations referring to the same object or function in different translation units do not have to use the same type. They only have to use sufficiently similar types, formally known as compatible types. Same applies to function calls and lvalue accesses; argument types must be compatible with parameter types and lvalue expression type must be compatible with the object type that is accessed.\n   The types T and U are compatible, if.\n   The type char is not compatible with signed char and not compatible with unsigned char.\n   If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.\n   Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.\n\nComposite types\n   A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:\nOtherwise, if one type is a VLA whose size is specified by an expression that is not evaluated, the behavior is undefined. \nOtherwise, if one type is a VLA whose size is specified, the composite type is a VLA of that size. \nOtherwise, if one type is a VLA of unspecified size, the composite type is a VLA of unspecified size. \n  (since C99)\n\n   These rules apply recursively to the types from which the two types are derived.\n   For an identifier with internal or external linkage declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.\n\nIncomplete types\n   An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.\n   The following types are incomplete:\n\nType names\n   A type may have to be named in context other than the declaration. In these situations, type name is used, which is, grammatically, exactly the same as a list of type-specifiers and type-qualifiers, followed by the declarator (see declarations) as would be used to declare a single object or function of this type, except that the identifier is omitted:\n   Except the redundant parentheses around the identifier are meaningful in a type-name and represent \"function with no parameter specification\":\n   Type names are used in the following situations:\ncompound literal   (since C99)\ngeneric selection \n _Alignof \n _Alignas \n _Atomic (when used as a type specifier) \n  (since C11)\n\n   A type name may introduce a new type:\n", "url": "https://devdocs.io/c/language/types\n"}, {"name": "Typedef declaration", "type": "STANDARD LIB", "description": "   The typedef declaration provides a way to declare an identifier as a type alias, to be used to replace a possibly complex type name.\n   The keyword typedef is used in a declaration, in the grammatical position of a storage-class specifier, except that it does not affect storage or linkage:\n\nExplanation\n   If a declaration uses typedef as storage-class specifier, every declarator in it defines an identifier as an alias to the type specified. Since only one storage-class specifier is permitted in a declaration, typedef declaration cannot be static or extern.\n   typedef declaration does not introduce a distinct type, it only establishes a synonym for an existing type, thus typedef names are compatible with the types they alias. Typedef names share the name space with ordinary identifiers such as enumerators, variables and function.\nA typedef for a VLA can only appear at block scope. The length of the array is evaluated each time the flow of control passes over the typedef declaration, as opposed to the declaration of the array itself:\nvoid copyt(int n)\n{\n    typedef int B[n]; // B is a VLA, its size is n, evaluated now\n    n += 1;\n    B a; // size of a is n from before +=1\n    int b[n]; // a and b are different sizes\n    for (int i = 1; i < n; i++)\n        a[i-1] = b[i];\n}  (since C99)\n\n\nNotes\n   typedef name may be an incomplete type, which may be completed as usual:\n   typedef declarations are often used to inject names from the tag name space into the ordinary name space:\n   They can even avoid using the tag name space at all:\n   Typedef names are also commonly used to simplify the syntax of complex declarations:\n   Libraries often expose system-dependent or configuration-dependent types as typedef names, to present a consistent interface to the users or to other library components:\n", "url": "https://devdocs.io/c/language/typedef\n"}, {"name": "Undefined behavior", "type": "STANDARD LIB", "description": "   The C language standard precisely specifies the observable behavior of C language programs, except for the ones in the following categories:\n   (Note: Strictly conforming programs do not depend on any unspecified, undefined, or implementation-defined behavior).\n   The compilers are required to issue diagnostic messages (either errors or warnings) for any programs that violates any C syntax rule or semantic constraint, even if its behavior is specified as undefined or implementation-defined or if the compiler provides a language extension that allows it to accept such program. Diagnostics for undefined behavior are not otherwise required.\n\nUB and optimization\n   Because correct C programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:\n   For example,\n   may be compiled as (demo).\n   May be compiled as (demo).\n   May produce the following output (observed with an older version of gcc):\n   May be compiled as (demo).\n   May be compiled as (demo).\n   may be compiled as (foo with gcc, bar with clang).\n", "url": "https://devdocs.io/c/language/behavior\n"}, {"name": "Union declaration", "type": "STANDARD LIB", "description": "   A union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence). The value of at most one of the members can be stored in a union at any one time.\n   The type specifier for a union is identical to the  struct type specifier except for the keyword used:\n\nSyntax\nunion name(optional) {  struct-declaration-list }    (1)\nunion name   (2)\n\nname   -   the name of the union that's being defined\nstruct-declaration-list   -   any number of variable declarations, bit field declarations, and static assert declarations. Members of incomplete type and members of function type are not allowed.\n\n\nExplanation\n   The union is only as big as necessary to hold its largest member (additional unnamed trailing padding may also be added). The other members are allocated in the same bytes as part of that largest member.\n   A pointer to a union can be cast to a pointer to each of its members (if a union has bit field members, the pointer to a union can be cast to the pointer to the bit field's underlying type). Likewise, a pointer to any member of a union can be cast to a pointer to the enclosing union.\n   If the member used to access the contents of a union is not the same as the member last used to store a value, the object representation of the value that was stored is reinterpreted as an object representation of the new type (this is known as type punning). If the size of the new type is larger than the size of the last-written type, the contents of the excess bytes are unspecified (and may be a trap representation).\nSimilar to struct, an unnamed member of a union whose type is a union without name is known as anonymous union. Every member of an anonymous union is considered to be a member of the enclosing struct or union. This applies recursively if the enclosing struct or union is also anonymous.\nstruct v {\n   union { // anonymous union\n      struct { int i, j; }; // anonymous structure\n      struct { long k, l; } w;\n   };\n   int m;\n} v1;\n \nv1.i = 2;   // valid\nv1.k = 3;   // invalid: inner structure is not anonymous\nv1.w.k = 5; // valid Similar to struct, the behavior of the program is undefined if union is defined without any named members (including those obtained via anonymous nested structs or unions).\n (since C11)\n\n\nKeywords\n   union.\n\nNotes\n   See struct initialization for the rules about initialization of structs and unions.\n   Each member is allocated as if it were the only member of the union, which is why s.c in the example above aliases the first byte of s.s[0].\n", "url": "https://devdocs.io/c/language/union\n"}, {"name": "Value categories", "type": "STANDARD LIB", "description": "   Each expression in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a type and a value category.\n   Every expression belongs to one of three value categories: lvalue, non-lvalue object (rvalue), and function designator.\n\nLvalue expressions\n   Lvalue expression is any expression with object type other than the type void, which potentially designates an object (the behavior is undefined if an lvalue does not actually designate an object when it is evaluated). In other words, lvalue expression evaluates to the object identity. The name of this value category (\"left value\") is historic and reflects the use of lvalue expressions as the left-hand operand of the assignment operator in the CPL programming language.\n   Lvalue expressions can be used in the following lvalue contexts:\n   If an lvalue expression is used in any context other than sizeof, _Alignof, or the operators listed above, non-array lvalues of any complete type undergo lvalue conversion, which models the memory load of the value of the object from its location. Similarly, array lvalues undergo array-to-pointer conversion when used in any context other than sizeof, _Alignof, address-of operator, or array initialization from a string literal.\n   The semantics of const/volatile/restrict-qualifiers and atomic types apply to lvalues only (lvalue conversion strips the qualifiers and removes atomicity).\n   The following expressions are lvalues:\n   A modifiable lvalue is any lvalue expression of complete, non-array type which is not const-qualified, and, if it's a struct/union, has no members that are const-qualified, recursively.\n   Only modifiable lvalue expressions may be used as arguments to increment/decrement, and as left-hand arguments of assignment and compound assignment operators.\n\nNon-lvalue object expressions\n   Colloquially known as rvalues, non-lvalue object expressions are the expressions of object types that do not designate objects, but rather values that have no object identity or storage location. The address of a non-lvalue object expression cannot be taken.\n   The following expressions are non-lvalue object expressions:\n   As a special case, expressions of type void are assumed to be non-lvalue object expressions that yield a value which has no representation and requires no storage.\n   Note that a struct/union rvalue that has a member (possibly nested) of array type does in fact designate an object with temporary lifetime. This object can be accessed through lvalue expressions that form by indexing the array member or by indirection through the pointer obtained by array-to-pointer conversion of the array member.\n\nFunction designator expression\n   A function designator (the identifier introduced by a function declaration) is an expression of function type. When used in any context other than the address-of operator, sizeof, and _Alignof (the last two generate compile errors when applied to functions), the function designator is always converted to a non-lvalue pointer to function. Note that the function-call operator is defined for pointers to functions and not for function designators themselves.\n", "url": "https://devdocs.io/c/language/value_category\n"}, {"name": "Variadic arguments", "type": "STANDARD LIB", "description": "   Variadic functions are functions that may be called with different number of arguments.\n   Only new-style (prototyped) function declarations may be variadic. This is indicated by the parameter of the form ... which must appear last in the parameter list and must follow at least one named parameter.\n   At the function call, each argument that is a part of the variable argument list undergoes special implicit conversions known as default argument promotions.\n   Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the <stdarg.h> library facilities:\nDefined in header <stdarg.h>\nva_start   enables access to variadic function arguments  (function macro)\nva_arg   accesses the next variadic function argument  (function macro)\nva_copy\n(C99)   makes a copy of the variadic function arguments  (function macro)\nva_end   ends traversal of the variadic function arguments  (function macro)\nva_list   holds the information needed by va_start, va_arg, va_end, and va_copy  (typedef)\n\n\nNotes\n   Although old-style (prototype-less) function declarations allow the subsequent function calls to use any number of arguments, they are not allowed to be variadic (as of C89). The definition of such function must specify a fixed number of parameters and cannot use the stdarg.h macros.\n", "url": "https://devdocs.io/c/language/variadic\n"}, {"name": "volatile type qualifier", "type": "STANDARD LIB", "description": "   Each individual type in the C type system has several qualified versions of that type, corresponding to one, two, or all three of the const, volatile, and, for pointers to object types, restrict qualifiers. This page describes the effects of the volatile qualifier.\n   Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a sequence point from the volatile access.\n   A cast of a non-volatile value to a volatile type has no effect. To access a non-volatile object using volatile semantics, its address must be cast to a pointer-to-volatile and then the access must be made through that pointer.\n   Any attempt to read or write to an object whose type is volatile-qualified through a non-volatile lvalue results in undefined behavior:\n   A member of a volatile-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the . operator or the -> operator):\n   If an array type is declared with the volatile type qualifier (through the use of typedef), the array type is not volatile-qualified, but its element type is. If a function type is declared with the volatile type qualified (through the use of typedef), the behavior is undefined.\nIn a function declaration, the keyword volatile may appear inside the square brackets that are used to declare an array type of a function parameter. It qualifies the pointer type to which the array type is transformed.\nThe following two declarations declare the same function:\nvoid f(double x[volatile], const double y[volatile]);\nvoid f(double * volatile x, const double * volatile y);  (since C99)\n\n   A pointer to a non-volatile type can be implicitly converted to a pointer to the volatile-qualified version of the same or compatible type. The reverse conversion can be performed with a cast expression.\n   Note that pointer to pointer to T is not convertible to pointer to pointer to volatile T; for two types to be compatible, their qualifications must be identical:\n\nUses of volatile\n   Note that volatile variables are not suitable for communication between threads; they do not offer atomicity, synchronization, or memory ordering. A read from a volatile variable that is modified by another thread without synchronization or concurrent modification from two unsynchronized threads is undefined behavior due to a data race.\n\nKeywords\n   volatile.\n", "url": "https://devdocs.io/c/language/volatile\n"}, {"name": "while loop", "type": "STANDARD LIB", "description": "   Executes a statement repeatedly, until the value of expression becomes equal to zero. The test takes place before each iteration.\n\nSyntax\nwhile ( expression ) statement\n\nexpression   -   any expression of scalar type. This expression is evaluated before each iteration, and if it compares equal to zero, the loop is exited.\nstatement   -   any statement, typically a compound statement, which serves as the body of the loop\n\n\nExplanation\n   A while statement causes the statement (also called the loop body) to be executed repeatedly until the expression (also called controlling expression) compares equal to zero. The repetition occurs regardless of whether the loop body is entered normally or by a goto into the middle of statement.\n   The evaluation of expression takes place before each execution of statement (unless entered by a goto). If the controlling expression needs to be evaluated after the loop body, the do-while loop may be used.\n   If the execution of the loop needs to be terminated at some point,  break statement can be used as a terminating statement.\n   If the execution of the loop needs to be continued at the end of the loop body,  continue statement can be used as a shortcut.\n   A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; while(true) is always an endless loop.\nAs with all other selection and iteration statements, the while statement establishes block scope: any identifier introduced in the expression goes out of scope after the statement.\n (since C99)\n\n\nNotes\n   Boolean and pointer expressions are often used as loop controlling expressions. The boolean value false and the null pointer value of any pointer type compare equal to zero.\n\nKeywords\n   while.\n", "url": "https://devdocs.io/c/language/while\n"}, {"name": "_Alignof operator", "type": "STANDARD LIB", "description": "   Queries the alignment requirement of its operand type.\n\nSyntax\n_Alignof( type-name )     (since C11)\n\n   This operator is typically used through the convenience macro alignof, which is provided in the header stdalign.h.\n\nExplanation\n   Returns the alignment requirement of the type named by type-name. If type-name is an array type, the result is the alignment requirement of the array element type. The type-name cannot be function type or an incomplete type.\n   The result is an integer constant of type size_t.\n   The operand is not evaluated (so external identifiers used in the operand do not have to be defined).\nIf type is a VLA type, its size expression is not evaluated.\n (since C2x)\n\n\nNotes\n   The use of alignof with expressions is allowed by some C compilers as a non-standard extension.\n\nKeywords\n   _Alignof.\n", "url": "https://devdocs.io/c/language/alignof\n"}, {"name": "_Noreturn function specifier", "type": "STANDARD LIB", "description": "   Specifies that the function does not return to its point of invocation.\n\nSyntax\n_Noreturn function_declaration     (since C11)\n\n\nExplanation\n   The _Noreturn keyword appears in a function declaration and specifies that the function does not return by executing the return statement or by reaching the end of the function body (it may return by executing longjmp). If the function declared _Noreturn returns, the behavior is undefined. A compiler diagnostic is recommended if this can be detected.\n   The _Noreturn specifier may appear more than once in the same function declaration, the behavior is the same as if it appeared once.\n   This specifier is typically used through the convenience macro noreturn, which is provided in the header stdnoreturn.h.\n\nKeywords\n   _Noreturn.\n\nStandard library\n   The following functions are noreturn in the standard library:\n", "url": "https://devdocs.io/c/language/_noreturn\n"}, {"name": "asctime, asctime_s", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nchar* asctime( const struct tm* time_ptr );\n  (1)\nerrno_t asctime_s(char *buf, rsize_t bufsz, const struct tm *time_ptr);\n  (2)   (since C11)\n\n\nParameters\ntime_ptr   -   pointer to a tm object specifying the time to print\nbuf   -   pointer to a user-supplied buffer at least 26 bytes in length\nbufsz   -   size of the user-supplied buffer\n\n\nReturn value\n\nNotes\n   This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends strftime instead. The C standard also recommends strftime instead of asctime and asctime_s because strftime is more flexible and locale-sensitive.\n   POSIX limits undefined behaviors only to when the output string would be longer than 25 characters, when timeptr->tm_wday or timeptr->tm_mon are not within the expected ranges, or when timeptr->tm_year exceeds INT_MAX-1990.\n   Some implementations handle timeptr->tm_mday==0 as meaning the last day of the preceding month.\n", "url": "https://devdocs.io/c/chrono/asctime\n"}, {"name": "clock", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nclock_t clock(void);\n\n   Returns the approximate processor time used by the process since the beginning of an implementation-defined era related to the program's execution. To convert result value to seconds, divide it by CLOCKS_PER_SEC.\n   Only the difference between two values returned by different calls to clock is meaningful, as the beginning of the clock era does not have to coincide with the start of the program. clock time may advance faster or slower than the wall clock, depending on the execution resources given to the program by the operating system. For example, if the CPU is shared by other processes, clock time may advance slower than wall clock. On the other hand, if the current process is multithreaded and more than one execution core is available, clock time may advance faster than wall clock.\n\nParameters\n   (none).\n\nReturn value\n   Processor time used by the program so far or (clock_t)(-1) if that information is unavailable or its value cannot be represented.\n\nNotes\n   On POSIX-compatible systems, clock_gettime with clock id CLOCK_PROCESS_CPUTIME_ID offers better resolution.\n   The value returned by clock() may wrap around on some implementations. For example, on a machine with 32-bit clock_t, it wraps after 2147 seconds or 36 minutes.\n", "url": "https://devdocs.io/c/chrono/clock\n"}, {"name": "CLOCKS_PER_SEC", "type": "STANDARD LIB", "description": "Defined in header <time.h>\n#define CLOCKS_PER_SEC /*implementation defined*/\n\n   Expands to an expression (not necessarily a compile-time constant) of type clock_t equal to the number of clock ticks per second, as returned by clock().\n\nNotes\n   POSIX defines CLOCKS_PER_SEC as one million, regardless of the actual precision of clock.\n   Until standardized as CLOCKS_PER_SEC in C89, this macro was sometimes known by its IEEE std 1003.1-1988 name CLK_TCK: that name was not included in C89 and was removed from POSIX itself in 1996 over ambiguity with _SC_CLK_TCK, which gives number of clocks per second for the function times()).\n", "url": "https://devdocs.io/c/chrono/clocks_per_sec\n"}, {"name": "clock_t", "type": "STANDARD LIB", "description": "Defined in header <time.h>\ntypedef /* unspecified */ clock_t;\n\n   Arithmetic (until C11)Real (since C11) type capable of representing the processor time used by a process. It has implementation-defined range and precision.\n", "url": "https://devdocs.io/c/chrono/clock_t\n"}, {"name": "ctime, ctime_s", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nchar* ctime( const time_t* time );\n  (1)\nerrno_t ctime_s(char *buffer, rsize_t bufsz, const time_t *time);\n  (2)   (since C11)\n\n   The resulting string has the following format:\n   The function does not support localization.\n\nParameters\ntime   -   pointer to a time_t object specifying the time to print\nbuffer   -   pointer to an element of a char array of size at least bufsz\nbufsz   -   max number of bytes to output, typically the size of the buffer pointed to by buffer\n\n\nReturn value\n\nNotes\n   ctime returns a pointer to static data and is not thread-safe. In addition, it modifies the static tm object which may be shared with gmtime and localtime. POSIX marks this function obsolete and recommends strftime instead. The C standard also recommends strftime instead of ctime and ctime_s because strftime is more flexible and locale-sensitive.\n   The behavior of ctime may be undefined for the values of time_t that result in the string longer than 25 characters (e.g. year 10000).\n", "url": "https://devdocs.io/c/chrono/ctime\n"}, {"name": "Date and time utilities", "type": "STANDARD LIB", "description": "\nFunctions\nTime manipulation\nDefined in header <time.h>\ndifftime   computes the difference between times  (function)\ntime   returns the current calendar time of the system as time since epoch  (function)\nclock   returns raw processor clock time since the program is started  (function)\ntimespec_get\n(since C11)   returns the calendar time based on a given time base  (function)\nFormat conversions\nDefined in header <time.h>\nasctimeasctime_s\n(C11)   converts a tm object to a textual representation  (function)\nctimectime_s\n(C11)   converts a time_t object to a textual representation  (function)\nstrftime   converts a tm object to custom textual representation  (function)\nDefined in header <wchar.h>\nwcsftime\n(C95)   converts a tm object to custom wide string textual representation  (function)\nDefined in header <time.h>\ngmtimegmtime_s\n(C11)   converts time since epoch to calendar time expressed as Coordinated Universal Time (UTC)  (function)\nlocaltimelocaltime_s\n(C11)   converts time since epoch to calendar time expressed as local time  (function)\nmktime   converts calendar time to time since epoch  (function)\n\n\nConstants\nDefined in header <time.h>\nCLOCKS_PER_SEC   number of processor clock ticks per second  (macro constant)\n\n\nTypes\nDefined in header <time.h>\ntm   calendar time type  (struct)\ntime_t   calendar time since epoch type  (typedef)\nclock_t   processor time since era type  (typedef)\ntimespec\n(since C11)   time in seconds and nanoseconds  (struct)\n\n", "url": "https://devdocs.io/c/chrono\n"}, {"name": "difftime", "type": "STANDARD LIB", "description": "Defined in header <time.h>\ndouble difftime( time_t time_end, time_t time_beg );\n\n   Computes difference between two calendar times as time_t objects (time_end - time_beg) in seconds. If time_end refers to time point before time_beg then the result is negative.\n\nParameters\ntime_beg, time_end   -   times to compare\n\n\nReturn value\n   Difference between two times in seconds.\n\nNotes\n   On POSIX systems, time_t is measured in seconds, and difftime is equivalent to arithmetic subtraction, but C and C++ allow fractional units for time_t.\n", "url": "https://devdocs.io/c/chrono/difftime\n"}, {"name": "gmtime, gmtime_s", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nstruct tm *gmtime( const time_t *time );\n  (1)\nstruct tm *gmtime_s(const time_t *restrict time, struct tm *restrict result);\n  (2)   (since C11)\n\n\nParameters\ntime   -   pointer to a time_t object to convert\nresult   -   pointer to a struct tm object to store the result\n\n\nReturn value\n\nNotes\n   This function gmtime may not be thread-safe.\n   POSIX requires that this function sets errno to EOVERFLOW if it fails because the argument is too large.\n   POSIX defines a thread-safe alternative gmtime_r, which is similar to the C11 function gmtime_s, except that it does not check the validity of its input parameters.\n", "url": "https://devdocs.io/c/chrono/gmtime\n"}, {"name": "localtime, localtime_s", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nstruct tm *localtime( const time_t *time );\n  (1)\nstruct tm *localtime_s(const time_t *restrict time, struct tm *restrict result);\n  (2)   (since C11)\n\n\nParameters\ntime   -   pointer to a time_t object to convert\nresult   -   pointer to a struct tm object to store the result\n\n\nReturn value\n\nNotes\n   This function localtime may not be thread-safe.\n   POSIX requires that this function sets errno to EOVERFLOW if it fails because the argument is too large.\n   POSIX defines a thread-safe alternative localtime_r, which is similar to the C11 function localtime_s, except that it does not check the validity of its input parameters.\n   POSIX specifies that the timezone information is determined by this function as if by calling tzset, which reads the environment variable TZ.\n", "url": "https://devdocs.io/c/chrono/localtime\n"}, {"name": "mktime", "type": "STANDARD LIB", "description": "Defined in header <time.h>\ntime_t mktime( struct tm *time );\n\n   Renormalizes local calendar time expressed as a struct tm object and also converts it to time since epoch as a time_t object. time->tm_wday and time->tm_yday are ignored. The values in time are not checked for being out of range.\n   A negative value of time->tm_isdst causes mktime to attempt to determine if Daylight Saving Time was in effect in the specified time.\n   If the conversion to time_t is successful, the time object is modified. All fields of time are updated to fit their proper ranges. time->tm_wday and time->tm_yday are recalculated using information available in other fields.\n\nParameters\ntime   -   pointer to a tm object specifying local calendar time to convert\n\n\nReturn value\n   time since epoch as a time_t object on success or -1 if time cannot be represented as a time_t object (POSIX also requires EOVERFLOW to be stored in errno in this case).\n\nNotes\n   If the struct tm object was obtained from POSIX strptime or equivalent function, the value of tm_isdst is indeterminate, and needs to be set explicitly before calling mktime.\n", "url": "https://devdocs.io/c/chrono/mktime\n"}, {"name": "strftime", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nsize_t strftime( char *         str, size_t count, \n                 const char *         format, const struct tm *         time );\n    (until C99)\nsize_t strftime( char *restrict str, size_t count, \n                 const char *restrict format, const struct tm *restrict time );\n    (since C99)\n\n   Converts the date and time information from a given calendar time time to a null-terminated multibyte character string str according to format string format. Up to count bytes are written.\n\nParameters\nstr   -   pointer to the first element of the char array for output\ncount   -   maximum number of bytes to write\nformat   -   pointer to a null-terminated multibyte character string specifying the format of conversion. The format string consists of zero or more conversion specifiers and ordinary characters (except %). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with % character, optionally followed by E or O modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:\n   Conversion specifier   Explanation   Used fields \n   %   writes literal %. The full conversion specification must be %%.   \n   n(C99)   writes newline character   \n   t(C99)   writes horizontal tab character   \n   Year \n   Y   writes year as a decimal number, e.g. 2017   tm_year \n   EY(C99)   writes year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   tm_year \n   y   writes last 2 digits of year as a decimal number (range [00,99])   tm_year \n   Oy(C99)   writes last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 instead of 11 in ja_JP locale   tm_year \n   Ey(C99)   writes year as offset from locale's alternative calendar period %EC (locale-dependent)   tm_year \n   C(C99)   writes first 2 digits of year as a decimal number (range [00,99])   tm_year \n   EC(C99)   writes name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year \n   G(C99)   writes ISO 8601 week-based year, i.e. the year that contains the specified week. In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   g(C99)   writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   Month \n   b   writes abbreviated month name, e.g. Oct (locale dependent)   tm_mon \n   h(C99)   synonym of b   tm_mon \n   B   writes full month name, e.g. October (locale dependent)   tm_mon \n   m   writes month as a decimal number (range [01,12])   tm_mon \n   Om(C99)   writes month using the alternative numeric system, e.g. \u5341\u4e8c instead of 12 in ja_JP locale   tm_mon \n   Week \n   U   writes week of the year as a decimal number (Sunday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OU(C99)   writes week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   W   writes week of the year as a decimal number (Monday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OW(C99)   writes week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   V(C99)   writes ISO 8601 week of the year (range [01,53]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   OV(C99)   writes week of the year, as by %V, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   Day of the year/month \n   j   writes day of the year as a decimal number (range [001,366])   tm_yday \n   d   writes day of the month as a decimal number (range [01,31])   tm_mday \n   Od(C99)   writes zero-based day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   e(C99)   writes day of the month as a decimal number (range [1,31]). Single digit is preceded by a space.\n  tm_mday \n   Oe(C99)   writes one-based day of the month using the alternative numeric system, e.g. \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   Day of the week \n   a   writes abbreviated weekday name, e.g. Fri (locale dependent)   tm_wday \n   A   writes full weekday name, e.g. Friday (locale dependent)   tm_wday \n   w   writes weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday \n   Ow(C99)   writes weekday, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   u(C99)   writes weekday as a decimal number, where Monday is 1 (ISO 8601 format) (range [1-7])   tm_wday \n   Ou(C99)   writes weekday, where Monday is 1, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   Hour, minute, second \n   H   writes hour as a decimal number, 24 hour clock (range [00-23])   tm_hour \n   OH(C99)   writes hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b instead of 18 in ja_JP locale   tm_hour \n   I   writes hour as a decimal number, 12 hour clock (range [01,12])   tm_hour \n   OI(C99)   writes hour from 12-hour clock using the alternative numeric system, e.g. \u516d instead of 06 in ja_JP locale   tm_hour \n   M   writes minute as a decimal number (range [00,59])   tm_min \n   OM(C99)   writes minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 instead of 25 in ja_JP locale   tm_min \n   S   writes second as a decimal number (range [00,60])   tm_sec \n   OS(C99)   writes second using the alternative numeric system, e.g. \u4e8c\u5341\u56db instead of 24 in ja_JP locale   tm_sec \n   Other \n   c   writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all \n   Ec(C99)   writes alternative date and time string, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   x   writes localized date representation (locale dependent)   all \n   Ex(C99)   writes alternative date representation, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   X   writes localized time representation (locale dependent)   all \n   EX(C99)   writes alternative time representation (locale dependent)   all \n   D(C99)   equivalent to \"%m/%d/%y\"   tm_mon, tm_mday, tm_year \n   F(C99)   equivalent to \"%Y-%m-%d\" (the ISO 8601 date format)   tm_mon, tm_mday, tm_year \n   r(C99)   writes localized 12-hour clock time (locale dependent)   tm_hour, tm_min, tm_sec \n   R(C99)   equivalent to \"%H:%M\"   tm_hour, tm_min \n   T(C99)   equivalent to \"%H:%M:%S\" (the ISO 8601 time format)   tm_hour, tm_min, tm_sec \n   p   writes localized a.m. or p.m. (locale dependent)   tm_hour \n   z(C99)   writes offset from UTC in the ISO 8601 format (e.g. -0430), or no characters if the time zone information is not available   tm_isdst \n   Z   writes locale-dependent time zone name or abbreviation, or no characters if the time zone information is not available   tm_isdst\nConversion specifier   Explanation   Used fields\n%   writes literal %. The full conversion specification must be %%.\nn(C99)   writes newline character\nt(C99)   writes horizontal tab character\nYear\nY   writes year as a decimal number, e.g. 2017   tm_year\nEY(C99)   writes year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   tm_year\ny   writes last 2 digits of year as a decimal number (range [00,99])   tm_year\nOy(C99)   writes last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 instead of 11 in ja_JP locale   tm_year\nEy(C99)   writes year as offset from locale's alternative calendar period %EC (locale-dependent)   tm_year\nC(C99)   writes first 2 digits of year as a decimal number (range [00,99])   tm_year\nEC(C99)   writes name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year\nG(C99)   writes ISO 8601 week-based year, i.e. the year that contains the specified week. In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday\ng(C99)   writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday\nMonth\nb   writes abbreviated month name, e.g. Oct (locale dependent)   tm_mon\nh(C99)   synonym of b   tm_mon\nB   writes full month name, e.g. October (locale dependent)   tm_mon\nm   writes month as a decimal number (range [01,12])   tm_mon\nOm(C99)   writes month using the alternative numeric system, e.g. \u5341\u4e8c instead of 12 in ja_JP locale   tm_mon\nWeek\nU   writes week of the year as a decimal number (Sunday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday\nOU(C99)   writes week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday\nW   writes week of the year as a decimal number (Monday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday\nOW(C99)   writes week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday\nV(C99)   writes ISO 8601 week of the year (range [01,53]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday\nOV(C99)   writes week of the year, as by %V, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday\nDay of the year/month\nj   writes day of the year as a decimal number (range [001,366])   tm_yday\nd   writes day of the month as a decimal number (range [01,31])   tm_mday\nOd(C99)   writes zero-based day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday\ne(C99)   writes day of the month as a decimal number (range [1,31]). Single digit is preceded by a space.\n  tm_mday\nOe(C99)   writes one-based day of the month using the alternative numeric system, e.g. \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday\nDay of the week\na   writes abbreviated weekday name, e.g. Fri (locale dependent)   tm_wday\nA   writes full weekday name, e.g. Friday (locale dependent)   tm_wday\nw   writes weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday\nOw(C99)   writes weekday, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday\nu(C99)   writes weekday as a decimal number, where Monday is 1 (ISO 8601 format) (range [1-7])   tm_wday\nOu(C99)   writes weekday, where Monday is 1, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday\nHour, minute, second\nH   writes hour as a decimal number, 24 hour clock (range [00-23])   tm_hour\nOH(C99)   writes hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b instead of 18 in ja_JP locale   tm_hour\nI   writes hour as a decimal number, 12 hour clock (range [01,12])   tm_hour\nOI(C99)   writes hour from 12-hour clock using the alternative numeric system, e.g. \u516d instead of 06 in ja_JP locale   tm_hour\nM   writes minute as a decimal number (range [00,59])   tm_min\nOM(C99)   writes minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 instead of 25 in ja_JP locale   tm_min\nS   writes second as a decimal number (range [00,60])   tm_sec\nOS(C99)   writes second using the alternative numeric system, e.g. \u4e8c\u5341\u56db instead of 24 in ja_JP locale   tm_sec\nOther\nc   writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all\nEc(C99)   writes alternative date and time string, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all\nx   writes localized date representation (locale dependent)   all\nEx(C99)   writes alternative date representation, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all\nX   writes localized time representation (locale dependent)   all\nEX(C99)   writes alternative time representation (locale dependent)   all\nD(C99)   equivalent to \"%m/%d/%y\"   tm_mon, tm_mday, tm_year\nF(C99)   equivalent to \"%Y-%m-%d\" (the ISO 8601 date format)   tm_mon, tm_mday, tm_year\nr(C99)   writes localized 12-hour clock time (locale dependent)   tm_hour, tm_min, tm_sec\nR(C99)   equivalent to \"%H:%M\"   tm_hour, tm_min\nT(C99)   equivalent to \"%H:%M:%S\" (the ISO 8601 time format)   tm_hour, tm_min, tm_sec\np   writes localized a.m. or p.m. (locale dependent)   tm_hour\nz(C99)   writes offset from UTC in the ISO 8601 format (e.g. -0430), or no characters if the time zone information is not available   tm_isdst\nZ   writes locale-dependent time zone name or abbreviation, or no characters if the time zone information is not available   tm_isdst\ntime   -   pointer to a struct tm object specifying the time to format\n\n\nReturn value\n   The number of bytes written into the character array pointed to by str not including the terminating '\\0' on success. If count was reached before the entire string could be stored, \u200b0\u200b is returned and the contents are undefined.\n", "url": "https://devdocs.io/c/chrono/strftime\n"}, {"name": "time", "type": "STANDARD LIB", "description": "Defined in header <time.h>\ntime_t time( time_t *arg );\n\n   Returns the current calendar time encoded as a time_t object, and also stores it in the time_t object pointed to by arg (unless arg is a null pointer).\n\nParameters\narg   -   pointer to a time_t object where the time will be stored, or a null pointer\n\n\nReturn value\n   Current calendar time encoded as time_t object on success, (time_t)(-1) on error. If arg is not a null pointer, the return value is also stored in the object pointed to by arg.\n\nNotes\n   The encoding of calendar time in time_t is unspecified, but most systems conform to POSIX specification and return a value of integral type holding the number of seconds since the Epoch. Implementations in which time_t is a 32-bit signed integer (many historical implementations) fail in the year 2038.\n", "url": "https://devdocs.io/c/chrono/time\n"}, {"name": "timespec", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nstruct timespec;\n    (since C11)\n\n   Structure holding an interval broken down into seconds and nanoseconds.\n\nMember objects\ntime_t tv_sec   whole seconds (valid values are >= 0)\nlong tv_nsec   nanoseconds (valid values are [0, 999999999])\n\n", "url": "https://devdocs.io/c/chrono/timespec\n"}, {"name": "timespec_get", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nint timespec_get( struct timespec *ts, int base)\n    (since C11)\n#define TIME_UTC /* implementation-defined */\n    (since C11)\n\n   Other macro constants beginning with TIME_ may be provided by the implementation to indicate additional time bases.\n   If base is TIME_UTC, then.\n\nParameters\nts   -   pointer to an object of type struct timespec\nbase   -   TIME_UTC or another nonzero integer value indicating the time base\n\n\nReturn value\n   The value of base if successful, zero otherwise.\n\nNotes\n   The POSIX function clock_gettime(CLOCK_REALTIME, ts) may also be used to populate a timespec with the time since the Epoch.\n", "url": "https://devdocs.io/c/chrono/timespec_get\n"}, {"name": "time_t", "type": "STANDARD LIB", "description": "Defined in header <time.h>\ntypedef /* unspecified */ time_t;\n\n   Arithmetic (until C11) Real (since C11) type capable of representing times.\n   Although not defined by the C standard, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to  POSIX time.\n\nNotes\n   The standard uses the term calendar time when referring to a value of type time_t.\n", "url": "https://devdocs.io/c/chrono/time_t\n"}, {"name": "tm", "type": "STANDARD LIB", "description": "Defined in header <time.h>\nstruct tm;\n\n   Structure holding a calendar date and time broken down into its components.\n\nMember objects\nint tm_sec   seconds after the minute \u2013 [0, 61](until C99) / [0, 60] (since C99)[note 1]\nint tm_min   minutes after the hour \u2013 [0, 59]\nint tm_hour   hours since midnight \u2013 [0, 23]\nint tm_mday   day of the month \u2013 [1, 31]\nint tm_mon   months since January \u2013 [0, 11]\nint tm_year   years since 1900\nint tm_wday   days since Sunday \u2013 [0, 6]\nint tm_yday   days since January 1 \u2013 [0, 365]\nint tm_isdst   Daylight Saving Time flag. The value is positive if DST is in effect, zero if not and negative if no information is available\n\n", "url": "https://devdocs.io/c/chrono/tm\n"}, {"name": "wcsftime", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nsize_t wcsftime( wchar_t* str, size_t count, const wchar_t* format, tm* time );\n    (since C95)\n\n   Converts the date and time information from a given calendar time time to a null-terminated wide character string str according to format string format. Up to count bytes are written.\n\nParameters\nstr   -   pointer to the first element of the wchar_t array for output\ncount   -   maximum number of wide characters to write\nformat   -   pointer to a null-terminated wide character string specifying the format of conversion. The format string consists of zero or more conversion specifiers and ordinary characters (except %). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with % character, optionally followed by E or O modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:\n   Conversion specifier   Explanation   Used fields \n   %   writes literal %. The full conversion specification must be %%.   \n   n(C99)   writes newline character   \n   t(C99)   writes horizontal tab character   \n   Year \n   Y   writes year as a decimal number, e.g. 2017   tm_year \n   EY(C99)   writes year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   tm_year \n   y   writes last 2 digits of year as a decimal number (range [00,99])   tm_year \n   Oy(C99)   writes last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 instead of 11 in ja_JP locale   tm_year \n   Ey(C99)   writes year as offset from locale's alternative calendar period %EC (locale-dependent)   tm_year \n   C(C99)   writes first 2 digits of year as a decimal number (range [00,99])   tm_year \n   EC(C99)   writes name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year \n   G(C99)   writes ISO 8601 week-based year, i.e. the year that contains the specified week. In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   g(C99)   writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   Month \n   b   writes abbreviated month name, e.g. Oct (locale dependent)   tm_mon \n   h(C99)   synonym of b   tm_mon \n   B   writes full month name, e.g. October (locale dependent)   tm_mon \n   m   writes month as a decimal number (range [01,12])   tm_mon \n   Om(C99)   writes month using the alternative numeric system, e.g. \u5341\u4e8c instead of 12 in ja_JP locale   tm_mon \n   Week \n   U   writes week of the year as a decimal number (Sunday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OU(C99)   writes week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   W   writes week of the year as a decimal number (Monday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday \n   OW(C99)   writes week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   V(C99)   writes ISO 8601 week of the year (range [01,53]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday \n   OV(C99)   writes week of the year, as by %V, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday \n   Day of the year/month \n   j   writes day of the year as a decimal number (range [001,366])   tm_yday \n   d   writes day of the month as a decimal number (range [01,31])   tm_mday \n   Od(C99)   writes zero-based day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   e(C99)   writes day of the month as a decimal number (range [1,31]). Single digit is preceded by a space.\n  tm_mday \n   Oe(C99)   writes one-based day of the month using the alternative numeric system, e.g. \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday \n   Day of the week \n   a   writes abbreviated weekday name, e.g. Fri (locale dependent)   tm_wday \n   A   writes full weekday name, e.g. Friday (locale dependent)   tm_wday \n   w   writes weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday \n   Ow(C99)   writes weekday, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   u(C99)   writes weekday as a decimal number, where Monday is 1 (ISO 8601 format) (range [1-7])   tm_wday \n   Ou(C99)   writes weekday, where Monday is 1, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday \n   Hour, minute, second \n   H   writes hour as a decimal number, 24 hour clock (range [00-23])   tm_hour \n   OH(C99)   writes hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b instead of 18 in ja_JP locale   tm_hour \n   I   writes hour as a decimal number, 12 hour clock (range [01,12])   tm_hour \n   OI(C99)   writes hour from 12-hour clock using the alternative numeric system, e.g. \u516d instead of 06 in ja_JP locale   tm_hour \n   M   writes minute as a decimal number (range [00,59])   tm_min \n   OM(C99)   writes minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 instead of 25 in ja_JP locale   tm_min \n   S   writes second as a decimal number (range [00,60])   tm_sec \n   OS(C99)   writes second using the alternative numeric system, e.g. \u4e8c\u5341\u56db instead of 24 in ja_JP locale   tm_sec \n   Other \n   c   writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all \n   Ec(C99)   writes alternative date and time string, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   x   writes localized date representation (locale dependent)   all \n   Ex(C99)   writes alternative date representation, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all \n   X   writes localized time representation (locale dependent)   all \n   EX(C99)   writes alternative time representation (locale dependent)   all \n   D(C99)   equivalent to \"%m/%d/%y\"   tm_mon, tm_mday, tm_year \n   F(C99)   equivalent to \"%Y-%m-%d\" (the ISO 8601 date format)   tm_mon, tm_mday, tm_year \n   r(C99)   writes localized 12-hour clock time (locale dependent)   tm_hour, tm_min, tm_sec \n   R(C99)   equivalent to \"%H:%M\"   tm_hour, tm_min \n   T(C99)   equivalent to \"%H:%M:%S\" (the ISO 8601 time format)   tm_hour, tm_min, tm_sec \n   p   writes localized a.m. or p.m. (locale dependent)   tm_hour \n   z(C99)   writes offset from UTC in the ISO 8601 format (e.g. -0430), or no characters if the time zone information is not available   tm_isdst \n   Z   writes locale-dependent time zone name or abbreviation, or no characters if the time zone information is not available   tm_isdst\nConversion specifier   Explanation   Used fields\n%   writes literal %. The full conversion specification must be %%.\nn(C99)   writes newline character\nt(C99)   writes horizontal tab character\nYear\nY   writes year as a decimal number, e.g. 2017   tm_year\nEY(C99)   writes year in the alternative representation, e.g.\u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   tm_year\ny   writes last 2 digits of year as a decimal number (range [00,99])   tm_year\nOy(C99)   writes last 2 digits of year using the alternative numeric system, e.g. \u5341\u4e00 instead of 11 in ja_JP locale   tm_year\nEy(C99)   writes year as offset from locale's alternative calendar period %EC (locale-dependent)   tm_year\nC(C99)   writes first 2 digits of year as a decimal number (range [00,99])   tm_year\nEC(C99)   writes name of the base year (period) in the locale's alternative representation, e.g. \u5e73\u6210 (Heisei era) in ja_JP   tm_year\nG(C99)   writes ISO 8601 week-based year, i.e. the year that contains the specified week. In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday\ng(C99)   writes last 2 digits of ISO 8601 week-based year, i.e. the year that contains the specified week (range [00,99]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday\nMonth\nb   writes abbreviated month name, e.g. Oct (locale dependent)   tm_mon\nh(C99)   synonym of b   tm_mon\nB   writes full month name, e.g. October (locale dependent)   tm_mon\nm   writes month as a decimal number (range [01,12])   tm_mon\nOm(C99)   writes month using the alternative numeric system, e.g. \u5341\u4e8c instead of 12 in ja_JP locale   tm_mon\nWeek\nU   writes week of the year as a decimal number (Sunday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday\nOU(C99)   writes week of the year, as by %U, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday\nW   writes week of the year as a decimal number (Monday is the first day of the week) (range [00,53])   tm_year, tm_wday, tm_yday\nOW(C99)   writes week of the year, as by %W, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday\nV(C99)   writes ISO 8601 week of the year (range [01,53]). In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:\n\n Includes January 4 \n Includes first Thursday of the year \n   tm_year, tm_wday, tm_yday\nOV(C99)   writes week of the year, as by %V, using the alternative numeric system, e.g. \u4e94\u5341\u4e8c instead of 52 in ja_JP locale   tm_year, tm_wday, tm_yday\nDay of the year/month\nj   writes day of the year as a decimal number (range [001,366])   tm_yday\nd   writes day of the month as a decimal number (range [01,31])   tm_mday\nOd(C99)   writes zero-based day of the month using the alternative numeric system, e.g \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday\ne(C99)   writes day of the month as a decimal number (range [1,31]). Single digit is preceded by a space.\n  tm_mday\nOe(C99)   writes one-based day of the month using the alternative numeric system, e.g. \u4e8c\u5341\u4e03 instead of 27 in ja_JP locale Single character is preceded by a space.\n  tm_mday\nDay of the week\na   writes abbreviated weekday name, e.g. Fri (locale dependent)   tm_wday\nA   writes full weekday name, e.g. Friday (locale dependent)   tm_wday\nw   writes weekday as a decimal number, where Sunday is 0 (range [0-6])   tm_wday\nOw(C99)   writes weekday, where Sunday is 0, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday\nu(C99)   writes weekday as a decimal number, where Monday is 1 (ISO 8601 format) (range [1-7])   tm_wday\nOu(C99)   writes weekday, where Monday is 1, using the alternative numeric system, e.g. \u4e8c instead of 2 in ja_JP locale   tm_wday\nHour, minute, second\nH   writes hour as a decimal number, 24 hour clock (range [00-23])   tm_hour\nOH(C99)   writes hour from 24-hour clock using the alternative numeric system, e.g. \u5341\u516b instead of 18 in ja_JP locale   tm_hour\nI   writes hour as a decimal number, 12 hour clock (range [01,12])   tm_hour\nOI(C99)   writes hour from 12-hour clock using the alternative numeric system, e.g. \u516d instead of 06 in ja_JP locale   tm_hour\nM   writes minute as a decimal number (range [00,59])   tm_min\nOM(C99)   writes minute using the alternative numeric system, e.g. \u4e8c\u5341\u4e94 instead of 25 in ja_JP locale   tm_min\nS   writes second as a decimal number (range [00,60])   tm_sec\nOS(C99)   writes second using the alternative numeric system, e.g. \u4e8c\u5341\u56db instead of 24 in ja_JP locale   tm_sec\nOther\nc   writes standard date and time string, e.g. Sun Oct 17 04:41:13 2010 (locale dependent)   all\nEc(C99)   writes alternative date and time string, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all\nx   writes localized date representation (locale dependent)   all\nEx(C99)   writes alternative date representation, e.g. using \u5e73\u621023\u5e74 (year Heisei 23) instead of 2011\u5e74 (year 2011) in ja_JP locale   all\nX   writes localized time representation (locale dependent)   all\nEX(C99)   writes alternative time representation (locale dependent)   all\nD(C99)   equivalent to \"%m/%d/%y\"   tm_mon, tm_mday, tm_year\nF(C99)   equivalent to \"%Y-%m-%d\" (the ISO 8601 date format)   tm_mon, tm_mday, tm_year\nr(C99)   writes localized 12-hour clock time (locale dependent)   tm_hour, tm_min, tm_sec\nR(C99)   equivalent to \"%H:%M\"   tm_hour, tm_min\nT(C99)   equivalent to \"%H:%M:%S\" (the ISO 8601 time format)   tm_hour, tm_min, tm_sec\np   writes localized a.m. or p.m. (locale dependent)   tm_hour\nz(C99)   writes offset from UTC in the ISO 8601 format (e.g. -0430), or no characters if the time zone information is not available   tm_isdst\nZ   writes locale-dependent time zone name or abbreviation, or no characters if the time zone information is not available   tm_isdst\n\n\nReturn value\n   number of wide characters written into the wide character array pointed to by str not including the terminating L'\\0' on success. If count was reached before the entire string could be stored, \u200b0\u200b is returned and the contents are undefined.\n", "url": "https://devdocs.io/c/chrono/wcsftime\n"}, {"name": "aligned_alloc", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid *aligned_alloc( size_t alignment, size_t size );\n    (since C11)\n\n   Allocate size bytes of uninitialized storage whose alignment is specified by alignment. The size parameter must be an integral multiple of alignment.\n   aligned_alloc is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.\n   A previous call to free or realloc that deallocates a region of memory synchronizes-with a call to aligned_alloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by aligned_alloc. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n\nParameters\nalignment   -   specifies the alignment. Must be a valid alignment supported by the implementation.\nsize   -   number of bytes to allocate. An integral multiple of alignment\n\n\nReturn value\n   On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with free() or realloc().\n   On failure, returns a null pointer.\n\nNotes\n   Passing a size which is not an integral multiple of alignment or a alignment which is not valid or not supported by the implementation causes the function to fail and return a null pointer (C11, as published, specified undefined behavior in this case, this was corrected by DR 460). Removal of size restrictions to make it possible to allocate small objects at restrictive alignment boundaries (similar to alignas) has been proposed by n2072.\n   As an example of the \"supported by the implementation\" requirement, POSIX function posix_memalign accepts any alignment that is a power of two and a multiple of sizeof(void *), and POSIX-based implementations of aligned_alloc inherit this requirements.\n   Regular malloc aligns memory suitable for any object type (which, in practice, means that it is aligned to alignof(max_align_t)). This function is useful for over-aligned allocations, such as to SSE, cache line, or VM page boundary.\n", "url": "https://devdocs.io/c/memory/aligned_alloc\n"}, {"name": "C memory management library", "type": "STANDARD LIB", "description": "\nFunctions\nDefined in header <stdlib.h>\nmalloc   allocates memory  (function)\ncalloc   allocates and zeroes memory  (function)\nrealloc   expands previously allocated memory block  (function)\nfree   deallocates previously allocated memory  (function)\naligned_alloc\n(C11)   allocates aligned memory  (function)\n\n\nSee also\n", "url": "https://devdocs.io/c/memory\n"}, {"name": "calloc", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid* calloc( size_t num, size_t size );\n\n   Allocates memory for an array of num objects of size size and initializes all bytes in the allocated storage to zero.\n   If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.\n   If size is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).\ncalloc is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.\nA previous call to free or realloc that deallocates a region of memory synchronizes-with a call to calloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by calloc. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n (since C11)\n\n\nParameters\nnum   -   number of objects\nsize   -   size of each object\n\n\nReturn value\n   On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with free() or realloc().\n   On failure, returns a null pointer.\n\nNotes\n   Due to the alignment requirements, the number of allocated bytes is not necessarily equal to num*size.\n   Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).\n   Originally (in C89), support for zero size was added to accommodate code such as.\n", "url": "https://devdocs.io/c/memory/calloc\n"}, {"name": "free", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid free( void* ptr );\n\n   Deallocates the space previously allocated by malloc(), calloc(), aligned_alloc, (since C11) or realloc().\n   If ptr is a null pointer, the function does nothing.\n   The behavior is undefined if the value of ptr does not equal a value returned earlier by malloc(), calloc(), realloc(), or aligned_alloc() (since C11).\n   The behavior is undefined if the memory area referred to by ptr has already been deallocated, that is, free() or realloc() has already been called with ptr as the argument and no calls to malloc(), calloc() or realloc() resulted in a pointer equal to ptr afterwards.\n   The behavior is undefined if after free() returns, an access is made through the pointer ptr (unless another allocation function happened to result in a pointer value equal to ptr).\nfree is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.\nA call to free that deallocates a region of memory synchronizes-with a call to any subsequent allocation function that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by the allocation function. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n (since C11)\n\n\nParameters\nptr   -   pointer to the memory to deallocate\n\n\nReturn value\n   (none).\n\nNotes\n   The function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to free().\n", "url": "https://devdocs.io/c/memory/free\n"}, {"name": "malloc", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid* malloc( size_t size );\n\n   Allocates size bytes of uninitialized storage.\n   If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type with fundamental alignment.\n   If size is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to free).\nmalloc is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.\nA previous call to free or realloc that deallocates a region of memory synchronizes-with a call to malloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by malloc. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n (since C11)\n\n\nParameters\nsize   -   number of bytes to allocate\n\n\nReturn value\n   On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with free() or realloc().\n   On failure, returns a null pointer.\n", "url": "https://devdocs.io/c/memory/malloc\n"}, {"name": "realloc", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid *realloc( void *ptr, size_t new_size );\n\n   Reallocates the given area of memory. It must be previously allocated by malloc(), calloc() or realloc() and not yet freed with a call to free or realloc. Otherwise, the results are undefined.\n   The reallocation is done by either:\n   If there is not enough memory, the old memory block is not freed and null pointer is returned.\n   If ptr is NULL, the behavior is the same as calling malloc(new_size).\n   If new_size is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage).\nrealloc is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.\nA previous call to free or realloc that deallocates a region of memory synchronizes-with a call to any allocation function, including realloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by realloc. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n (since C11)\n\n\nParameters\nptr   -   pointer to the memory area to be reallocated\nnew_size   -   new size of the array in bytes\n\n\nReturn value\n   On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with free() or realloc(). The original pointer ptr is invalidated and any access to it is undefined behavior (even if reallocation was in-place).\n   On failure, returns a null pointer. The original pointer ptr remains valid and may need to be deallocated with free() or realloc().\n\nNotes\n   Support for zero size is deprecated as of C11 DR 400.\n   Originally (in C89), support for zero size was added to accommodate code such as.\n", "url": "https://devdocs.io/c/memory/realloc\n"}, {"name": "abort_handler_s", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid abort_handler_s( const char * restrict msg,\n                      void * restrict ptr,\n                      errno_t error\n                    );\n    (since C11)\n\n   Writes an implementation-defined message to stderr which must include the string pointed to by msg and calls abort().\n   A pointer to this function can be passed to set_constraint_handler_s to establish a runtime constraints violation handler.  As with all bounds-checked functions, abort_handler_s is only guaranteed to be available if __STDC_LIB_EXT1__ is defined by the implementation and if the user defines __STDC_WANT_LIB_EXT1__ to the integer constant 1 before including <stdlib.h>.\n\nParameters\nmsg   -   pointer to the message written to the standard error stream\nptr   -   pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected\nerror   -   a positive value of type errno_t\n\n\nReturn value\n   none; this function does not return to its caller.\n\nNotes\n   If set_constraint_handler_s is never called, the default handler is implementation-defined: it may be abort_handler_s, ignore_handler_s, or some other implementation-defined handler.\n", "url": "https://devdocs.io/c/error/abort_handler_s\n"}, {"name": "assert", "type": "STANDARD LIB", "description": "Defined in header <assert.h>\n#ifdef NDEBUG\n#define assert(condition) ((void)0)\n#else\n#define assert(condition) /*implementation defined*/\n#endif\n\n   The definition of the macro assert depends on another macro, NDEBUG, which is not defined by the standard library.\n   If NDEBUG is defined as a macro name at the point in the source code where <assert.h> is included, then assert does nothing.\n   If NDEBUG is not defined, then assert checks if its argument (which must have scalar type) compares equal to zero. If it does, assert outputs implementation-specific diagnostic information on the standard error output and calls abort(). The diagnostic information is required to include the text of expression, as well as the values of the standard macros __FILE__, __LINE__, and the predefined variable __func__. (since C99).\n\nParameters\ncondition   -   expression of scalar type\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/error/assert\n"}, {"name": "set_constraint_handler_s, constraint_handler_t", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nconstraint_handler_t set_constraint_handler_s( constraint_handler_t handler );\n    (since C11)\n\n   Configures the handler to be called by all bounds-checked functions on a runtime constraint violation or restores the default handler (if handler is a null pointer).\n   The handler must be a pointer to function of type constraint_handler_t, which is defined as.\nDefined in header <stdlib.h>\ntypedef void (*constraint_handler_t)( const char *restrict msg,\n                                      void *restrict ptr,\n                                      errno_t error);\n    (since C11)\n\n   On a runtime constraint violation, it is called with the following arguments:\n   If set_constraint_handler_s is never called, the default handler is implementation-defined: it may be abort_handler_s, ignore_handler_s, or some other implementation-defined handler.  As with all bounds-checked functions, set_constraint_handler_s and constraint_handler_t are only guaranteed to be available if __STDC_LIB_EXT1__ is defined by the implementation and if the user defines __STDC_WANT_LIB_EXT1__ to the integer constant 1 before including <stdlib.h>.\n\nParameters\nhandler   -   pointer to function of type constraint_handler_t or a null pointer\n\n\nReturn value\n   A pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling set_constraint_handler_s(NULL) sets up the system default handler).\n", "url": "https://devdocs.io/c/error/set_constraint_handler_s\n"}, {"name": "errno", "type": "STANDARD LIB", "description": "Defined in header <errno.h>\n#define errno /*implementation-defined*/\n\n   errno is a preprocessor macro that expands to a thread-local (since C11) modifiable lvalue of type int. Several standard library functions indicate errors by writing positive integers to errno. Typically, the value of errno is set to one of the error codes listed in <errno.h> as macro constants beginning with the letter E followed by uppercase letters or digits.\n   The value of errno is \u200b0\u200b at program startup, and although library functions are allowed to write positive integers to errno whether or not an error occurred, library functions never store \u200b0\u200b in errno.\n   Library functions perror and strerror can be used to obtain textual descriptions of the error conditions that correspond to the current errno value.\n", "url": "https://devdocs.io/c/error/errno\n"}, {"name": "Error handling", "type": "STANDARD LIB", "description": "\nError numbers\nDefined in header <errno.h>\nerrno   macro which expands to POSIX-compatible thread-local error number variable(macro variable)\nE2BIG, EACCES, ..., EXDEV   macros for standard POSIX-compatible error conditions  (macro constant)\n\n\nAssertions\nDefined in header <assert.h>\nassert   aborts the program if the user-specified condition is not true. May be disabled for release builds  (function macro)\nstatic_assert\n(C11)   issues a compile-time diagnostic if the value of a constant expression is false  (keyword macro)\n\nBounds checking The standard library provides bounds-checked versions of some existing functions (gets_s, fopen_s, printf_s, strcpy_s, wcscpy_s, mbstowcs_s, qsort_s, getenv_s, etc). This functionality is optional and is only available if __STDC_LIB_EXT1__ is defined. The following macros and functions support this functionality.\n   Defined in header <errno.h> \n   Defined in header <stdio.h> \n   errno_t\n(C11)   a typedef for the type int, used to self-document functions that return errno values  (typedef) \n   Defined in header <stddef.h> \n   rsize_t\n(C11)   a typedef for the same type as size_t, used to self-document functions that range-check their parameters at runtime  (typedef) \n   Defined in header <stdint.h> \n   RSIZE_MAX\n(C11)   largest acceptable size for bounds-checked functions, expands to either constant or variable which may change at runtime (e.g. as the currently allocated memory size changes)(macro variable) \n   Defined in header <stdlib.h> \n    set_constraint_handler_s\n(C11)   set the error callback for bounds-checked functions  (function) \n    abort_handler_s\n(C11)   abort callback for the bounds-checked functions  (function) \n    ignore_handler_s\n(C11)   ignore callback for the bounds-checked functions  (function) \n  Note: implementations of bounds-checked functions are available as open-source libraries Safe C and Slibc, and as part of Watcom C. There is also an incompatible set of bounds-checked functions available in Visual Studio.\n (since C11)\nDefined in header <errno.h>\nDefined in header <stdio.h>\nerrno_t\n(C11)   a typedef for the type int, used to self-document functions that return errno values  (typedef)\nDefined in header <stddef.h>\nrsize_t\n(C11)   a typedef for the same type as size_t, used to self-document functions that range-check their parameters at runtime  (typedef)\nDefined in header <stdint.h>\nRSIZE_MAX\n(C11)   largest acceptable size for bounds-checked functions, expands to either constant or variable which may change at runtime (e.g. as the currently allocated memory size changes)(macro variable)\nDefined in header <stdlib.h>\nset_constraint_handler_s\n(C11)   set the error callback for bounds-checked functions  (function)\nabort_handler_s\n(C11)   abort callback for the bounds-checked functions  (function)\nignore_handler_s\n(C11)   ignore callback for the bounds-checked functions  (function)\n\n", "url": "https://devdocs.io/c/error\n"}, {"name": "Error numbers", "type": "STANDARD LIB", "description": "   Each of the macros defined in <errno.h> expands to an integer constant expression with type int and with a unique positive value. The following constants are defined by ISO C. The implementation may define more, as long as they begin with 'E' followed by digits or uppercase letters.\nDefined in header <errno.h>\nEDOM   Mathematics argument out of domain of function  (macro constant)\nEILSEQ\n(C95)   Illegal byte sequence  (macro constant)\nERANGE   Result too large  (macro constant)\n\n\nNotes\n   Many additional errno constants are defined by POSIX and by the C++ standard library, and individual implementations may define even more, e.g. errno(3) on Linux or intro(2) on BSD and OS X.\n", "url": "https://devdocs.io/c/error/errno_macros\n"}, {"name": "ignore_handler_s", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid ignore_handler_s( const char * restrict msg,\n                       void * restrict ptr,\n                       errno_t error\n                     );\n    (since C11)\n\n   The function simply returns to the caller without performing any other action.\n   A pointer to this function can be passed to set_constraint_handler_s to establish a runtime constraints violation handler that does nothing.  As with all bounds-checked functions, ignore_handler_s is only guaranteed to be available if __STDC_LIB_EXT1__ is defined by the implementation and if the user defines __STDC_WANT_LIB_EXT1__ to the integer constant 1 before including <stdlib.h>.\n\nParameters\nmsg   -   pointer to character string that describes the error\nptr   -   pointer to an implementation-defined object or a null pointer. Examples of implementation-defined objects are objects that give the name of the function that detected the violation and the line number when the violation was detected\nerror   -   the error about to be returned by the calling function, if it happens to be one of the functions that return errno_t\n\n\nReturn value\n   (none).\n\nNotes\n   If ignore_handler_s is used as a the runtime constraints handler, the violations may be detected by examining the results of the bounds-checked function calls, which may be different for different functions (non-zero errno_t, null character written to the first byte of the output string, etc).\n   If set_constraint_handler_s is never called, the default handler is implementation-defined: it may be abort_handler_s, ignore_handler_s, or some other implementation-defined handler.\n", "url": "https://devdocs.io/c/error/ignore_handler_s\n"}, {"name": "static_assert", "type": "STANDARD LIB", "description": "Defined in header <assert.h>\n#define static_assert _Static_assert\n\n   This convenience macro expands to the keyword _Static_assert.\n", "url": "https://devdocs.io/c/error/static_assert\n"}, {"name": "clearerr", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nvoid clearerr( FILE *stream );\n\n   Resets the error flags and the EOF indicator for the given file stream.\n\nParameters\nstream   -   the file to reset the error flags for\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/io/clearerr\n"}, {"name": "fclose", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint fclose( FILE *stream );\n\n   Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.\n   Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by setbuf or setvbuf, if any, is also disassociated and deallocated if automatic allocation was used.\n   The behavior is undefined if the value of the pointer stream is used after fclose returns.\n\nParameters\nstream   -   the file stream to close\n\n\nReturn value\n   \u200b0\u200b on success, EOF otherwise.\n", "url": "https://devdocs.io/c/io/fclose\n"}, {"name": "feof", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint feof( FILE *stream );\n\n   Checks if the end of the given file stream has been reached.\n\nParameters\nstream   -   the file stream to check\n\n\nReturn value\n   nonzero value if the end of the stream has been reached, otherwise \u200b0\u200b\n\nNotes\n   This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a fgetc, which returned the last byte of a file, feof returns zero. The next fgetc fails and changes the stream state to end-of-file. Only then feof returns non-zero.\n   In typical usage, input stream processing stops on any error; feof and ferror are then used to distinguish between different error conditions.\n", "url": "https://devdocs.io/c/io/feof\n"}, {"name": "ferror", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint ferror( FILE *stream );\n\n   Checks the given stream for errors.\n\nParameters\nstream   -   the file stream to check\n\n\nReturn value\n   Nonzero value if the file stream has errors occurred, \u200b0\u200b otherwise.\n", "url": "https://devdocs.io/c/io/ferror\n"}, {"name": "fflush", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint fflush( FILE *stream );\n\n   For output streams (and for update streams on which the last operation was output), writes any unwritten data from the stream's buffer to the associated output device.\n   For input streams (and for update streams on which the last operation was input), the behavior is undefined.\n   If stream is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.\n\nParameters\nstream   -   the file stream to write out\n\n\nReturn value\n   Returns zero on success. Otherwise EOF is returned and the error indicator of the file stream is set.\n\nNotes\n   POSIX extends the specification of fflush by defining its effects on an input stream, as long as that stream represents a file or another seekable device: in that case the POSIX file pointer is repositioned to match the C stream pointer (which effectively undoes any read buffering) and the effects of any ungetc or ungetwc that weren't yet read back from the stream are discarded.\n   Microsoft also extends the specification of fflush by defining its effects on an input stream: in Visual Studio 2013 and prior, it discarded the input buffer, in Visual Studio 2015 and newer, it has no effect, buffers are retained.\n", "url": "https://devdocs.io/c/io/fflush\n"}, {"name": "fgetc, getc", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint fgetc( FILE *stream );\nint getc( FILE *stream );\n\n   Reads the next character from the given input stream. getc() may be implemented as a macro.\n\nParameters\nstream   -   to read the character from\n\n\nReturn value\n   The obtained character on success or EOF on failure.\n   If the failure has been caused by end-of-file condition, additionally sets the eof indicator (see feof()) on stream. If the failure has been caused by some other error, sets the error indicator (see ferror()) on stream.\n", "url": "https://devdocs.io/c/io/fgetc\n"}, {"name": "fgetpos", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint fgetpos( FILE          *stream, fpos_t          *pos );\n    (until C99)\nint fgetpos( FILE *restrict stream, fpos_t *restrict pos );\n    (since C99)\n\n   Obtains the file position indicator and the current parse state (if any) for the file stream stream and stores them in the object pointed to by pos. The value stored is only meaningful as the input to fsetpos.\n\nParameters\nstream   -   file stream to examine\npos   -   pointer to a fpos_t object to store the file position indicator to\n\n\nReturn value\n   \u200b0\u200b upon success, nonzero value otherwise.\n", "url": "https://devdocs.io/c/io/fgetpos\n"}, {"name": "fgets", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nchar *fgets( char          *str, int count, FILE          *stream );\n    (until C99)\nchar *fgets( char *restrict str, int count, FILE *restrict stream );\n    (since C99)\n\n   Reads at most count - 1 characters from the given file stream and stores them in the character array pointed to by str. Parsing stops if end-of-file occurs or a newline character is found, in which case str will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to str.\n   The behavior is undefined if count is less than 1.\n\nParameters\nstr   -   pointer to an element of a char array\ncount   -   maximum number of characters to write (typically the length of str)\nstream   -   file stream to read the data from\n\n\nReturn value\n   str on success, null pointer on failure.\n   If the failure has been caused by end-of-file condition, additionally sets the eof indicator (see feof()) on stream. The contents of the array pointed to by str are not altered in this case.\n   If the failure has been caused by some other error, sets the error indicator (see ferror()) on stream. The contents of the array pointed to by str are indeterminate (it may not even be null-terminated).\n\nNotes\n   POSIX additionally requires that fgets sets errno if it encounters an failure other than the end-of-file condition.\n   Although the standard specification is ambiguous in the case where count==1, common implementations read no characters, store zero in str[0], and report success (return str).\n", "url": "https://devdocs.io/c/io/fgets\n"}, {"name": "fgetwc", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwint_t fgetwc( FILE *stream );\n    (since C95)\nwint_t getwc( FILE *stream );\n    (since C95)\n\n   Reads the next wide character from the given input stream. getwc() may be implemented as a macro and may evaluate stream more than once.\n\nParameters\nstream   -   to read the wide character from\n\n\nReturn value\n   The next wide character from the stream or WEOF on failure.\n   If the failure has been caused by end-of-file condition, additionally sets the eof indicator (see feof()) on stream. If the failure has been caused by some other error, sets the error indicator (see ferror()) on stream.\n   If an encoding error occurred, additionally sets errno to EILSEQ.\n", "url": "https://devdocs.io/c/io/fgetwc\n"}, {"name": "fgetws", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwchar_t *fgetws( wchar_t *str, int count, FILE *stream );\n    (since C95) (until C99)\nwchar_t *fgetws( wchar_t * restrict str, int count, FILE * restrict stream );\n    (since C99)\n\n   Reads at most count - 1 wide characters from the given file stream and stores them in str. The produced wide string is always null-terminated. Parsing stops if end-of-file occurs or a newline wide character is found, in which case str will contain that wide newline character.\n\nParameters\nstr   -   wide string to read the characters to\ncount   -   the length of str\nstream   -   file stream to read the data from\n\n\nReturn value\n   str on success, NULL on an error.\n", "url": "https://devdocs.io/c/io/fgetws\n"}, {"name": "File input/output", "type": "STANDARD LIB", "description": "   The <stdio.h> header provides generic file operation support and supplies functions with narrow character input/output capabilities.\n   The <wchar.h> header supplies functions with wide character input/output capabilities.\n   I/O streams are objects of type FILE that can only be accessed and manipulated through pointers of type FILE* (Note: while it may be possible to create a local object of type FILE by dereferencing and copying a valid FILE*, using the address of such copy in the I/O functions is undefined behavior). Each stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).\n   I/O streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. All streams access the same locale object: the one most recently installed with setlocale.\n   Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each stream object holds the following:\n   A newly opened stream has no orientation. The first call to fwide or to any I/O function establishes the orientation: a wide I/O function makes the stream wide-oriented, a narrow I/O function makes the stream narrow-oriented. Once set, the orientation can only be changed with freopen. Narrow I/O functions cannot be called on a wide-oriented stream; wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling mbrtowc and wcrtomb. Unlike the multibyte character strings that are valid in a program, multibyte character sequences in the file may contain embedded nulls and do not have to begin or end in the initial shift state.\n   POSIX requires that the LC_CTYPE facet of the currently installed C locale is stored within the stream object the moment its orientation becomes wide, and is used for all future I/O on this stream until the orientation is changed, regardless of any subsequent calls to setlocale.\n   A text stream is an ordered sequence of characters composed into lines (zero or more characters plus a terminating '\\n'). Whether the last line requires a terminating '\\n' is implementation-defined. Characters may have to be added, altered, or deleted on input and output to conform to the conventions for representing text in the OS (in particular, C streams on Windows OS convert \\n to \\r\\n on output, and convert \\r\\n to \\n on input).\n   Data read in from a text stream is guaranteed to compare equal to the data that were earlier written out to that stream only if all of the following is true:\n   A binary stream is an ordered sequence of characters that can transparently record internal data. Data read in from a binary stream always equals to the data that were earlier written out to that stream. Implementations are only allowed to append a number of null characters to the end of the stream. A wide binary stream doesn't need to end in the initial shift state.\n   POSIX implementations do not distinguish between text and binary streams (there is no special mapping for \\n or any other characters).\n\nFunctions\nFile access\nDefined in header <stdio.h>\nfopenfopen_s\n(C11)   opens a file  (function)\nfreopenfreopen_s\n(C11)   open an existing stream with a different name  (function)\nfclose   closes a file  (function)\nfflush   synchronizes an output stream with the actual file  (function)\nsetbuf   sets the buffer for a file stream  (function)\nsetvbuf   sets the buffer and its size for a file stream  (function)\nDefined in header <wchar.h>\nfwide\n(C95)   switches a file stream between wide character I/O and narrow character I/O  (function)\nDirect input/output\nDefined in header <stdio.h>\nfread   reads from a file  (function)\nfwrite   writes to a file  (function)\nUnformatted input/output\nNarrow character\nDefined in header <stdio.h>\nfgetcgetc   gets a character from a file stream  (function)\nfgets   gets a character string from a file stream  (function)\nfputcputc   writes a character to a file stream  (function)\nfputs   writes a character string to a file stream  (function)\ngetchar   reads a character from stdin  (function)\ngetsgets_s\n(removed in C11)(since C11)   reads a character string from stdin  (function)\nputchar   writes a character to stdout  (function)\nputs   writes a character string to stdout  (function)\nungetc   puts a character back into a file stream  (function)\nWide character\nDefined in header <wchar.h>\nfgetwcgetwc\n(C95)   gets a wide character from a file stream  (function)\nfgetws\n(C95)   gets a wide string from a file stream  (function)\nfputwcputwc\n(C95)   writes a wide character to a file stream  (function)\nfputws\n(C95)   writes a wide string to a file stream  (function)\ngetwchar\n(C95)   reads a wide character from stdin  (function)\nputwchar\n(C95)   writes a wide character to stdout  (function)\nungetwc\n(C95)   puts a wide character back into a file stream  (function)\nFormatted input/output\nNarrow character\nDefined in header <stdio.h>\nscanffscanfsscanfscanf_sfscanf_ssscanf_s\n(C11)(C11)(C11)   reads formatted input from stdin, a file stream or a buffer  (function)\nvscanfvfscanfvsscanfvscanf_svfscanf_svsscanf_s\n(C99)(C99)(C99)(C11)(C11)(C11)   reads formatted input from stdin, a file stream or a buffer using variable argument list  (function)\nprintffprintfsprintfsnprintfprintf_sfprintf_ssprintf_ssnprintf_s\n(C99)(C11)(C11)(C11)(C11)   prints formatted output to stdout, a file stream or a buffer  (function)\nvprintfvfprintfvsprintfvsnprintfvprintf_svfprintf_svsprintf_svsnprintf_s\n(C99)(C11)(C11)(C11)(C11)   prints formatted output to stdout, a file stream or a buffer using variable argument list  (function)\nWide character\nDefined in header <wchar.h>\nwscanffwscanfswscanfwscanf_sfwscanf_sswscanf_s\n(C95)(C95)(C95)(C11)(C11)(C11)   reads formatted wide character input from stdin, a file stream or a buffer  (function)\nvwscanfvfwscanfvswscanfvwscanf_svfwscanf_svswscanf_s\n(C99)(C99)(C99)(C11)(C11)(C11)   reads formatted wide character input from stdin, a file stream or a buffer using variable argument list  (function)\nwprintffwprintfswprintfwprintf_sfwprintf_sswprintf_ssnwprintf_s\n(C95)(C95)(C95)(C11)(C11)(C11)(C11)   prints formatted wide character output to stdout, a file stream or a buffer  (function)\nvwprintfvfwprintfvswprintfvwprintf_svfwprintf_svswprintf_svsnwprintf_s\n(C95)(C95)(C95)(C11)(C11)(C11)(C11)   prints formatted wide character output to stdout, a file stream or a buffer using variable argument list  (function)\nFile positioning\nDefined in header <stdio.h>\nftell   returns the current file position indicator  (function)\nfgetpos   gets the file position indicator  (function)\nfseek   moves the file position indicator to a specific location in a file  (function)\nfsetpos   moves the file position indicator to a specific location in a file  (function)\nrewind   moves the file position indicator to the beginning in a file  (function)\nError handling\nDefined in header <stdio.h>\nclearerr   clears errors  (function)\nfeof   checks for the end-of-file  (function)\nferror   checks for a file error  (function)\nperror   displays a character string corresponding of the current error to stderr  (function)\nOperations on files\nDefined in header <stdio.h>\nremove   erases a file  (function)\nrename   renames a file  (function)\ntmpfiletmpfile_s\n(C11)   returns a pointer to a temporary file  (function)\ntmpnamtmpnam_s\n(C11)   returns a unique filename  (function)\n\n\nTypes\nDefined in header <stdio.h>\nType   Definition\nFILE   type, capable of holding all information needed to control a C I/O stream\nfpos_t   type, capable of uniquely specifying a position and mutibyte parser state in a file\n\n\nMacros\nDefined in header <stdio.h>\nstdinstdoutstderr   expression of type FILE* associated with the input streamexpression of type FILE* associated with the output streamexpression of type FILE* associated with the error output stream  (macro constant)\nEOF   integer constant expression of type int and negative value  (macro constant)\nFOPEN_MAX   maximum number of files that can be open simultaneously  (macro constant)\nFILENAME_MAX   size needed for an array of char to hold the longest supported file name  (macro constant)\nBUFSIZ   size of the buffer used by setbuf()  (macro constant)\n_IOFBF_IOLBF_IONBF   argument to setvbuf() indicating fully buffered I/Oargument to setvbuf() indicating line buffered I/Oargument to setvbuf() indicating unbuffered I/O  (macro constant)\nSEEK_SETSEEK_CURSEEK_END   argument to fseek() indicating seeking from beginning of the fileargument to fseek() indicating seeking from the current file positionargument to fseek() indicating seeking from end of the file  (macro constant)\nTMP_MAXTMP_MAX_S\n(C11)   maximum number of unique filenames that can be generated by tmpnammaximum number of unique filenames that can be generated by tmpnam_s  (macro constant)\nL_tmpnamL_tmpnam_s\n(C11)   size needed for an array of char to hold the result of tmpnamsize needed for an array of char to hold the result of tmpnam_s  (macro constant)\n\n", "url": "https://devdocs.io/c/io\n"}, {"name": "fopen, fopen_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\n(1)\nFILE *fopen( const char *filename, const char *mode );\n  (until C99)\nFILE *fopen( const char *restrict filename, const char *restrict mode );\n  (since C99)\nerrno_t fopen_s(FILE *restrict *restrict streamptr,\n                const char *restrict filename,\n                const char *restrict mode);\n  (2)   (since C11)\n\n\nParameters\nfilename   -   file name to associate the file stream to\nmode   -   null-terminated character string determining file access mode    File access mode string   Meaning   Explanation   Action if file  already exists   Action if file  does not exist \n   \"r\"   read   Open a file for reading   read from start   failure to open \n   \"w\"   write   Create a file for writing   destroy contents   create new \n   \"a\"   append   Append to a file   write to end   create new \n   \"r+\"   read extended   Open a file for read/write   read from start   error \n   \"w+\"   write extended   Create a file for read/write   destroy contents   create new \n   \"a+\"   append extended   Open a file for read/write   write to end   create new \n   File access mode flag \"b\" can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows it disables special handling of '\\n' and '\\x1A'.  On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator. \n   The behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. Windows). \n   In update mode ('+'), both input and output may be performed, but output cannot be followed by input without an intervening call to fflush, fseek, fsetpos or rewind, and input cannot be followed by output without an intervening call to fseek, fsetpos or rewind, unless the input operation encountered end of file. In update mode, implementations are permitted to use binary mode even when text mode is specified. \n   File access mode flag \"x\" can optionally be appended to \"w\" or \"w+\" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11) \n   When using fopen_s or freopen_s, file access permissions for any file created with \"w\" or \"a\" prevents other users from accessing it. File access mode flag \"u\" can optionally be prepended to any specifier that begins with \"w\" or \"a\", to enable the default fopen permissions. (C11)\nFile access mode string   Meaning   Explanation   Action if file  already exists   Action if file  does not exist\n\"r\"   read   Open a file for reading   read from start   failure to open\n\"w\"   write   Create a file for writing   destroy contents   create new\n\"a\"   append   Append to a file   write to end   create new\n\"r+\"   read extended   Open a file for read/write   read from start   error\n\"w+\"   write extended   Create a file for read/write   destroy contents   create new\n\"a+\"   append extended   Open a file for read/write   write to end   create new\nFile access mode flag \"b\" can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows it disables special handling of '\\n' and '\\x1A'.  On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.\nThe behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. Windows).\nIn update mode ('+'), both input and output may be performed, but output cannot be followed by input without an intervening call to fflush, fseek, fsetpos or rewind, and input cannot be followed by output without an intervening call to fseek, fsetpos or rewind, unless the input operation encountered end of file. In update mode, implementations are permitted to use binary mode even when text mode is specified.\nFile access mode flag \"x\" can optionally be appended to \"w\" or \"w+\" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11)\nWhen using fopen_s or freopen_s, file access permissions for any file created with \"w\" or \"a\" prevents other users from accessing it. File access mode flag \"u\" can optionally be prepended to any specifier that begins with \"w\" or \"a\", to enable the default fopen permissions. (C11)\nstreamptr   -   pointer to a pointer where the function stores the result (an out-parameter)\n\n\nReturn value\n\nNotes\n   The format of filename is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible though filesystem API). On platforms that support them, filename may include absolute or relative filesystem path.\n", "url": "https://devdocs.io/c/io/fopen\n"}, {"name": "printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\n(1)\n\u200bint printf( const char *format, ... );\u200b\n  (until C99)\n\u200bint printf( const char *restrict format, ... );\u200b\n  (since C99)\n(2)\nint fprintf( FILE *stream, const char *format, ... );\n  (until C99)\nint fprintf( FILE *restrict stream, const char *restrict format, ... );\n  (since C99)\n(3)\nint sprintf( char *buffer, const char *format, ... );\n  (until C99)\nint sprintf( char *restrict buffer, const char *restrict format, ... );\n  (since C99)\nint snprintf( char *restrict buffer, size_t bufsz, \n              const char *restrict format, ... );\n  (4)   (since C99)\nint printf_s(const char *restrict format, ...);\n  (5)   (since C11)\nint fprintf_s(FILE *restrict stream, const char *restrict format, ...);\n  (6)   (since C11)\nint sprintf_s(char *restrict buffer, rsize_t bufsz,\n              const char *restrict format, ...);\n  (7)   (since C11)\nint snprintf_s(char *restrict buffer, rsize_t bufsz,\n               const char *restrict format, ...);\n  (8)   (since C11)\n\n   Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.\n\nParameters\nstream   -   output file stream to write to\nbuffer   -   pointer to a character string to write to\nbufsz   -   up to bufsz - 1 characters may be written, plus the null terminator\nformat   -   pointer to a null-terminated multibyte string specifying how to interpret the data. The format string consists of ordinary multibyte characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n introductory % character \n (optional) one or more flags that modify the behavior of the conversion: \n\n -: the result of the conversion is left-justified within the field (by default it is right-justified) \n +: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) \n space: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if + flag is present. \n # : alternative form of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. \n 0 : for integer and floating point number conversions, leading zeros are used to pad the field instead of space characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if - flag is present. \n\n (optional) integer value or * that specifies minimum field width. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when * is used, the width is specified by an additional argument of type int. If the value of the argument is negative, it results with the - flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) \n\n (optional) . followed by integer number or *, or neither that specifies precision of the conversion. In the case when * is used, the precision is specified by an additional argument of type int. If the value of this argument is negative, it is ignored. If neither a number nor * is used, the precision is taken as zero. See the table below for exact effects of precision. \n (optional) length modifier that specifies the size of the argument \n conversion format specifier \n\n The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L \n   %   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    writes a single character.  The argument is first converted to unsigned char. If the l modifier is used, the argument is first converted to a character string as if by %ls with a wchar_t[2] argument.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A \n   s    writes a character string The argument must be a pointer to the initial element of an array of characters. Precision specifies the maximum number of bytes to be written. If Precision is not specified, writes every byte up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t, which is converted to char array as if by a call to wcrtomb with zero-initialized conversion state.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   d i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A \n   o   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A \n   x X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A \n   u   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A \n   f F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C99)\n   N/A   N/A   N/A   N/A   long double \n   e E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   a A (C99).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   g G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   n   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A \n   p   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A \n\n The floating point conversion functions convert infinity to inf or infinity. Which one is used is implementation defined.\nNot-a-number is converted to nan or nan(char_sequence). Which one is used is implementation defined.\nThe conversions F, E, G, A output INF, INFINITY, NAN instead.\nEven though %c expects int argument, it is safe to pass a char because of the integer promotion that takes place when a variadic function is called.\nThe correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <inttypes.h> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).\nThe memory-writing conversion specifier %n is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked printf_s family of functions.\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple %n results in the same variable or, as an edge case, printing a string modified by an earlier %n within the same call.\nIf a conversion specification is invalid, the behavior is undefined.\nConversion specifier   Explanation   Argument type\nlength modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L\n%   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A\nc    writes a single character.  The argument is first converted to unsigned char. If the l modifier is used, the argument is first converted to a character string as if by %ls with a wchar_t[2] argument.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A\ns    writes a character string The argument must be a pointer to the initial element of an array of characters. Precision specifies the maximum number of bytes to be written. If Precision is not specified, writes every byte up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t, which is converted to char array as if by a call to wcrtomb with zero-initialized conversion state.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A\nd i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A\no   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A\nx X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A\nu   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A\nf F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C99)\n   N/A   N/A   N/A   N/A   long double\ne E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\na A (C99).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\ng G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\nn   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A\np   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A\n...   -   arguments specifying data to print. If any argument after default argument promotions is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by format, the behavior is undefined. If there are more arguments than required by format, the extraneous arguments are evaluated and ignored.\n\n\nReturn value\n\nNotes\n   The C standard and POSIX specify that the behavior of sprintf and its variants is undefined when an argument overlaps with the destination buffer. Example:\n   POSIX specifies that errno is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (n$ immediately after % indicates n'th argument).\n   Calling snprintf with zero bufsz and null pointer for buffer is useful to determine the necessary buffer size to contain the output:\n   snprintf_s, just like snprintf, but unlike sprintf_s, will truncate the output to fit in bufsz-1.\n", "url": "https://devdocs.io/c/io/fprintf\n"}, {"name": "fputc, putc", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint fputc( int ch, FILE *stream );\nint putc( int ch, FILE *stream );\n\n   Writes a character ch to the given output stream stream. putc() may be implemented as a macro and evaluate stream more than once, so the corresponding argument should never be an expression with side effects.\n   Internally, the character is converted to unsigned char just before being written.\n\nParameters\nch   -   character to be written\nstream   -   output stream\n\n\nReturn value\n   On success, returns the written character.\n   On failure, returns EOF and sets the error indicator (see ferror()) on stream.\n", "url": "https://devdocs.io/c/io/fputc\n"}, {"name": "fputs", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint fputs( const char          *str, FILE          *stream );\n    (until C99)\nint fputs( const char *restrict str, FILE *restrict stream );\n    (since C99)\n\n   Writes every character from the null-terminated string str to the output stream stream, as if by repeatedly executing fputc.\n   The terminating null character from str is not written.\n\nParameters\nstr   -   null-terminated character string to be written\nstream   -   output stream\n\n\nReturn value\n   On success, returns a non-negative value.\n   On failure, returns EOF and sets the error indicator (see ferror()) on stream.\n\nNotes\n   The related function puts appends a newline character to the output, while fputs writes the string unmodified.\n   Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant such as zero.\n", "url": "https://devdocs.io/c/io/fputs\n"}, {"name": "fputwc, putwc", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwint_t fputwc( wchar_t ch, FILE *stream );\n    (since C95)\nwint_t putwc( wchar_t ch, FILE *stream );\n    (since C95)\n\n   Writes a wide character ch to the given output stream stream. putwc() may be implemented as a macro and may evaluate stream more than once.\n\nParameters\nch   -   wide character to be written\nstream   -   the output stream\n\n\nReturn value\n   Returns a copy of ch on success.\n   On failure, returns WEOF and sets the error indicator (see ferror()) on stream.\n   If an encoding error occurred, additionally sets errno to EILSEQ.\n", "url": "https://devdocs.io/c/io/fputwc\n"}, {"name": "fputws", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint fputws( const wchar_t *str, FILE *stream );\n    (since C95) (until C99)\nint fputws( const wchar_t * restrict str, FILE * restrict stream );\n    (since C99)\n\n   Writes every character from the null-terminated wide string str to the output stream stream, as if by repeatedly executing fputwc.\n   The terminating null wide character from str is not written.\n\nParameters\nstr   -   null-terminated wide string to be written\nstream   -   output stream\n\n\nReturn value\n   On success, returns a non-negative value.\n   On failure, returns EOF and sets the error indicator (see ferror) on stream.\n", "url": "https://devdocs.io/c/io/fputws\n"}, {"name": "fread", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nsize_t fread( void          *buffer, size_t size, size_t count,\n              FILE          *stream );\n    (until C99)\nsize_t fread( void *restrict buffer, size_t size, size_t count, \n              FILE *restrict stream );\n    (since C99)\n\n   Reads up to count objects into the array buffer from the given input stream stream as if by calling fgetc size times for each object, and storing the results, in the order obtained, into the successive positions of buffer, which is reinterpreted as an array of unsigned char. The file position indicator for the stream is advanced by the number of characters read.\n   If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.\n\nParameters\nbuffer   -   pointer to the array where the read objects are stored\nsize   -   size of each object in bytes\ncount   -   the number of the objects to be read\nstream   -   the stream to read\n\n\nReturn value\n   Number of objects read successfully, which may be less than count if an error or end-of-file condition occurs.\n   If size or count is zero, fread returns zero and performs no other action.\n   fread does not distinguish between end-of-file and error, and callers must use feof and ferror to determine which occurred.\n", "url": "https://devdocs.io/c/io/fread\n"}, {"name": "freopen, freopen_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\n(1)\nFILE *freopen( const char *filename, const char *mode,\n               FILE *stream );\n  (until C99)\nFILE *freopen( const char *restrict filename, const char *restrict mode, \n               FILE *restrict stream );\n  (since C99)\nerrno_t freopen_s(FILE *restrict *restrict newstreamptr,\n                  const char *restrict filename, const char *restrict mode,\n                  FILE *restrict stream);\n  (2)   (since C11)\n\n\nParameters\nfilename   -   file name to associate the file stream to\nmode   -   null-terminated character string determining new file access mode    File access mode string   Meaning   Explanation   Action if file  already exists   Action if file  does not exist \n   \"r\"   read   Open a file for reading   read from start   failure to open \n   \"w\"   write   Create a file for writing   destroy contents   create new \n   \"a\"   append   Append to a file   write to end   create new \n   \"r+\"   read extended   Open a file for read/write   read from start   error \n   \"w+\"   write extended   Create a file for read/write   destroy contents   create new \n   \"a+\"   append extended   Open a file for read/write   write to end   create new \n   File access mode flag \"b\" can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows it disables special handling of '\\n' and '\\x1A'.  On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator. \n   The behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. Windows). \n   In update mode ('+'), both input and output may be performed, but output cannot be followed by input without an intervening call to fflush, fseek, fsetpos or rewind, and input cannot be followed by output without an intervening call to fseek, fsetpos or rewind, unless the input operation encountered end of file. In update mode, implementations are permitted to use binary mode even when text mode is specified. \n   File access mode flag \"x\" can optionally be appended to \"w\" or \"w+\" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11) \n   When using fopen_s or freopen_s, file access permissions for any file created with \"w\" or \"a\" prevents other users from accessing it. File access mode flag \"u\" can optionally be prepended to any specifier that begins with \"w\" or \"a\", to enable the default fopen permissions. (C11)\nFile access mode string   Meaning   Explanation   Action if file  already exists   Action if file  does not exist\n\"r\"   read   Open a file for reading   read from start   failure to open\n\"w\"   write   Create a file for writing   destroy contents   create new\n\"a\"   append   Append to a file   write to end   create new\n\"r+\"   read extended   Open a file for read/write   read from start   error\n\"w+\"   write extended   Create a file for read/write   destroy contents   create new\n\"a+\"   append extended   Open a file for read/write   write to end   create new\nFile access mode flag \"b\" can optionally be specified to open a file in binary mode. This flag has no effect on POSIX systems, but on Windows it disables special handling of '\\n' and '\\x1A'.  On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.\nThe behavior is undefined if the mode is not one of the strings listed above. Some implementations define additional supported modes (e.g. Windows).\nIn update mode ('+'), both input and output may be performed, but output cannot be followed by input without an intervening call to fflush, fseek, fsetpos or rewind, and input cannot be followed by output without an intervening call to fseek, fsetpos or rewind, unless the input operation encountered end of file. In update mode, implementations are permitted to use binary mode even when text mode is specified.\nFile access mode flag \"x\" can optionally be appended to \"w\" or \"w+\" specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C11)\nWhen using fopen_s or freopen_s, file access permissions for any file created with \"w\" or \"a\" prevents other users from accessing it. File access mode flag \"u\" can optionally be prepended to any specifier that begins with \"w\" or \"a\", to enable the default fopen permissions. (C11)\nstream   -   the file stream to modify\nnewstreamptr   -   pointer to a pointer where the function stores the result (an out-parameter)\n\n\nReturn value\n\nNotes\n   freopen is the only way to change the narrow/wide orientation of a stream once it has been established by an I/O operation or by fwide.\n", "url": "https://devdocs.io/c/io/freopen\n"}, {"name": "scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\n(1)\n\u200bint scanf( const char          *format, ... );\u200b\n  (until C99)\n\u200bint scanf( const char *restrict format, ... );\u200b\n  (since C99)\n(2)\nint fscanf( FILE          *stream, const char          *format, ... );\n  (until C99)\nint fscanf( FILE *restrict stream, const char *restrict format, ... );\n  (since C99)\n(3)\nint sscanf( const char          *buffer, const char          *format, ... );\n  (until C99)\nint sscanf( const char *restrict buffer, const char *restrict format, ... );\n  (since C99)\nint scanf_s(const char *restrict format, ...);\n  (4)   (since C11)\nint fscanf_s(FILE *restrict stream, const char *restrict format, ...);\n  (5)   (since C11)\nint sscanf_s(const char *restrict buffer, const char *restrict format, ...);\n  (6)   (since C11)\n\n   Reads data from the a variety of sources, interprets it according to format and stores the results into given locations.\n\nParameters\nstream   -   input file stream to read from\nbuffer   -   pointer to a null-terminated character string to read from\nformat   -   pointer to a null-terminated character string specifying how to read the input. The format string consists of.\n\n non-whitespace multibyte characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal. \n whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling isspace in a loop). Note that there is no difference between \"\\n\", \" \", \"\\t\\t\", or other whitespace in the format string. \n conversion specifications. Each conversion specification has the following format: \n\n introductory % character \n (optional) assignment-suppressing character *. If this option is present, the function does not assign the result of the conversion to any receiving argument. \n (optional) integer number (greater than zero) that specifies maximum field width, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided. \n (optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below). \n conversion format specifier \n\n The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L \n   %   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    matches a character or a sequence of characters If a width specifier is used, matches exactly width characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   s    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   [set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   d   matches a decimal integer.  The format of the number is the same as expected by strtol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A \n   i   matches an integer.  The format of the number is the same as expected by strtol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\n\n   u   matches an unsigned decimal integer.  The format of the number is the same as expected by strtoul() with the value 10 for the base argument.\n\n   o   matches an unsigned octal integer.  The format of the number is the same as expected by strtoul() with the value 8 for the base argument.\n\n   x, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by strtoul() with the value 16 for the base argument.\n\n   n   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\n\n   a, A(C99) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by strtof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double* \n   p   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A \n\n For every conversion specifier other than n, the longest sequence of input characters which does not exceed any speci\ufb01ed \ufb01eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \ufb01rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\ufb01le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\nAll conversion specifiers other than [, c, and n consume and discard all leading whitespace characters (determined as if by calling isspace) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\nThe conversion specifiers lc, ls, and l[ perform multibyte-to-wide character conversion as if by calling mbrtowc() with an mbstate_t object initialized to zero before the first character is converted.\nThe conversion specifiers s and [ always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of %s or %[, without specifying the destination array size, is as unsafe as gets.\nThe correct conversion specifications for the fixed-width integer types (int8_t, etc) are defined in the header <inttypes.h> (although SCNdMAX, SCNuMAX, etc is synonymous with %jd, %ju, etc).\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing \"100er\" with the conversion specifier %f, the sequence \"100e\" (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with \"r\" remaining. Some existing implementations do not follow this rule and roll back to consume only \"100\", leaving \"er\", e.g. glibc bug 1765.\nIf a conversion specification is invalid, the behavior is undefined.\nConversion specifier   Explanation   Argument type\nlength modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L\n%   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A\nc    matches a character or a sequence of characters If a width specifier is used, matches exactly width characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A\ns    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n[set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\nd   matches a decimal integer.  The format of the number is the same as expected by strtol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A\ni   matches an integer.  The format of the number is the same as expected by strtol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\nu   matches an unsigned decimal integer.  The format of the number is the same as expected by strtoul() with the value 10 for the base argument.\no   matches an unsigned octal integer.  The format of the number is the same as expected by strtoul() with the value 8 for the base argument.\nx, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by strtoul() with the value 16 for the base argument.\nn   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\na, A(C99) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by strtof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double*\np   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A\n...   -   receiving arguments\n\n\nReturn value\n\nNotes\n   Because most conversion specifiers first consume all consecutive whitespace, code such as.\n   will read two integers that are entered on different lines (second %d will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second %d will consume the spaces or tabs).  The conversion specifiers that do not consume leading whitespace, such as %c, can be made to do so by using a whitespace character in the format string:\n", "url": "https://devdocs.io/c/io/fscanf\n"}, {"name": "fseek", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint fseek( FILE *stream, long offset, int origin );\n\n   Sets the file position indicator for the file stream stream to the value pointed to by offset.\n   If the stream is open in binary mode, the new position is exactly offset bytes measured from the beginning of the file if origin is SEEK_SET, from the current file position if origin is SEEK_CUR, and from the end of the file if origin is SEEK_END. Binary streams are not required to support SEEK_END, in particular if additional null bytes are output.\n   If the stream is open in text mode, the only supported values for offset are zero (which works with any origin) and a value returned by an earlier call to ftell on a stream associated with the same file (which only works with origin of SEEK_SET).\n   If the stream is wide-oriented, the restrictions of both text and binary streams apply (result of ftell is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).\n   In addition to changing the file position indicator, fseek undoes the effects of ungetc and clears the end-of-file status, if applicable.\n   If a read or write error occurs, the error indicator for the stream (ferror) is set and the file position is unaffected.\n\nParameters\nstream   -   file stream to modify\noffset   -   number of characters to shift the position relative to origin\norigin   -   position to which offset is added. It can have one of the following values: SEEK_SET, SEEK_CUR, SEEK_END\n\n\nReturn value\n   \u200b0\u200b upon success, nonzero value otherwise.\n\nNotes\n   After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.\n   For text streams, the only valid values of offset are \u200b0\u200b (applicable to any origin) and a value returned by an earlier call to ftell (only applicable to SEEK_SET).\n   POSIX allows seeking beyond the existing end of file. If an output is performed after this seek, any read from the gap will return zero bytes. Where supported by the filesystem, this creates a sparse file.\n   POSIX also requires that fseek first performs fflush if there are any unwritten data (but whether the shift state is restored is implementation-defined).\n", "url": "https://devdocs.io/c/io/fseek\n"}, {"name": "fsetpos", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint fsetpos( FILE *stream, const fpos_t *pos );\n\n   Sets the file position indicator and the multibyte parsing state (if any) for the file stream stream according to the value pointed to by pos.\n   Besides establishing new parse state and position, a call to this function undoes the effects of ungetc and clears the end-of-file state, if it is set.\n   If a read or write error occurs, the error indicator (ferror) for the stream is set.\n\nParameters\nstream   -   file stream to modify\npos   -   pointer to a fpos_t object to use as new value of file position indicator\n\n\nReturn value\n   \u200b0\u200b upon success, nonzero value otherwise.\n\nNotes\n   After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.\n", "url": "https://devdocs.io/c/io/fsetpos\n"}, {"name": "ftell", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nlong ftell( FILE *stream );\n\n   Returns the file position indicator for the file stream stream.\n   If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.\n   If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to fseek().\n\nParameters\nstream   -   file stream to examine\n\n\nReturn value\n   File position indicator on success or EOF if failure occurs.\n   On error, the errno variable is set to implementation-defined positive value.\n", "url": "https://devdocs.io/c/io/ftell\n"}, {"name": "fwide", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint fwide( FILE *stream, int mode );\n    (since C95)\n\n   If mode > 0, attempts to make stream wide-oriented. If mode < 0, attempts to make stream byte-oriented. If mode==0, only queries the current orientation of the stream.\n   If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.\n\nParameters\nstream   -   pointer to the C I/O stream to modify or query\nmode   -   integer value greater than zero to set the stream wide, less than zero to set the stream narrow, or zero to query only\n\n\nReturn value\n   An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.\n", "url": "https://devdocs.io/c/io/fwide\n"}, {"name": "wprintf, fwprintf, swprintf, wprintf_s, fwprintf_s, swprintf_s, snwprintf_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nint wprintf( const wchar_t *format, ... );\n  (since C95) (until C99)\nint wprintf( const wchar_t *restrict format, ... );\n  (since C99)\n(2)\nint fwprintf( FILE *stream, const wchar_t* format, ... );\n  (since C95) (until C99)\nint fwprintf( FILE *restrict stream,\n              const wchar_t *restrict format, ... );\n  (since C99)\n(3)\nint swprintf( wchar_t *buffer, size_t bufsz,\n              const wchar_t* format, ... );\n  (since C95) (until C99)\nint swprintf( wchar_t *restrict buffer, size_t bufsz,\n              const wchar_t *restrict format, ... );\n  (since C99)\nint wprintf_s( const wchar_t *restrict format, ...);\n  (4)   (since C11)\nint fwprintf_s( FILE *restrict stream,\n                const wchar_t *restrict format, ...);\n  (5)   (since C11)\nint swprintf_s( wchar_t *restrict buffer, rsize_t bufsz,\n                const wchar_t* restrict format, ...);\n  (6)   (since C11)\nint snwprintf_s( wchar_t * restrict s, rsize_t n,\n                 const wchar_t * restrict format, ...);\n  (7)   (since C11)\n\n   Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.\n\nParameters\nstream   -   output file stream to write to\nbuffer   -   pointer to a wide character string to write to\nbufsz   -   up to bufsz-1 wide characters may be written, plus the null terminator\nformat   -   pointer to a null-terminated wide string specifying how to interpret the data. The format string consists of ordinary wide characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n introductory % character \n (optional) one or more flags that modify the behavior of the conversion: \n\n -: the result of the conversion is left-justified within the field (by default it is right-justified) \n +: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) \n space: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if + flag is present. \n # : alternative form of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. \n 0 : for integer and floating point number conversions, leading zeros are used to pad the field instead of space characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if - flag is present. \n\n (optional) integer value or * that specifies minimum field width. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when * is used, the width is specified by an additional argument of type int. If the value of the argument is negative, it results with the - flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) \n\n (optional) . followed by integer number or *, or neither that specifies precision of the conversion. In the case when * is used, the precision is specified by an additional argument of type int. If the value of this argument is negative, it is ignored. If neither a number nor * is used, the precision is taken as zero. See the table below for exact effects of precision. \n (optional) length modifier that specifies the size of the argument \n conversion format specifier \n\n The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L \n   %   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    writes a single character.  The argument is first converted to wchar_t as if by calling btowc. If the l modifier is used, the wint_t argument is first converted to wchar_t.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A \n   s    writes a character string The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to mbrtowc with zero-initialized conversion state. Precision specifies the maximum number of wide characters to be written. If Precision is not specified, writes every wide characters up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   d i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A \n   o   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A \n   x X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A \n   u   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A \n   f F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C99)\n   N/A   N/A   N/A   N/A   long double \n   e E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   a A (C99).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   g G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   n   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A \n   p   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A \n\n The floating point conversion functions convert infinity to inf or infinity. Which one is used is implementation defined.\nNot-a-number is converted to nan or nan(char_sequence). Which one is used is implementation defined.\nThe conversions F, E, G, A output INF, INFINITY, NAN instead.\nEven though %c expects int argument, it is safe to pass a char because of the integer promotion that takes place when a variadic function is called.\nThe correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <inttypes.h> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).\nThe memory-writing conversion specifier %n is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked printf_s family of functions.\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple %n results in the same variable or, as an edge case, printing a string modified by an earlier %n within the same call.\nIf a conversion specification is invalid, the behavior is undefined.\nConversion specifier   Explanation   Argument type\nlength modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L\n%   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A\nc    writes a single character.  The argument is first converted to wchar_t as if by calling btowc. If the l modifier is used, the wint_t argument is first converted to wchar_t.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A\ns    writes a character string The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to mbrtowc with zero-initialized conversion state. Precision specifies the maximum number of wide characters to be written. If Precision is not specified, writes every wide characters up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A\nd i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A\no   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A\nx X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A\nu   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A\nf F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C99)\n   N/A   N/A   N/A   N/A   long double\ne E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\na A (C99).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\ng G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\nn   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A\np   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A\n...   -   arguments specifying data to print. If any argument after default argument promotions is not the type expected by the corresponding conversion specifier, or if there are fewer arguments than required by format, the behavior is undefined. If there are more arguments than required by format, the extraneous arguments are evaluated and ignored\n\n\nReturn value\n\nNotes\n   While narrow strings provide snprintf, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's snwprintf_s), and in order to determine the buffer size, the program may need to call swprintf, check the result value, and reallocate a larger buffer, trying again until successful.\n   snwprintf_s, unlike swprintf_s, will truncate the result to fit within the array pointed to by buffer, even though truncation is treated as an error by most bounds-checked functions.\n", "url": "https://devdocs.io/c/io/fwprintf\n"}, {"name": "fwrite", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nsize_t fwrite( const void *buffer, size_t size, size_t count,\n               FILE *stream );\n    (until C99)\nsize_t fwrite( const void *restrict buffer, size_t size, size_t count, \n               FILE *restrict stream );\n    (since C99)\n\n   Writes count of objects from the given array buffer to the output stream stream. The objects are written as if by reinterpreting each object as an array of unsigned char and calling fputc size times for each object to write those unsigned chars into stream, in order. The file position indicator for the stream is advanced by the number of characters written.\n\nParameters\nbuffer   -   pointer to the first object in the array to be written\nsize   -   size of each object\ncount   -   the number of the objects to be written\nstream   -   pointer to the output stream\n\n\nReturn value\n   The number of objects written successfully, which may be less than count if an error occurs.\n   If size or count is zero, fwrite returns zero and performs no other action.\n", "url": "https://devdocs.io/c/io/fwrite\n"}, {"name": "wscanf, fwscanf, swscanf, wscanf_s, fwscanf_s, swscanf_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nint wscanf( const wchar_t *format, ... );\n  (since C95) (until C99)\nint wscanf( const wchar_t *restrict format, ... );\n  (since C99)\n(2)\nint fwscanf( FILE *stream, const wchar_t *format, ... );\n  (since C95) (until C99)\nint fwscanf( FILE *restrict stream,\n             const wchar_t *restrict format, ... );\n  (since C99)\n(3)\nint swscanf( const wchar_t *buffer, const wchar_t *format, ... );\n  (since C95) (until C99)\nint swscanf( const wchar_t *restrict buffer,\n             const wchar_t *restrict format, ... );\n  (since C99)\nint wscanf_s( const wchar_t *restrict format, ...);\n  (4)   (since C11)\nint fwscanf_s( FILE *restrict stream,\n               const wchar_t *restrict format, ...);\n  (5)   (since C11)\nint swscanf_s( const wchar_t *restrict s,\n               const wchar_t *restrict format, ...);\n  (6)   (since C11)\n\n   Reads data from the a variety of sources, interprets it according to format and stores the results into given locations.\n\nParameters\nstream   -   input file stream to read from\nbuffer   -   pointer to a null-terminated wide string to read from\nformat   -   pointer to a null-terminated wide string specifying how to read the input. The format string consists of \n non-whitespace wide characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal. \n whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling iswspace in a loop). Note that there is no difference between \"\\n\", \" \", \"\\t\\t\", or other whitespace in the format string. \n conversion specifications. Each conversion specification has the following format: \n\n introductory % character \n (optional) assignment-suppressing character *. If this option is present, the function does not assign the result of the conversion to any receiving argument. \n (optional) integer number (greater than zero) that specifies maximum field width, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided. \n (optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below). \n conversion format specifier \n\n The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L \n   %   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    matches a character or a sequence of characters If a width specifier is used, matches exactly width wide characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   s    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   [set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   d   matches a decimal integer.  The format of the number is the same as expected by wcstol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A \n   i   matches an integer.  The format of the number is the same as expected by wcstol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\n\n   u   matches an unsigned decimal integer.  The format of the number is the same as expected by wcstoul() with the value 10 for the base argument.\n\n   o   matches an unsigned octal integer.  The format of the number is the same as expected by wcstoul() with the value 8 for the base argument.\n\n   x, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by wcstoul() with the value 16 for the base argument.\n\n   n   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\n\n   a, A(C99) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by wcstof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double* \n   p   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A \n\n For every conversion specifier other than n, the longest sequence of input characters which does not exceed any speci\ufb01ed \ufb01eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \ufb01rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\ufb01le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\nAll conversion specifiers other than [, c, and n consume and discard all leading whitespace characters (determined as if by calling iswspace) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\nIf the length specifier l is not used, the conversion specifiers c, s, and [ perform wide-to-multibyte character conversion as if by calling wcrtomb() with an mbstate_t object initialized to zero before the first character is converted.\nThe conversion specifiers s and [ always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of %s or %[, without specifying the destination array size, is as unsafe as gets.\nThe correct conversion specifications for the fixed-width integer types (int8_t, etc) are defined in the header <inttypes.h> (although SCNdMAX, SCNuMAX, etc is synonymous with %jd, %ju, etc).\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing \"100er\" with the conversion specifier %f, the sequence \"100e\" (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with \"r\" remaining. Some existing implementations do not follow this rule and roll back to consume only \"100\", leaving \"er\", e.g. glibc bug 1765.\nConversion specifier   Explanation   Argument type\nlength modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L\n%   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A\nc    matches a character or a sequence of characters If a width specifier is used, matches exactly width wide characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A\ns    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n[set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\nd   matches a decimal integer.  The format of the number is the same as expected by wcstol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A\ni   matches an integer.  The format of the number is the same as expected by wcstol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\nu   matches an unsigned decimal integer.  The format of the number is the same as expected by wcstoul() with the value 10 for the base argument.\no   matches an unsigned octal integer.  The format of the number is the same as expected by wcstoul() with the value 8 for the base argument.\nx, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by wcstoul() with the value 16 for the base argument.\nn   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\na, A(C99) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by wcstof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double*\np   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A\n...   -   receiving arguments\n\n\nReturn value\n", "url": "https://devdocs.io/c/io/fwscanf\n"}, {"name": "getchar", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint getchar(void);\n\n   Reads the next character from stdin.\n   Equivalent to getc(stdin).\n\nParameters\n   (none).\n\nReturn value\n   The obtained character on success or EOF on failure.\n   If the failure has been caused by end-of-file condition, additionally sets the eof indicator (see feof()) on stdin. If the failure has been caused by some other error, sets the error indicator (see ferror()) on stdin.\n", "url": "https://devdocs.io/c/io/getchar\n"}, {"name": "gets, gets_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nchar *gets( char *str );\n    (removed in C11)\nchar *gets_s( char *str, rsize_t n );\n    (since C11) (optional)\n\n\nParameters\nstr   -   character string to be written\n\n\nReturn value\n   str on success, NULL on failure.\n   If the failure has been caused by end of file condition, additionally sets the eof indicator (see feof()) on stdin. If the failure has been caused by some other error, sets the error indicator (see ferror()) on stdin.\n\nNotes\n   The gets() function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely (unless the program runs in an environment which restricts what can appear on stdin). For this reason, the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard. fgets() and gets_s() are the recommended replacements.\n   Never use gets().\n", "url": "https://devdocs.io/c/io/gets\n"}, {"name": "getwchar", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwint_t getwchar(void);\n    (since C95)\n\n   Reads the next wide character from stdin.\n\nParameters\n   (none).\n\nReturn value\n   the obtained wide character or WEOF if an error has occurred or the end of file reached.\n", "url": "https://devdocs.io/c/io/getwchar\n"}, {"name": "perror", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nvoid perror( const char *s );\n\n   Prints a textual description of the error code currently stored in the system variable errno to stderr.\n   The description is formed by concatenating the following components:\n\nParameters\ns   -   pointer to a null-terminated string with explanatory message\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/io/perror\n"}, {"name": "putchar", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint putchar( int ch );\n\n   Writes a character ch to stdout. Internally, the character is converted to unsigned char just before being written.\n   Equivalent to putc(ch, stdout).\n\nParameters\nch   -   character to be written\n\n\nReturn value\n   On success, returns the written character.\n   On failure, returns EOF and sets the error indicator (see ferror()) on stdout.\n", "url": "https://devdocs.io/c/io/putchar\n"}, {"name": "puts", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint puts( const char *str );\n\n   Writes every character from the null-terminated string str and one additional newline character '\\n' to the output stream stdout, as if by repeatedly executing fputc.\n   The terminating null character from str is not written.\n\nParameters\nstr   -   character string to be written\n\n\nReturn value\n   On success, returns a non-negative value.\n   On failure, returns EOF and sets the error indicator (see ferror()) on stream.\n\nNotes\n   The puts function appends the newline character to the output, while fputs function does not.\n   Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant.\n   A typical cause of failure for puts is running out of space on the file system, when stdout is redirected to a file.\n", "url": "https://devdocs.io/c/io/puts\n"}, {"name": "putwchar", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwint_t putwchar( wchar_t ch );\n    (since C95)\n\n   Writes a wide character ch to stdout.\n\nParameters\nch   -   wide character to be written\n\n\nReturn value\n   ch on success, WEOF on failure.\n", "url": "https://devdocs.io/c/io/putwchar\n"}, {"name": "remove", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint remove( const char *fname );\n\n   Deletes the file identified by character string pointed to by fname.\n   If the file is currently open by this or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name although the file system space is not reclaimed until the last running process closes the file; Windows does not allow the file to be deleted).\n\nParameters\nfname   -   pointer to a null-terminated string containing the path identifying the file to delete\n\n\nReturn value\n   \u200b0\u200b upon success or non-zero value on error.\n\nNotes\n   POSIX specifies many additional details for the behavior of this function.\n", "url": "https://devdocs.io/c/io/remove\n"}, {"name": "rename", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint rename( const char *old_filename, const char *new_filename );\n\n   Changes the filename of a file. The file is identified by character string pointed to by old_filename. The new filename is identified by character string pointed to by new_filename.\n   If new_filename exists, the behavior is implementation-defined.\n\nParameters\nold_filename   -   pointer to a null-terminated string containing the path identifying the file to rename\nnew_filename   -   pointer to a null-terminated string containing the new path of the file\n\n\nReturn value\n   \u200b0\u200b upon success or non-zero value on error.\n\nNotes\n   POSIX specifies many additional details on the semantics of this function.\n", "url": "https://devdocs.io/c/io/rename\n"}, {"name": "rewind", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nvoid rewind( FILE *stream );\n\n   Moves the file position indicator to the beginning of the given file stream.\n   The function is equivalent to fseek(stream, 0, SEEK_SET);, except that end-of-file and error indicators are cleared.\n   The function drops any effects from previous calls to ungetc.\n\nParameters\nstream   -   file stream to modify\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/io/rewind\n"}, {"name": "setbuf", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nvoid setbuf( FILE          *stream, char          *buffer );\n    (until C99)\nvoid setbuf( FILE *restrict stream, char *restrict buffer );\n    (since C99)\n\n   Sets the internal buffer to use for stream operations. It should be at least BUFSIZ characters long.\n   If buffer is not null, equivalent to setvbuf(stream, buffer, _IOFBF, BUFSIZ).\n   If buffer is null, equivalent to setvbuf(stream, NULL, _IONBF, 0), which turns off buffering.\n\nParameters\nstream   -   the file stream to set the buffer to\nbuffer   -   pointer to a buffer for the stream to use. If NULL is supplied, the buffering is turned off\n\n\nReturn value\n   None.\n\nNotes\n   If BUFSIZ is not the appropriate buffer size, setvbuf can be used to change it.\n   setvbuf should also be used to detect errors, since setbuf does not indicate success or failure.\n   This function may only be used after stream has been associated with an open file, but before any other operation (other than a failed call to setbuf/setvbuf).\n   A common error is setting the buffer of stdin or stdout to an array whose lifetime ends before the program terminates:\n", "url": "https://devdocs.io/c/io/setbuf\n"}, {"name": "setvbuf", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint setvbuf( FILE *         stream, char *         buffer, \n             int mode, size_t size );\n    (until C99)\nint setvbuf( FILE *restrict stream, char *restrict buffer, \n             int mode, size_t size );\n    (since C99)\n\n   Changes the the buffering mode of the given file stream stream as indicated by the argument mode. In addition,\n\nParameters\nstream   -   the file stream to set the buffer to\nbuffer   -   pointer to a buffer for the stream to use or null pointer to change size and mode only\nmode   -   buffering mode to use. It can be one of the following values:    _IOFBF   full buffering \n   _IOLBF   line buffering \n   _IONBF   no buffering\n_IOFBF   full buffering\n_IOLBF   line buffering\n_IONBF   no buffering\nsize   -   size of the buffer\n\n\nReturn value\n   \u200b0\u200b on success or nonzero on failure.\n\nNotes\n   This function may only be used after stream has been associated with an open file, but before any other operation (other than a failed call to setbuf/setvbuf).\n   Not all size bytes will necessarily be used for buffering: the actual buffer size is usually rounded down to a multiple of 2, a multiple of page size, etc.\n   On many implementations, line buffering is only available for terminal input streams.\n   A common error is setting the buffer of stdin or stdout to an array whose lifetime ends before the program terminates:\n   The default buffer size BUFSIZ is expected to be the most efficient buffer size for file I/O on the implementation, but POSIX fstat often provides a better estimate.\n", "url": "https://devdocs.io/c/io/setvbuf\n"}, {"name": "tmpfile, tmpfile_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nFILE *tmpfile(void);\n  (1)\nerrno_t tmpfile_s(FILE * restrict * restrict streamptr);\n  (2)   (since C11)\n\n   The temporary file created by this function is closed and deleted when the program exits normally. Whether it's deleted on abnormal termination is implementation-defined.\n\nParameters\n\nReturn value\n\nNotes\n   On some implementations (e.g. Linux), this function actually creates, opens, and immediately deletes the file from the file system: as long as an open file descriptor to a deleted file is held by a program, the file exists, but since it was deleted, its name does not appear in any directory, so that no other process can open it. Once the file descriptor is closed, or once the program terminates (normally or abnormally), the space occupied by the file is reclaimed by the filesystem.\n   On some implementations (e.g. Windows), elevated privileges are required as the function may create the temporary file in a system directory.\n", "url": "https://devdocs.io/c/io/tmpfile\n"}, {"name": "tmpnam, tmpnam_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nchar *tmpnam( char *filename );\n  (1)\nerrno_t tmpnam_s(char *filename_s, rsize_t maxsize);\n  (2)   (since C11)\n\n   tmpnam and tmpnam_s modify static state (which may be shared between these functions) and are not required to be thread-safe.\n\nParameters\nfilename   -   pointer to the character array capable of holding at least L_tmpnam bytes, to be used as a result buffer. If null pointer is passed, a pointer to an internal static buffer is returned.\nfilename_s   -   pointer to the character array capable of holding at least L_tmpnam_s bytes, to be used as a result buffer.\nmaxsize   -   maximum number of characters the function is allowed to write (typically the size of the filename_s array).\n\n\nReturn value\n\nNotes\n   Although the names generated by tmpnam are difficult to guess, it is possible that a file with that name is created by another process between the moment tmpnam returns and the moment this program attempts to use the returned name to create a file. The standard function tmpfile and the POSIX function mkstemp do not have this problem (creating a unique directory using only the standard C library still requires the use of tmpnam).\n   POSIX systems additionally define the similarly named function tempnam(), which offers the choice of a directory (which defaults to the optionally defined macro P_tmpdir).\n", "url": "https://devdocs.io/c/io/tmpnam\n"}, {"name": "ungetc", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\nint ungetc( int ch, FILE *stream );\n\n   If ch does not equal EOF, pushes the character ch (reinterpreted as unsigned char) into the input buffer associated with the stream stream in such a manner that subsequent read operation from stream will retrieve that character. The external device associated with the stream is not modified.\n   Stream repositioning operations fseek, fsetpos, and rewind discard the effects of ungetc.\n   If ungetc is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful ungetc were performed, read operations retrieve the pushed-back characters in reverse order of ungetc.\n   If ch equals EOF, the operation fails and the stream is not affected.\n   A successful call to ungetc clears the end of file status flag feof.\n   A successful call to ungetc on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).\n   A successful call to ungetc on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before ungetc.\n\nParameters\nch   -   character to be pushed into the input stream buffer\nstream   -   file stream to put the character back to\n\n\nReturn value\n   On success ch is returned.\n   On failure EOF is returned and the given stream remains unchanged.\n\nNotes\n   The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).\n   The apparent size of the pushback buffer may be larger if the character that is pushed back equals the character existing at that location in the external character sequence (the implementation may simply decrement the read file position indicator and avoid maintaining a pushback buffer).\n", "url": "https://devdocs.io/c/io/ungetc\n"}, {"name": "ungetwc", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwint_t ungetwc( wint_t ch, FILE *stream );\n    (since C95)\n\n   If ch does not equal WEOF, pushes the wide character ch into the input buffer associated with the stream stream in such a manner that subsequent read operation from stream will retrieve that wide character. The external device associated with the stream is not modified.\n   Stream repositioning operations fseek, fsetpos, and rewind discard the effects of ungetwc.\n   If ungetwc is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful ungetwc were performed, read operations retrieve the pushed-back wide characters in reverse order of ungetwc.\n   If ch equals WEOF, the operation fails and the stream is not affected.\n   A successful call to ungetwc clears the end of file status flag feof.\n   A successful call to ungetwc on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before ungetwc.\n\nParameters\nch   -   wide character to be put back\nstream   -   file stream to put the wide character back to\n\n\nReturn value\n   On success ch is returned.\n   On failure WEOF is returned and the given stream remains unchanged.\n", "url": "https://devdocs.io/c/io/ungetwc\n"}, {"name": "vprintf, vfprintf, vsprintf, vsnprintf, vprintf_s, vfprintf_s, vsprintf_s, vsnprintf_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\n(1)\n\u200bint vprintf( const char *format, va_list vlist );\u200b\n  (until C99)\n\u200bint vprintf( const char *restrict format, va_list vlist );\u200b\n  (since C99)\n(2)\nint vfprintf( FILE *stream, const char *format, va_list vlist );\n  (until C99)\nint vfprintf( FILE *restrict stream, const char *restrict format, \n              va_list vlist );\n  (since C99)\n(3)\nint vsprintf( char *buffer, const char *format, va_list vlist );\n  (until C99)\nint vsprintf( char *restrict buffer, const char *restrict format, \n              va_list vlist );\n  (since C99)\nint vsnprintf( char *restrict buffer, size_t bufsz, \n               const char *restrict format, va_list vlist );\n  (4)   (since C99)\nint vprintf_s( const char *restrict format, va_list arg);\n  (5)   (since C11)\nint vfprintf_s( FILE *restrict stream, const char *restrict format,\n                va_list arg);\n  (6)   (since C11)\nint vsprintf_s( char *restrict buffer, rsize_t bufsz,\n                const char *restrict format, va_list arg);\n  (7)   (since C11)\nint vsnprintf_s(char *restrict buffer, rsize_t bufsz,\n                const char *restrict format, va_list arg);\n  (8)   (since C11)\n\n   Loads the data from the locations, defined by vlist, converts them to character string equivalents and writes the results to a variety of sinks.\n\nParameters\nstream   -   output file stream to write to\nbuffer   -   pointer to a character string to write to\nbufsz   -   up to bufsz - 1 characters may be written, plus the null terminator\nformat   -   pointer to a null-terminated character string specifying how to interpret the data. The format string consists of ordinary multibyte characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n introductory % character \n (optional) one or more flags that modify the behavior of the conversion: \n\n -: the result of the conversion is left-justified within the field (by default it is right-justified) \n +: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) \n space: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if + flag is present. \n # : alternative form of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. \n 0 : for integer and floating point number conversions, leading zeros are used to pad the field instead of space characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if - flag is present. \n\n (optional) integer value or * that specifies minimum field width. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when * is used, the width is specified by an additional argument of type int. If the value of the argument is negative, it results with the - flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) \n\n (optional) . followed by integer number or *, or neither that specifies precision of the conversion. In the case when * is used, the precision is specified by an additional argument of type int. If the value of this argument is negative, it is ignored. If neither a number nor * is used, the precision is taken as zero. See the table below for exact effects of precision. \n (optional) length modifier that specifies the size of the argument \n conversion format specifier \n\n The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L \n   %   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    writes a single character.  The argument is first converted to unsigned char. If the l modifier is used, the argument is first converted to a character string as if by %ls with a wchar_t[2] argument.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A \n   s    writes a character string The argument must be a pointer to the initial element of an array of characters. Precision specifies the maximum number of bytes to be written. If Precision is not specified, writes every byte up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t, which is converted to char array as if by a call to wcrtomb with zero-initialized conversion state.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   d i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A \n   o   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A \n   x X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A \n   u   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A \n   f F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C99)\n   N/A   N/A   N/A   N/A   long double \n   e E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   a A (C99).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   g G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   n   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A \n   p   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A \n\n The floating point conversion functions convert infinity to inf or infinity. Which one is used is implementation defined.\nNot-a-number is converted to nan or nan(char_sequence). Which one is used is implementation defined.\nThe conversions F, E, G, A output INF, INFINITY, NAN instead.\nEven though %c expects int argument, it is safe to pass a char because of the integer promotion that takes place when a variadic function is called.\nThe correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <inttypes.h> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).\nThe memory-writing conversion specifier %n is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked printf_s family of functions.\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple %n results in the same variable or, as an edge case, printing a string modified by an earlier %n within the same call.\nIf a conversion specification is invalid, the behavior is undefined.\nConversion specifier   Explanation   Argument type\nlength modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L\n%   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A\nc    writes a single character.  The argument is first converted to unsigned char. If the l modifier is used, the argument is first converted to a character string as if by %ls with a wchar_t[2] argument.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A\ns    writes a character string The argument must be a pointer to the initial element of an array of characters. Precision specifies the maximum number of bytes to be written. If Precision is not specified, writes every byte up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t, which is converted to char array as if by a call to wcrtomb with zero-initialized conversion state.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A\nd i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A\no   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A\nx X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A\nu   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A\nf F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C99)\n   N/A   N/A   N/A   N/A   long double\ne E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\na A (C99).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\ng G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\nn   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A\np   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A\nvlist   -   variable argument list containing the data to print\n\n\nReturn value\n\nNotes\n   All these functions invoke va_arg at least once, the value of arg is indeterminate after the return. These functions do not invoke va_end, and it must be done by the caller.\n   vsnprintf_s, unlike vsprintf_s, will truncate the result to fit within the array pointed to by buffer.\n", "url": "https://devdocs.io/c/io/vfprintf\n"}, {"name": "vscanf, vfscanf, vsscanf, vscanf_s, vfscanf_s, vsscanf_s", "type": "STANDARD LIB", "description": "Defined in header <stdio.h>\n\u200bint vscanf( const char *restrict format, va_list vlist );\u200b\n  (1)   (since C99)\nint vfscanf( FILE *restrict stream, const char *restrict format, \n             va_list vlist );\n  (2)   (since C99)\nint vsscanf( const char *restrict buffer, const char *restrict format, \n             va_list vlist );\n  (3)   (since C99)\nint vscanf_s(const char *restrict format, va_list vlist);\n  (4)   (since C11)\nint vfscanf_s( FILE *restrict stream, const char *restrict format,\n               va_list vlist);\n  (5)   (since C11)\nint vsscanf_s( const char *restrict buffer, const char *restrict format,\n               va_list vlist);\n  (6)   (since C11)\n\n   Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist.\n\nParameters\nstream   -   input file stream to read from\nbuffer   -   pointer to a null-terminated character string to read from\nformat   -   pointer to a null-terminated character string specifying how to read the input. The format string consists of.\n\n non-whitespace multibyte characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal. \n whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling isspace in a loop). Note that there is no difference between \"\\n\", \" \", \"\\t\\t\", or other whitespace in the format string. \n conversion specifications. Each conversion specification has the following format: \n\n introductory % character \n (optional) assignment-suppressing character *. If this option is present, the function does not assign the result of the conversion to any receiving argument. \n (optional) integer number (greater than zero) that specifies maximum field width, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided. \n (optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below). \n conversion format specifier \n\n The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L \n   %   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    matches a character or a sequence of characters If a width specifier is used, matches exactly width characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   s    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   [set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   d   matches a decimal integer.  The format of the number is the same as expected by strtol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A \n   i   matches an integer.  The format of the number is the same as expected by strtol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\n\n   u   matches an unsigned decimal integer.  The format of the number is the same as expected by strtoul() with the value 10 for the base argument.\n\n   o   matches an unsigned octal integer.  The format of the number is the same as expected by strtoul() with the value 8 for the base argument.\n\n   x, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by strtoul() with the value 16 for the base argument.\n\n   n   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\n\n   a, A(C99) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by strtof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double* \n   p   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A \n\n For every conversion specifier other than n, the longest sequence of input characters which does not exceed any speci\ufb01ed \ufb01eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \ufb01rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\ufb01le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\nAll conversion specifiers other than [, c, and n consume and discard all leading whitespace characters (determined as if by calling isspace) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\nThe conversion specifiers lc, ls, and l[ perform multibyte-to-wide character conversion as if by calling mbrtowc() with an mbstate_t object initialized to zero before the first character is converted.\nThe conversion specifiers s and [ always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of %s or %[, without specifying the destination array size, is as unsafe as gets.\nThe correct conversion specifications for the fixed-width integer types (int8_t, etc) are defined in the header <inttypes.h> (although SCNdMAX, SCNuMAX, etc is synonymous with %jd, %ju, etc).\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing \"100er\" with the conversion specifier %f, the sequence \"100e\" (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with \"r\" remaining. Some existing implementations do not follow this rule and roll back to consume only \"100\", leaving \"er\", e.g. glibc bug 1765.\nConversion specifier   Explanation   Argument type\nlength modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L\n%   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A\nc    matches a character or a sequence of characters If a width specifier is used, matches exactly width characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A\ns    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n[set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\nd   matches a decimal integer.  The format of the number is the same as expected by strtol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A\ni   matches an integer.  The format of the number is the same as expected by strtol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\nu   matches an unsigned decimal integer.  The format of the number is the same as expected by strtoul() with the value 10 for the base argument.\no   matches an unsigned octal integer.  The format of the number is the same as expected by strtoul() with the value 8 for the base argument.\nx, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by strtoul() with the value 16 for the base argument.\nn   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\na, A(C99) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by strtof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double*\np   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A\nvlist   -   variable argument list containing the receiving arguments\n\n\nReturn value\n\nNotes\n   All these functions invoke va_arg at least once, the value of arg is indeterminate after the return. These functions to not invoke va_end, and it must be done by the caller.\n", "url": "https://devdocs.io/c/io/vfscanf\n"}, {"name": "vwprintf, vfwprintf, vswprintf, vwprintf_s, vfwprintf_s, vswprintf_s, vsnwprintf_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nint vwprintf( const wchar_t *format, va_list vlist );\n  (since C95) (until C99)\nint vwprintf( const wchar_t *restrict format, va_list vlist );\n  (since C99)\n(2)\nint vfwprintf( FILE* stream, const wchar_t *format, va_list vlist );\n  (since C95) (until C99)\nint vfwprintf( FILE *restrict stream,\n               const wchar_t *restrict format, va_list vlist );\n  (since C99)\n(3)\nint vswprintf( wchar_t *buffer, size_t bufsz,\n               const wchar_t *format, va_list vlist );\n  (since C95) (until C99)\nint vswprintf( wchar_t *restrict buffer, size_t bufsz,\n               const wchar_t *restrict format, va_list vlist );\n  (since C99)\nint vwprintf_s( const wchar_t *restrict format, va_list vlist);\n  (4)   (since C11)\nint vfwprintf_s( FILE * restrict stream,\n                 const wchar_t *restrict format, va_list vlist);\n  (5)   (since C11)\nint vswprintf_s( wchar_t *restrict buffer, rsize_t bufsz, \n                 const wchar_t * restrict format, va_list vlist);\n  (6)   (since C11)\nint vsnwprintf_s( wchar_t *restrict buffer, rsize_t bufsz,\n                  const wchar_t *restrict format, va_list vlist);\n  (7)   (since C11)\n\n   Loads the data from locations, defined by vlist, converts them to wide string equivalents and writes the results to a variety of sinks.\n\nParameters\nstream   -   output wide stream to write to\nbuffer   -   pointer to a wide string to write to\nbufsz   -   maximum number of wide characters to write\nformat   -   pointer to a null-terminated wide string specifying how to interpret the data. The format string consists of ordinary wide characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:\n\n introductory % character \n (optional) one or more flags that modify the behavior of the conversion: \n\n -: the result of the conversion is left-justified within the field (by default it is right-justified) \n +: the sign of signed conversions is always prepended to the result of the conversion (by default the result is preceded by minus only when it is negative) \n space: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result. It is ignored if + flag is present. \n # : alternative form of the conversion is performed. See the table below for exact effects otherwise the behavior is undefined. \n 0 : for integer and floating point number conversions, leading zeros are used to pad the field instead of space characters. For integer numbers it is ignored if the precision is explicitly specified. For other conversions using this flag results in undefined behavior. It is ignored if - flag is present. \n\n (optional) integer value or * that specifies minimum field width. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified. In the case when * is used, the width is specified by an additional argument of type int. If the value of the argument is negative, it results with the - flag specified and positive field width. (Note: This is the minimum width: The value is never truncated.) \n\n (optional) . followed by integer number or *, or neither that specifies precision of the conversion. In the case when * is used, the precision is specified by an additional argument of type int. If the value of this argument is negative, it is ignored. If neither a number nor * is used, the precision is taken as zero. See the table below for exact effects of precision. \n (optional) length modifier that specifies the size of the argument \n conversion format specifier \n\n The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L \n   %   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    writes a single character.  The argument is first converted to wchar_t as if by calling btowc. If the l modifier is used, the wint_t argument is first converted to wchar_t.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A \n   s    writes a character string The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to mbrtowc with zero-initialized conversion state. Precision specifies the maximum number of wide characters to be written. If Precision is not specified, writes every wide characters up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   d i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A \n   o   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A \n   x X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A \n   u   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A \n   f F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C99)\n   N/A   N/A   N/A   N/A   long double \n   e E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   a A (C99).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   g G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A \n   n   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A \n   p   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A \n\n The floating point conversion functions convert infinity to inf or infinity. Which one is used is implementation defined.\nNot-a-number is converted to nan or nan(char_sequence). Which one is used is implementation defined.\nThe conversions F, E, G, A output INF, INFINITY, NAN instead.\nEven though %c expects int argument, it is safe to pass a char because of the integer promotion that takes place when a variadic function is called.\nThe correct conversion specifications for the fixed-width character types (int8_t, etc) are defined in the header <inttypes.h> (although PRIdMAX, PRIuMAX, etc is synonymous with %jd, %ju, etc).\nThe memory-writing conversion specifier %n is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked printf_s family of functions.\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple %n results in the same variable or, as an edge case, printing a string modified by an earlier %n within the same call.\nIf a conversion specification is invalid, the behavior is undefined.\nConversion specifier   Explanation   Argument type\nlength modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L\n%   writes literal %. The full conversion specification must be %%.   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A\nc    writes a single character.  The argument is first converted to wchar_t as if by calling btowc. If the l modifier is used, the wint_t argument is first converted to wchar_t.\n  N/A   N/A   int   wint_t   N/A   N/A   N/A   N/A   N/A\ns    writes a character string The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to mbrtowc with zero-initialized conversion state. Precision specifies the maximum number of wide characters to be written. If Precision is not specified, writes every wide characters up to and not including the first null terminator. If the l specifier is used, the argument must be a pointer to the initial element of an array of wchar_t.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A\nd i   converts a signed integer into decimal representation [-]dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  signed char   short   int   long   long long   intmax_t   signed size_t\n   ptrdiff_t   N/A\no   converts a unsigned integer into octal representation oooo.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are \u200b0\u200b, single \u200b0\u200b is written.\n  unsigned char   unsigned short   unsigned int   unsigned long   unsigned long long   uintmax_t   size_t   unsigned version of ptrdiff_t\n   N/A\nx X   converts an unsigned integer into hexadecimal representation hhhh.  For the x conversion letters abcdef are used. For the X conversion letters ABCDEF are used. Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters. In the alternative implementation 0x or 0X is prefixed to results if the converted value is nonzero.\n  N/A\nu   converts an unsigned integer into decimal representation dddd.  Precision specifies the minimum number of digits to appear. The default precision is 1. If both the converted value and the precision are \u200b0\u200b the conversion results in no characters.\n  N/A\nf F   converts floating-point number to the decimal notation in the style [-]ddd.ddd.  Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   double   \ndouble (C99)\n   N/A   N/A   N/A   N/A   long double\ne E   converts floating-point number to the decimal exponent notation.  For the e conversion style [-]d.ddde\u00b1dd is used. For the E conversion style [-]d.dddE\u00b1dd is used. The exponent contains at least two digits, more digits are used only if necessary. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\na A (C99).\n  converts floating-point number to the hexadecimal exponent notation.  For the a conversion style [-]0xh.hhhp\u00b1d is used. For the A conversion style [-]0Xh.hhhP\u00b1d is used. The first hexadecimal digit is not 0 if the argument is a normalized floating point value. If the value is \u200b0\u200b, the exponent is also \u200b0\u200b. Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is sufficient for exact representation of the value. In the alternative implementation decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\ng G   converts floating-point number to decimal or decimal exponent notation depending on the value and the precision.  For the g conversion style conversion with style e or f will be performed. For the G conversion style conversion with style E or F will be performed. Let P equal the precision if nonzero, 6 if the precision is not specified, or 1 if the precision is \u200b0\u200b. Then, if a conversion with style E would have an exponent of X:\n\n if P > X \u2265 \u22124, the conversion is with style f or F and precision P \u2212 1 \u2212 X. \n otherwise, the conversion is with style e or E and precision P \u2212 1. \n Unless alternative representation is requested the trailing zeros are removed, also the decimal point character is removed if no fractional part is left. For infinity and not-a-number conversion style see notes.\n  N/A   N/A   N/A   N/A   N/A   N/A\nn   returns the number of characters written so far by this call to the function.  The result is written to the value pointed to by the argument. The specification may not contain any flag, field width, or precision.\n  signed char*   short*   int*   long*   long long*   intmax_t*   signed size_t*\n   ptrdiff_t*   N/A\np   writes an implementation defined character sequence defining a pointer.   N/A   N/A   void*   N/A   N/A   N/A   N/A   N/A   N/A\nvlist   -   variable argument list containing the data to print\n\n\nReturn value\n\nNotes\n   All these functions invoke va_arg at least once, the value of arg is indeterminate after the return. These functions to not invoke va_end, and it must be done by the caller.\n   While narrow strings provide vsnprintf, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings (until C11's vsnwprintf_s), and in order to determine the buffer size, the program may need to call vswprintf, check the result value, and reallocate a larger buffer, trying again until successful.\n   vsnwprintf_s, unlike vswprintf_s, will truncate the result to fit within the array pointed to by buffer, even though truncation is treated as an error by most bounds-checked functions.\n", "url": "https://devdocs.io/c/io/vfwprintf\n"}, {"name": "vwscanf, vfwscanf, vswscanf, vwscanf_s, vfwscanf_s, vswscanf_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint vwscanf( const wchar_t *restrict format, va_list vlist );\n  (1)   (since C99)\nint vfwscanf( FILE *restrict stream,\n              const wchar_t *restrict format, va_list vlist );\n  (2)   (since C99)\nint vswscanf( const wchar_t *restrict buffer,\n              const wchar_t *restrict format, va_list vlist );\n  (3)   (since C99)\nint vwscanf_s( const wchar_t *restrict format, va_list vlist );\n  (4)   (since C11)\nint vfwscanf_s( FILE *restrict stream,\n                const wchar_t *restrict format, va_list vlist );\n  (5)   (since C11)\nint vswscanf_s( const wchar_t *restrict buffer,\n                const wchar_t *restrict format, va_list vlist );\n  (6)   (since C11)\n\n   Reads data from the a variety of sources, interprets it according to format and stores the results into locations defined by vlist.\n\nParameters\nstream   -   input file stream to read from\nbuffer   -   pointer to a null-terminated wide string to read from\nformat   -   pointer to a null-terminated wide string specifying how to read the input. The format string consists of \n non-whitespace wide characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal. \n whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling iswspace in a loop). Note that there is no difference between \"\\n\", \" \", \"\\t\\t\", or other whitespace in the format string. \n conversion specifications. Each conversion specification has the following format: \n\n introductory % character \n (optional) assignment-suppressing character *. If this option is present, the function does not assign the result of the conversion to any receiving argument. \n (optional) integer number (greater than zero) that specifies maximum field width, that is, the maximum number of characters that the function is allowed to consume when doing the conversion specified by the current conversion specification. Note that %s and %[ may lead to buffer overflow if the width is not provided. \n (optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type. This affects the conversion accuracy and overflow rules. The default destination type is different for each conversion type (see table below). \n conversion format specifier \n\n The following format specifiers are available:\n   Conversion specifier   Explanation   Argument type \n   length modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L \n   %   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A \n   c    matches a character or a sequence of characters If a width specifier is used, matches exactly width wide characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A \n   s    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   [set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n\n   d   matches a decimal integer.  The format of the number is the same as expected by wcstol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A \n   i   matches an integer.  The format of the number is the same as expected by wcstol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\n\n   u   matches an unsigned decimal integer.  The format of the number is the same as expected by wcstoul() with the value 10 for the base argument.\n\n   o   matches an unsigned octal integer.  The format of the number is the same as expected by wcstoul() with the value 8 for the base argument.\n\n   x, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by wcstoul() with the value 16 for the base argument.\n\n   n   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\n\n   a, A(C99) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by wcstof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double* \n   p   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A \n\n For every conversion specifier other than n, the longest sequence of input characters which does not exceed any speci\ufb01ed \ufb01eld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The \ufb01rst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-\ufb01le, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.\nAll conversion specifiers other than [, c, and n consume and discard all leading whitespace characters (determined as if by calling iswspace) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.\nIf the length specifier l is not used, the conversion specifiers c, s, and [ perform wide-to-multibyte character conversion as if by calling wcrtomb() with an mbstate_t object initialized to zero before the first character is converted.\nThe conversion specifiers s and [ always store the null terminator in addition to the matched characters. The size of the destination array must be at least one greater than the specified field width. The use of %s or %[, without specifying the destination array size, is as unsafe as gets.\nThe correct conversion specifications for the fixed-width integer types (int8_t, etc) are defined in the header <inttypes.h> (although SCNdMAX, SCNuMAX, etc is synonymous with %jd, %ju, etc).\nThere is a sequence point after the action of each conversion specifier; this permits storing multiple fields in the same \"sink\" variable.\nWhen parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing \"100er\" with the conversion specifier %f, the sequence \"100e\" (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with \"r\" remaining. Some existing implementations do not follow this rule and roll back to consume only \"100\", leaving \"er\", e.g. glibc bug 1765.\nConversion specifier   Explanation   Argument type\nlength modifier   hh (C99).\n  h   (none)   l   ll (C99).\n  j (C99).\n  z (C99).\n  t (C99).\n  L\n%   matches literal %   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A   N/A\nc    matches a character or a sequence of characters If a width specifier is used, matches exactly width wide characters (the argument must be a pointer to an array with sufficient room). Unlike %s and %[, does not append the null character to the array.\n  N/A   N/A   char*   wchar_t*   N/A   N/A   N/A   N/A   N/A\ns    matches a sequence of non-whitespace characters (a string)  If width specifier is used, matches up to width or until the first whitespace character, whichever appears first. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\n[set]   matches a non-empty sequence of character from set of characters.  If the first character of the set is ^, then all characters not in the set are matched. If the set begins with ] or ^] then the ] character is also included into the set. It is implementation-defined whether the character - in the non-initial position in the scanset may be indicating a range, as in [0-9]. If width specifier is used, matches only up to width. Always stores a null character in addition to the characters matched (so the argument array must have room for at least width+1 characters).\nd   matches a decimal integer.  The format of the number is the same as expected by wcstol() with the value 10 for the base argument.\n  \nsigned char* or unsigned char*\n   \nsigned short* or unsigned short*\n   \nsigned int* or unsigned int*\n   \nsigned long* or unsigned long*\n   \nsigned long long* or unsigned long long*\n   \nintmax_t* or uintmax_t*\n   size_t*   ptrdiff_t*   N/A\ni   matches an integer.  The format of the number is the same as expected by wcstol() with the value \u200b0\u200b for the base argument (base is determined by the first characters parsed).\nu   matches an unsigned decimal integer.  The format of the number is the same as expected by wcstoul() with the value 10 for the base argument.\no   matches an unsigned octal integer.  The format of the number is the same as expected by wcstoul() with the value 8 for the base argument.\nx, X   matches an unsigned hexadecimal integer.  The format of the number is the same as expected by wcstoul() with the value 16 for the base argument.\nn   returns the number of characters read so far.  No input is consumed. Does not increment the assignment count. If the specifier has assignment-suppressing operator defined, the behavior is undefined.\na, A(C99) e, E f, F g, G   matches a floating-point number.  The format of the number is the same as expected by wcstof().\n  N/A   N/A   float*   double*   N/A   N/A   N/A   N/A   long double*\np   matches implementation defined character sequence defining a pointer.  printf family of functions should produce the same sequence using %p format specifier.\n  N/A   N/A   void**   N/A   N/A   N/A   N/A   N/A   N/A\nvlist   -   variable argument list containing the receiving arguments\n\n\nReturn value\n\nNotes\n   All these functions may invoke va_arg, the value of arg is indeterminate after the return. These functions to not invoke va_end, and it must be done by the caller.\n", "url": "https://devdocs.io/c/io/vfwscanf\n"}, {"name": "lconv", "type": "STANDARD LIB", "description": "Defined in header <locale.h>\nstruct lconv;\n\n   The struct lconv contains numeric and monetary formatting rules as defined by a C locale. Objects of this struct may be obtained with localeconv. The members of lconv are values of type char and of type char*. Each char* member except decimal_point may be pointing at a null character (that is, at an empty C-string). The members of type char are all non-negative numbers, any of which may be CHAR_MAX if the corresponding value is not available in the current C locale.\n\nMember objects\nchar* decimal_point   the character used as the decimal point  (public member object)\nchar* thousands_sep   the character used to separate groups of digits before the decimal point  (public member object)\nchar* grouping   a string whose elements indicate the sizes of digit groups  (public member object)\n\nchar* mon_decimal_point   the character used as the decimal point  (public member object)\nchar* mon_thousands_sep   the character used to separate groups of digits before the decimal point  (public member object)\nchar* mon_grouping   a string whose elements indicate the sizes of digit groups  (public member object)\nchar* positive_sign   a string used to indicate non-negative monetary quantity  (public member object)\nchar* negative_sign   a string used to indicate negative monetary quantity  (public member object)\n\nchar* currency_symbol   the symbol used for currency in the current C locale  (public member object)\nchar frac_digits   the number of digits after the decimal point to display in a monetary quantity  (public member object)\nchar p_cs_precedes   1 if currency_symbol is placed before non-negative value, \u200b0\u200b if after  (public member object)\nchar n_cs_precedes   1 if currency_symbol is placed before negative value, \u200b0\u200b if after  (public member object)\nchar p_sep_by_space   indicates the separation of currency_symbol, positive_sign, and the non-negative monetary value  (public member object)\nchar n_sep_by_space   indicates the separation of currency_symbol, negative_sign, and the negative monetary value  (public member object)\nchar p_sign_posn   indicates the position of positive_sign in a non-negative monetary value  (public member object)\nchar n_sign_posn   indicates the position of negative_sign in a negative monetary value  (public member object)\n\nchar* int_curr_symbol   the string used as international currency name in the current C locale  (public member object)\nchar int_frac_digits   the number of digits after the decimal point to display in an international monetary quantity  (public member object)\nchar int_p_cs_precedes\n(C99)   1 if int_curr_symbol is placed before non-negative international monetary value, \u200b0\u200b if after  (public member object)\nchar int_n_cs_precedes\n(C99)   1 if int_curr_symbol is placed before negative international monetary value, \u200b0\u200b if after  (public member object)\nchar int_p_sep_by_space\n(C99)   indicates the separation of int_curr_symbol, positive_sign, and the non-negative international monetary value  (public member object)\nchar int_n_sep_by_space\n(C99)   indicates the separation of int_curr_symbol, negative_sign, and the negative international monetary value  (public member object)\nchar int_p_sign_posn\n(C99)   indicates the position of positive_sign in a non-negative international monetary value  (public member object)\nchar int_n_sign_posn\n(C99)   indicates the position of negative_sign in a negative international monetary value  (public member object)\n\n   The characters of the C-strings pointed to by grouping and mon_grouping are interpreted according to their numeric values. When the terminating '\\0' is encountered, the last value seen is assumed to repeat for the remainder of digits. If CHAR_MAX is encountered, no further digits are grouped. the typical grouping of three digits at a time is \"\\003\".\n   The values of p_sep_by_space, n_sep_by_space, int_p_sep_by_space, int_n_sep_by_space are interpreted as follows:\n0   no space separates the currency symbol and the value\n1   sign sticks to the currency symbol, value is separated by a space\n2   sign sticks to the value. Currency symbol is separated by a space\n\n   The values of p_sign_posn, n_sign_posn, int_p_sign_posn, int_n_sign_posn are interpreted as follows:\n0   parentheses around the value and the currency symbol are used to represent the sign\n1   sign before the value and the currency symbol\n2   sign after the value and the currency symbol\n3   sign before the currency symbol\n4   sign after the currency symbol\n\n", "url": "https://devdocs.io/c/locale/lconv\n"}, {"name": "LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME", "type": "STANDARD LIB", "description": "Defined in header <locale.h>\n#define LC_ALL      /*implementation defined*/\n#define LC_COLLATE  /*implementation defined*/\n#define LC_CTYPE    /*implementation defined*/\n#define LC_MONETARY /*implementation defined*/\n#define LC_NUMERIC  /*implementation defined*/\n#define LC_TIME     /*implementation defined*/\n\n   Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of setlocale.\nConstant   Explanation\nLC_ALL   selects the entire C locale\nLC_COLLATE   selects the collation category of the C locale\nLC_CTYPE   selects the character classification category of the C locale\nLC_MONETARY   selects the monetary formatting category of the C locale\nLC_NUMERIC   selects the numeric formatting category of the C locale\nLC_TIME   selects the time formatting category of the C locale\n\n   Additional macro constants, with names that begin with LC_ followed by at least one uppercase letter, may be defined in locale.h. For example, the POSIX specification requires LC_MESSAGES (which controls, among other things, perror and strerror), ISO/IEC 30112:2014 (2014 draft) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).\n", "url": "https://devdocs.io/c/locale/lc_categories\n"}, {"name": "localeconv", "type": "STANDARD LIB", "description": "Defined in header <locale.h>\nstruct lconv *localeconv(void);\n\n   The localeconv function obtains a pointer to a static object of type lconv, which represents numeric and monetary formatting rules of the current C locale.\n\nParameters\n   (none).\n\nReturn value\n   pointer to the current lconv object.\n\nNotes\n   Modifying the object references through the returned pointer is undefined behavior.\n   localeconv modifies a static object, calling it from different threads without synchronization is undefined behavior.\n", "url": "https://devdocs.io/c/locale/localeconv\n"}, {"name": "Localization support", "type": "STANDARD LIB", "description": "Defined in header <locale.h>\nsetlocale   gets and sets the current C locale  (function)\nlocaleconv   queries numeric and monetary formatting details of the current locale  (function)\nlconv   formatting details, returned by localeconv  (struct)\nLocale categories\nLC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME   locale categories for setlocale  (macro constant)\n\n", "url": "https://devdocs.io/c/locale\n"}, {"name": "setlocale", "type": "STANDARD LIB", "description": "Defined in header <locale.h>\nchar* setlocale( int category, const char* locale);\n\n   The setlocale function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to setlocale. If locale is a null pointer, setlocale queries the current C locale without modifying it.\n\nParameters\ncategory   -   locale category identifier, one of the LC_xxx macros. May be null.\nlocale   -   system-specific locale identifier. Can be \"\" for the user-preferred locale or \"C\" for the minimal locale\n\n\nReturn value\n   pointer to a narrow null-terminated string identifying the C locale after applying the changes, if any, or null pointer on failure.\n   A copy of the returned string along with the category used in this call to setlocale may be used later in the program to restore the locale back to the state at the end of this call.\n\nNotes\n   During program startup, the equivalent of setlocale(LC_ALL, \"C\"); is executed before any user code is run.\n   Although the return type is char*, modifying the pointed-to characters is undefined behavior.\n   Because setlocale modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: fprintf, isprint, iswdigit, localeconv, tolower, fscanf, ispunct, iswgraph, mblen, toupper, isalnum, isspace, iswlower, mbstowcs, towlower, isalpha, isupper, iswprint, mbtowc, towupper, isblank, iswalnum, iswpunct, setlocale, wcscoll, iscntrl, iswalpha, iswspace, strcoll, wcstod, isdigit, iswblank, iswupper, strerror, wcstombs, isgraph, iswcntrl, iswxdigit, strtod, wcsxfrm, islower, iswctype, isxdigit.\n   POSIX also defines a locale named \"POSIX\", which is always accessible and is exactly equivalent to the default minimal \"C\" locale.\n   POSIX also specifies that the returned pointer, not just the contents of the pointed-to string, may be invalidated by subsequent calls to setlocale.\n", "url": "https://devdocs.io/c/locale/setlocale\n"}, {"name": "abs, labs, llabs, imaxabs", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint        abs( int n );\nlong       labs( long n );\nlong long llabs( long long n );\n    (since C99)\nDefined in header <inttypes.h>\nintmax_t imaxabs( intmax_t n );\n    (since C99)\n\n   Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.\n\nParameters\nn   -   integer value\n\n\nReturn value\n   The absolute value of n (i.e. |n|), if it is representable.\n\nNotes\n   In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.\n", "url": "https://devdocs.io/c/numeric/math/abs\n"}, {"name": "acos, acosf, acosl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       acosf( float arg );\n  (1)   (since C99)\ndouble      acos( double arg );\n  (2)\nlong double acosl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define acos( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the arc cosine of arg (arccos(arg)) in the range [0 ; \u03c0], is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error occurs if arg is outside the range [-1.0; 1.0].\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n", "url": "https://devdocs.io/c/numeric/math/acos\n"}, {"name": "acosh, acoshf, acoshl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       acoshf( float arg );\n  (1)   (since C99)\ndouble      acosh( double arg );\n  (2)   (since C99)\nlong double acoshl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define acosh( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing the area of a hyperbolic sector\n\n\nReturn value\n   If no errors occur, the inverse hyperbolic cosine of arg (cosh-1(arg), or arcosh(arg)) on the interval [0, +\u221e], is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the argument is less than 1, a domain error occurs.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   Although the C standard names this function \"arc hyperbolic cosine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic cosine\" (used by POSIX) or \"area hyperbolic cosine\".\n", "url": "https://devdocs.io/c/numeric/math/acosh\n"}, {"name": "asin, asinf, asinl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       asinf( float arg );\n  (1)   (since C99)\ndouble      asin( double arg );\n  (2)\nlong double asinl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define asin( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error occurs if arg is outside the range [-1.0; 1.0].\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n", "url": "https://devdocs.io/c/numeric/math/asin\n"}, {"name": "asinh, asinhf, asinhl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       asinhf( float arg );\n  (1)   (since C99)\ndouble      asinh( double arg );\n  (2)   (since C99)\nlong double asinhl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define asinh( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing the area of a hyperbolic sector\n\n\nReturn value\n   If no errors occur, the inverse hyperbolic sine of arg (sinh-1(arg), or arsinh(arg)), is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   Although the C standard names this function \"arc hyperbolic sine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic sine\" (used by POSIX) or \"area hyperbolic sine\".\n", "url": "https://devdocs.io/c/numeric/math/asinh\n"}, {"name": "atan, atanf, atanl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       atanf( float arg );\n  (1)   (since C99)\ndouble      atan( double arg );\n  (2)\nlong double atanl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define atan( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   POSIX specifies that in case of underflow, arg is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n", "url": "https://devdocs.io/c/numeric/math/atan\n"}, {"name": "atan2, atan2f, atan2l", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       atan2f( float y, float x );\n  (1)   (since C99)\ndouble      atan2( double y, double x );\n  (2)\nlong double atan2l( long double y, long double x );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define atan2( arg )\n  (4)   (since C99)\n\n\nParameters\nx, y   -   floating point value\n\n\nReturn value\n   If a domain error occurs, an implementation-defined value is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error may occur if x and y are both zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   atan2(y, x) is equivalent to carg(x + I*y).\n   POSIX specifies that in case of underflow, y/x is the value returned, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n", "url": "https://devdocs.io/c/numeric/math/atan2\n"}, {"name": "atanh, atanhf, atanhl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       atanhf( float arg );\n  (1)   (since C99)\ndouble      atanh( double arg );\n  (2)   (since C99)\nlong double atanhl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define atanh( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing the area of a hyperbolic sector\n\n\nReturn value\n   If no errors occur, the inverse hyperbolic tangent of arg (tanh-1(arg), or artanh(arg)), is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a pole error occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned (with the correct sign).\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the argument is not on the interval [-1, +1], a range error occurs.\n   If the argument is \u00b11, a pole error occurs.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   Although the C standard names this function \"arc hyperbolic tangent\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"inverse hyperbolic tangent\" (used by POSIX) or \"area hyperbolic tangent\".\n   POSIX specifies that in case of underflow, arg is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n", "url": "https://devdocs.io/c/numeric/math/atanh\n"}, {"name": "cabsf, cabs, cabsl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat       cabsf( float complex z );\n  (1)   (since C99)\ndouble      cabs( double complex z );\n  (2)   (since C99)\nlong double cabsl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define fabs( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, returns the absolute value (norm, magnitude) of z.\n   Errors and special cases are handled as if the function is implemented as hypot(creal(z), cimag(z)).\n", "url": "https://devdocs.io/c/numeric/complex/cabs\n"}, {"name": "cacosf, cacos, cacosl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       cacosf( float complex z );\n  (1)   (since C99)\ndouble complex      cacos( double complex z );\n  (2)   (since C99)\nlong double complex cacosl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define acos( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, complex arc cosine of z is returned, in the range [0 ; \u221e) along the real axis and in the range [\u2212i\u03c0 ; i\u03c0] along the imaginary axis.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n\nNotes\n   Inverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventially placed at the line segments (-\u221e,-1) and (1,\u221e) of the real axis.  The mathematical definition of the principal value of arc cosine is acos z =\n   For any z, acos(z) = \u03c0 - acos(-z).\n", "url": "https://devdocs.io/c/numeric/complex/cacos\n"}, {"name": "cacoshf, cacosh, cacoshl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       cacoshf( float complex z );\n  (1)   (since C99)\ndouble complex      cacosh( double complex z );\n  (2)   (since C99)\nlong double complex cacoshl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define acosh( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   The complex arc hyperbolic cosine of z in the interval [0; \u221e) along the real axis and in the interval [\u2212i\u03c0; +i\u03c0] along the imaginary axis.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n\nNotes\n   Although the C standard names this function \"complex arc hyperbolic cosine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic cosine\", and, less common, \"complex area hyperbolic cosine\".\n   Inverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-\u221e,+1) of the real axis.\n   The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + \u221az+1 \u221az-1)  For any z, acosh(z) =\n", "url": "https://devdocs.io/c/numeric/complex/cacosh\n"}, {"name": "cargf, carg, cargl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat       cargf( float complex z );\n  (1)   (since C99)\ndouble      carg( double complex z );\n  (2)   (since C99)\nlong double cargl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define carg( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, returns the phase angle of z in the interval [\u2212\u03c0; \u03c0].\n   Errors and special cases are handled as if the function is implemented as atan2(cimag(z), creal(z)).\n", "url": "https://devdocs.io/c/numeric/complex/carg\n"}, {"name": "casinf, casin, casinl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       casinf( float complex z );\n  (1)   (since C99)\ndouble complex      casin( double complex z );\n  (2)   (since C99)\nlong double complex casinl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define asin( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, complex arc sine of z is returned, in the range of a strip unbounded along the imaginary axis and in the interval [\u2212\u03c0/2; +\u03c0/2] along the real axis.\n   Errors and special cases are handled as if the operation is implemented by -I * casinh(I*z).\n\nNotes\n   Inverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-\u221e,-1) and (1,\u221e) of the real axis.\n   The mathematical definition of the principal value of arc sine is asin z = -iln(iz + \u221a1-z2)  For any z, asin(z) = acos(-z) -\n", "url": "https://devdocs.io/c/numeric/complex/casin\n"}, {"name": "casinhf, casinh, casinhl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       casinhf( float complex z );\n  (1)   (since C99)\ndouble complex      casinh( double complex z );\n  (2)   (since C99)\nlong double complex casinhl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define asinh( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, the complex arc hyperbolic sine of z is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [\u2212i\u03c0/2; +i\u03c0/2] along the imaginary axis.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n\nNotes\n   Although the C standard names this function \"complex arc hyperbolic sine\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic sine\", and, less common, \"complex area hyperbolic sine\".\n   Inverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-i\u221e,-i) and (i,i\u221e) of the imaginary axis.\n   The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + \u221a1+z2)  For any z, asinh(z) =\n", "url": "https://devdocs.io/c/numeric/complex/casinh\n"}, {"name": "catanf, catan, catanl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       catanf( float complex z );\n  (1)   (since C99)\ndouble complex      catan( double complex z );\n  (2)   (since C99)\nlong double complex catanl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define atan( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, complex arc tangent of z is returned, in the range of a strip unbounded along the imaginary axis and in the interval [\u2212\u03c0/2; +\u03c0/2] along the real axis.\n   Errors and special cases are handled as if the operation is implemented by -I * catanh(I*z).\n\nNotes\n   Inverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-\u221ei,-i) and (+i,+\u221ei) of the imaginary axis.  The mathematical definition of the principal value of inverse tangent is atan z = -\n", "url": "https://devdocs.io/c/numeric/complex/catan\n"}, {"name": "catanhf, catanh, catanhl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       catanhf( float complex z );\n  (1)   (since C99)\ndouble complex      catanh( double complex z );\n  (2)   (since C99)\nlong double complex catanhl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define atanh( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, the complex arc hyperbolic tangent of z is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [\u2212i\u03c0/2; +i\u03c0/2] along the imaginary axis.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n\nNotes\n   Although the C standard names this function \"complex arc hyperbolic tangent\", the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is \"complex inverse hyperbolic tangent\", and, less common, \"complex area hyperbolic tangent\".\n   Inverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-\u221e,-1] and [+1,+\u221e) of the real axis.  The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =\n   For any z, atanh(z) =\n", "url": "https://devdocs.io/c/numeric/complex/catanh\n"}, {"name": "cbrt, cbrtf, cbrtl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       cbrtf( float arg );\n  (1)   (since C99)\ndouble      cbrt( double arg );\n  (2)   (since C99)\nlong double cbrtl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define cbrt( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the cubic root of arg (3\u221aarg), is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   cbrt(arg) is not equivalent to pow(arg, 1.0/3) because pow cannot raise a negative base to a fractional exponent.\n", "url": "https://devdocs.io/c/numeric/math/cbrt\n"}, {"name": "ccosf, ccos, ccosl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       ccosf( float complex z );\n  (1)   (since C99)\ndouble complex      ccos( double complex z );\n  (2)   (since C99)\nlong double complex ccosl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define cos( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, the complex cosine of z is returned.\n   Errors and special cases are handled as if the operation is implemented by ccosh(I*z).\n\nNotes\n   The cosine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the cosine is cos z =\n", "url": "https://devdocs.io/c/numeric/complex/ccos\n"}, {"name": "ccoshf, ccosh, ccoshl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       ccoshf( float complex z );\n  (1)   (since C99)\ndouble complex      ccosh( double complex z );\n  (2)   (since C99)\nlong double complex ccoshl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define cosh( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, complex hyperbolic cosine of z is returned.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n   where cis(y) is cos(y) + i sin(y).\n\nNotes\n   Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2\u03c0i.\n", "url": "https://devdocs.io/c/numeric/complex/ccosh\n"}, {"name": "ceil, ceilf, ceill", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       ceilf( float arg );\n  (1)   (since C99)\ndouble      ceil( double arg );\n  (2)\nlong double ceill( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define ceil( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the smallest integer value not less than arg, that is \u2308arg\u2309, is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   FE_INEXACT may be (but isn't required to be) raised when rounding a non-integer finite value.\n   The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including intmax_t), when stored in an integer variable.\n   This function (for double argument) behaves as if (except for the freedom to not raise FE_INEXACT) implemented by.\n", "url": "https://devdocs.io/c/numeric/math/ceil\n"}, {"name": "cexpf, cexp, cexpl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       cexpf( float complex z );\n  (1)   (since C99)\ndouble complex      cexp( double complex z );\n  (2)   (since C99)\nlong double complex cexpl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define exp( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, e raised to the power of z, ez is returned.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n   where cis(y) is cos(y) + i sin(y).\n\nNotes\n   The complex exponential function ez for z = x+iy equals to ex cis(y), or, ex (cos(y) + i sin(y)).\n   The exponential function is an entire function in the complex plane and has no branch cuts.\n", "url": "https://devdocs.io/c/numeric/complex/cexp\n"}, {"name": "cimagf, cimag, cimagl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat       cimagf( float complex z );\n  (1)   (since C99)\ndouble      cimag( double complex z );\n  (2)   (since C99)\nlong double cimagl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define cimag( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   The imaginary part of z.\n   This function is fully specified for all possible inputs and is not subject to any errors described in math_errhandling.\n\nNotes\n   For any complex variable z, z == creal(z) + I*cimag(z).\n", "url": "https://devdocs.io/c/numeric/complex/cimag\n"}, {"name": "clogf, clog, clogl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       clogf( float complex z );\n  (1)   (since C99)\ndouble complex      clog( double complex z );\n  (2)   (since C99)\nlong double complex clogl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define log( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, the complex natural logarithm of z is returned, in the range of a strip in the interval [\u2212i\u03c0, +i\u03c0] along the imaginary axis and mathematically unbounded along the real axis.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n\nNotes\n   The natural logarithm of a complex number z with polar coordinate components (r,\u03b8) equals ln r + i(\u03b8+2n\u03c0), with the principal value ln r + i\u03b8\n", "url": "https://devdocs.io/c/numeric/complex/clog\n"}, {"name": "CMPLXF, CMPLX, CMPLXL", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       CMPLXF( float real, float imag );\n    (since C11)\ndouble complex      CMPLX( double real, double imag );\n    (since C11)\nlong double complex CMPLXL( long double real, long double imag );\n    (since C11)\n\n   Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of real (converted to the specified argument type) and the imaginary part having the value of imag (converted to the specified argument type).\n   The expressions are suitable for use as initializers for objects with static or thread storage duration, as long as the expressions real and imag are also suitable.\n\nParameters\nreal   -   the real part of the complex number to return\nimag   -   the imaginary part of the complex number to return\n\n\nReturn value\n   A complex number composed of real and imag as the real and imaginary parts.\n\nNotes\n   These macros are implemented as if the imaginary types are supported (even if they are otherwise not supported and _Imaginary_I is actually undefined) and as if defined as follows:\n", "url": "https://devdocs.io/c/numeric/complex/cmplx\n"}, {"name": "Common mathematical functions", "type": "STANDARD LIB", "description": "\nFunctions\nDefined in header <stdlib.h>\nabslabsllabs\n(C99)   computes absolute value of an integral value (|x|)  (function)\ndivldivlldiv\n(C99)   computes quotient and remainder of integer division  (function)\nDefined in header <inttypes.h>\nimaxabs\n(C99)   computes absolute value of an integral value (|x|)  (function)\nimaxdiv\n(C99)   computes quotient and remainder of integer division  (function)\nDefined in header <math.h>\nBasic operations\nfabsfabsffabsl\n(C99)(C99)   computes absolute value of a floating-point value (|x|)  (function)\nfmodfmodffmodl\n(C99)(C99)   computes remainder of the floating-point division operation  (function)\nremainderremainderfremainderl\n(C99)(C99)(C99)   computes signed remainder of the floating-point division operation  (function)\nremquoremquofremquol\n(C99)(C99)(C99)   computes signed remainder as well as the three last bits of the division operation  (function)\nfmafmaffmal\n(C99)(C99)(C99)   computes fused multiply-add operation  (function)\nfmaxfmaxffmaxl\n(C99)(C99)(C99)   determines larger of two floating-point values  (function)\nfminfminffminl\n(C99)(C99)(C99)   determines smaller of two floating-point values  (function)\nfdimfdimffdiml\n(C99)(C99)(C99)   determines positive difference of two floating-point values (max(0, x-y))  (function)\nnannanfnanl\n(C99)(C99)(C99)   returns a NaN (not-a-number)  (function)\nExponential functions\nexpexpfexpl\n(C99)(C99)   computes e raised to the given power (ex)  (function)\nexp2exp2fexp2l\n(C99)(C99)(C99)   computes 2 raised to the given power (2x)  (function)\nexpm1expm1fexpm1l\n(C99)(C99)(C99)   computes e raised to the given power, minus one (ex-1)  (function)\nloglogflogl\n(C99)(C99)   computes natural (base-e) logarithm (ln(x))  (function)\nlog10log10flog10l\n(C99)(C99)   computes common (base-10) logarithm (log10(x))  (function)\nlog2log2flog2l\n(C99)(C99)(C99)   computes base-2 logarithm (log2(x))  (function)\nlog1plog1pflog1pl\n(C99)(C99)(C99)   computes natural (base-e) logarithm of 1 plus the given number (ln(1+x))  (function)\nPower functions\npowpowfpowl\n(C99)(C99)   computes a number raised to the given power (xy)  (function)\nsqrtsqrtfsqrtl\n(C99)(C99)   computes square root (\u221ax)  (function)\ncbrtcbrtfcbrtl\n(C99)(C99)(C99)   computes cubic root (3\u221ax)  (function)\nhypothypotfhypotl\n(C99)(C99)(C99)   computes square root of the sum of the squares of two given numbers (\u221ax2+y2)  (function)\nTrigonometric functions\nsinsinfsinl\n(C99)(C99)   computes sine (sin(x))  (function)\ncoscosfcosl\n(C99)(C99)   computes cosine (cos(x))  (function)\ntantanftanl\n(C99)(C99)   computes tangent (tan(x))  (function)\nasinasinfasinl\n(C99)(C99)   computes arc sine (arcsin(x))  (function)\nacosacosfacosl\n(C99)(C99)   computes arc cosine (arccos(x))  (function)\natanatanfatanl\n(C99)(C99)   computes arc tangent (arctan(x))  (function)\natan2atan2fatan2l\n(C99)(C99)   computes arc tangent, using signs to determine quadrants  (function)\nHyperbolic functions\nsinhsinhfsinhl\n(C99)(C99)   computes hyperbolic sine (sh(x))  (function)\ncoshcoshfcoshl\n(C99)(C99)   computes hyperbolic cosine (ch(x))  (function)\ntanhtanhftanhl\n(C99)(C99)   computes hyperbolic tangent  (function)\nasinhasinhfasinhl\n(C99)(C99)(C99)   computes inverse hyperbolic sine (arsinh(x))  (function)\nacoshacoshfacoshl\n(C99)(C99)(C99)   computes inverse hyperbolic cosine (arcosh(x))  (function)\natanhatanhfatanhl\n(C99)(C99)(C99)   computes inverse hyperbolic tangent (artanh(x))  (function)\nError and gamma functions\nerferfferfl\n(C99)(C99)(C99)   computes error function  (function)\nerfcerfcferfcl\n(C99)(C99)(C99)   computes complementary error function  (function)\ntgammatgammaftgammal\n(C99)(C99)(C99)   computes gamma function  (function)\nlgammalgammaflgammal\n(C99)(C99)(C99)   computes natural (base-e) logarithm of the gamma function  (function)\nNearest integer floating-point operations\nceilceilfceill\n(C99)(C99)   computes smallest integer not less than the given value  (function)\nfloorfloorffloorl\n(C99)(C99)   computes largest integer not greater than the given value  (function)\ntrunctruncftruncl\n(C99)(C99)(C99)   rounds to nearest integer not greater in magnitude than the given value  (function)\nroundlroundllround\n(C99)(C99)(C99)   rounds to nearest integer, rounding away from zero in halfway cases  (function)\nnearbyintnearbyintfnearbyintl\n(C99)(C99)(C99)   rounds to an integer using current rounding mode  (function)\nrintrintfrintllrintlrintflrintlllrintllrintfllrintl\n(C99)(C99)(C99)(C99)(C99)(C99)(C99)(C99)(C99)   rounds to an integer using current rounding mode with  exception if the result differs  (function)\nFloating-point manipulation functions\nfrexpfrexpffrexpl\n(C99)(C99)   breaks a number into significand and a power of 2  (function)\nldexpldexpfldexpl\n(C99)(C99)   multiplies a number by 2 raised to a power  (function)\nmodfmodffmodfl\n(C99)(C99)   breaks a number into integer and fractional parts  (function)\nscalbnscalbnfscalbnlscalblnscalblnfscalblnl\n(C99)(C99)(C99)(C99)(C99)(C99)   computes efficiently a number times FLT_RADIX raised to a power  (function)\nilogbilogbfilogbl\n(C99)(C99)(C99)   extracts exponent of the given number  (function)\nlogblogbflogbl\n(C99)(C99)(C99)   extracts exponent of the given number  (function)\nnextafternextafterfnextafterlnexttowardnexttowardfnexttowardl\n(C99)(C99)(C99)(C99)(C99)(C99)   determines next representable floating-point value towards the given value  (function)\ncopysigncopysignfcopysignl\n(C99)(C99)(C99)   produces a value with the magnitude of a given value and the sign of another given value  (function)\nClassification and comparison\nfpclassify\n(C99)   classifies the given floating-point value  (function)\nisfinite\n(C99)   checks if the given number has finite value  (function)\nisinf\n(C99)   checks if the given number is infinite  (function)\nisnan\n(C99)   checks if the given number is NaN  (function)\nisnormal\n(C99)   checks if the given number is normal  (function)\nsignbit\n(C99)   checks if the given number is negative  (function)\nisgreater\n(C99)   checks if the first floating-point argument is greater than the second  (function)\nisgreaterequal\n(C99)   checks if the first floating-point argument is greater or equal than the second  (function)\nisless\n(C99)   checks if the first floating-point argument is less than the second  (function)\nislessequal\n(C99)   checks if the first floating-point argument is less or equal than the second  (function)\nislessgreater\n(C99)   checks if the first floating-point argument is less or greater than the second  (function)\nisunordered\n(C99)   checks if two floating-point values are unordered  (function)\n\n\nTypes\nDefined in header <stdlib.h>\ndiv_t   structure type, return of the div function  (typedef)\nldiv_t   structure type, return of the ldiv function  (typedef)\nlldiv_t\n(C99)   structure type, return of the lldiv function  (typedef)\nDefined in header <inttypes.h>\nimaxdiv_t\n(C99)   structure type, return of the imaxdiv function  (typedef)\nDefined in header <math.h>\nfloat_t\n(C99)   most efficient floating-point type at least as wide as float  (typedef)\ndouble_t\n(C99)   most efficient floating-point type at least as wide as double  (typedef)\n\n\nMacro constants\nDefined in header <math.h>\nHUGE_VALFHUGE_VALHUGE_VALL\n(C99)(C99)   indicates value too big to be representable (infinity) by float, double and long double respectively  (macro constant)\nINFINITY\n(C99)   evaluates to positive infinity or the value guaranteed to overflow a float  (macro constant)\nNAN\n(C99)   evaluates to a quiet NaN of type float  (macro constant)\nFP_FAST_FMAFFP_FAST_FMAFP_FAST_FMAL\n(C99)(C99)(C99)   indicates that the fma function generally executes about as fast as, or faster than, a multiply and an add of double operands  (macro constant)\nFP_ILOGB0FP_ILOGBNAN\n(C99)(C99)   evaluates to ilogb(x) if x is zero or NaN, respectively  (macro constant)\nmath_errhandlingMATH_ERRNOMATH_ERREXCEPT\n(C99)(C99)(C99)   defines the error handling mechanism used by the common mathematical functions  (macro constant)\nClassification\nFP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN\n(C99)(C99)(C99)(C99)(C99)   indicates a floating-point category  (macro constant)\n\n", "url": "https://devdocs.io/c/numeric/math\n"}, {"name": "complex", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\n#define complex _Complex\n    (since C99)\n\n   This macro expands to a type specifier used to identify complex types.\n   A program may undefine and perhaps then redefine the complex macro.\n", "url": "https://devdocs.io/c/numeric/complex/complex\n"}, {"name": "Complex number arithmetic", "type": "STANDARD LIB", "description": "If the macro constant __STDC_NO_COMPLEX__ is defined by the implementation, the complex types, the header <complex.h> and all of the names listed here are not provided.\n (since C11)\n\n   The C programming language, as of C99, supports complex number math with the three built-in types double _Complex, float _Complex, and long double _Complex (see _Complex). When the header <complex.h> is included, the three complex number types are also accessible as double complex, float complex, long double complex.\n   In addition to the complex types, the three imaginary types may be supported: double _Imaginary, float _Imaginary, and long double _Imaginary (see _Imaginary). When the header <complex.h> is included, the three imaginary types are also accessible as double imaginary, float imaginary, and long double imaginary.\n   Standard arithmetic operators +, -, *, / can be used with real, complex, and imaginary types in any combination.\nA compiler that defines __STDC_IEC_559_COMPLEX__ is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro _Imaginary_I is defined to identify imaginary number support.\n \n(since C99)(until C11)\nImaginary numbers are supported if __STDC_IEC_559_COMPLEX__ is defined.\n (since C11)\n\nDefined in header <complex.h>\nTypes\nimaginary\n(C99)   imaginary type macro  (keyword macro)\ncomplex\n(C99)   complex type macro  (keyword macro)\nThe imaginary constant\n_Imaginary_I\n(C99)   the imaginary unit constant i  (macro constant)\n_Complex_I\n(C99)   the complex unit constant i  (macro constant)\nI\n(C99)   the complex or imaginary unit constant i  (macro constant)\nManipulation\nCMPLXCMPLXFCMPLXL\n(C11)(C11)(C11)   constructs a complex number from real and imaginary parts  (function macro)\ncrealcrealfcreall\n(C99)(C99)(C99)   computes the real part of a complex number  (function)\ncimagcimagfcimagl\n(C99)(C99)(C99)   computes the imaginary part a complex number  (function)\ncabscabsfcabsl\n(C99)(C99)(C99)   computes the magnitude of a complex number  (function)\ncargcargfcargl\n(C99)(C99)(C99)   computes the phase angle of a complex number  (function)\nconjconjfconjl\n(C99)(C99)(C99)   computes the complex conjugate  (function)\ncprojcprojfcprojl\n(C99)(C99)(C99)   computes the projection on Riemann sphere  (function)\nExponential functions\ncexpcexpfcexpl\n(C99)(C99)(C99)   computes the complex base-e exponential  (function)\nclogclogfclogl\n(C99)(C99)(C99)   computes the complex natural logarithm  (function)\nPower functions\ncpowcpowfcpowl\n(C99)(C99)(C99)   computes the complex power function  (function)\ncsqrtcsqrtfcsqrtl\n(C99)(C99)(C99)   computes the complex square root  (function)\nTrigonometric functions\ncsincsinfcsinl\n(C99)(C99)(C99)   computes the complex sine  (function)\nccosccosfccosl\n(C99)(C99)(C99)   computes the complex cosine  (function)\nctanctanfctanl\n(C99)(C99)(C99)   computes the complex tangent  (function)\ncasincasinfcasinl\n(C99)(C99)(C99)   computes the complex arc sine  (function)\ncacoscacosfcacosl\n(C99)(C99)(C99)   computes the complex arc cosine  (function)\ncatancatanfcatanl\n(C99)(C99)(C99)   computes the complex arc tangent  (function)\nHyperbolic functions\ncsinhcsinhfcsinhl\n(C99)(C99)(C99)   computes the complex hyperbolic sine  (function)\nccoshccoshfccoshl\n(C99)(C99)(C99)   computes the complex hyperbolic cosine  (function)\nctanhctanhfctanhl\n(C99)(C99)(C99)   computes the complex hyperbolic tangent  (function)\ncasinhcasinhfcasinhl\n(C99)(C99)(C99)   computes the complex arc hyperbolic sine  (function)\ncacoshcacoshfcacoshl\n(C99)(C99)(C99)   computes the complex arc hyperbolic cosine  (function)\ncatanhcatanhfcatanhl\n(C99)(C99)(C99)   computes the complex arc hyperbolic tangent  (function)\n\n\nNotes\n   The following function names are reserved for future addition to complex.h and are not available for use in the programs that include that header: cerf, cerfc, cexp2, cexpm1, clog10, clog1p, clog2, clgamma, and ctgamma, along with their -f and -l suffixed variants.\n   Although the C standard names the inverse hyperbolics with \"complex arc hyperbolic sine\" etc., the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct names are \"complex inverse hyperbolic sine\" etc. Some authors use \"complex area hyperbolic sine\" etc.\n   A complex or imaginary number is infinite if one of its components is infinite, even if the other component is NaN.\n   A complex or imaginary number is finite if both components are neither infinities nor NaNs.\n   A complex or imaginary number is a zero if both components are positive or negative zeroes.\n", "url": "https://devdocs.io/c/numeric/complex\n"}, {"name": "conjf, conj, conjl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       conjf( float complex z );\n  (1)   (since C99)\ndouble complex      conj( double complex z );\n  (2)   (since C99)\nlong double complex conjl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define conj( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   The complex conjugate of z.\n\nNotes\n   On C99 implementations that do not implement I as _Imaginary_I, conj may be used to obtain complex numbers with negative zero imaginary part. In C11, the macro CMPLX is used for that purpose.\n", "url": "https://devdocs.io/c/numeric/complex/conj\n"}, {"name": "copysign, copysignf, copysignl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       copysignf( float x, float y );\n  (1)   (since C99)\ndouble      copysign( double x, double y );\n  (2)   (since C99)\nlong double copysignl( long double x, long double y );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define copysign(x, y)\n  (4)   (since C99)\n\n\nParameters\nx, y   -   floating point values\n\n\nReturn value\n   If no errors occur, the floating point value with the magnitude of x and the sign of y is returned.\n   If x is NaN, then NaN with the sign of y is returned.\n   If y is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.\n\nError handling\n   This function is not subject to any errors specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   copysign is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, signbit may also be used).\n", "url": "https://devdocs.io/c/numeric/math/copysign\n"}, {"name": "cos, cosf, cosl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       cosf( float arg );\n  (1)   (since C99)\ndouble      cos( double arg );\n  (2)\nlong double cosl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define cos( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing angle in radians\n\n\nReturn value\n   If no errors occur, the cosine of arg (cos(arg)) in the range [-1 ; +1], is returned.\nThe result may have little or no significance if the magnitude of arg is large.\n (until C++11)\n\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a domain error in POSIX.\n", "url": "https://devdocs.io/c/numeric/math/cos\n"}, {"name": "cosh, coshf, coshl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       coshf( float arg );\n  (1)   (since C99)\ndouble      cosh( double arg );\n  (2)\nlong double coshl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define cosh( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing a hyperbolic angle\n\n\nReturn value\n   If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   For the IEEE-compatible type double, if |arg| > 710.5, then cosh(arg) overflows.\n", "url": "https://devdocs.io/c/numeric/math/cosh\n"}, {"name": "cpowf, cpow, cpowl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       cpowf( float complex x, float complex y );\n  (1)   (since C99)\ndouble complex      cpow( double complex x, double complex y );\n  (2)   (since C99)\nlong double complex cpowl( long double complex x, long double complex y );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define pow( x, y )\n  (4)   (since C99)\n\n\nParameters\nx, y   -   complex argument\n\n\nReturn value\n   If no errors occur, the complex power xy, is returned.\n   Errors and special cases are handled as if the operation is implemented by cexp(y*clog(x)), except that the implementation is allowed to treat special cases more carefully.\n", "url": "https://devdocs.io/c/numeric/complex/cpow\n"}, {"name": "cprojf, cproj, cprojl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat       cprojf( float complex z );\n  (1)   (since C99)\ndouble      cproj( double complex z );\n  (2)   (since C99)\nlong double cprojl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define cproj( z )\n  (4)   (since C99)\n\n   For most z, cproj(z)==z, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, INFINITY+0.0*I or INFINITY-0.0*I. The sign of the imaginary (zero) component is the sign of cimag(z).\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   The projection of z on the Riemann sphere.\n   This function is fully specified for all possible inputs and is not subject to any errors described in math_errhandling.\n\nNotes\n   The cproj function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.\n", "url": "https://devdocs.io/c/numeric/complex/cproj\n"}, {"name": "crealf, creal, creall", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat       crealf( float complex z );\n  (1)   (since C99)\ndouble      creal( double complex z );\n  (2)   (since C99)\nlong double creall( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define creal( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   The real part of z.\n   This function is fully specified for all possible inputs and is not subject to any errors described in math_errhandling.\n\nNotes\n   For any complex variable z, z == creal(z) + I*cimag(z).\n", "url": "https://devdocs.io/c/numeric/complex/creal\n"}, {"name": "csinf, csin, csinl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       csinf( float complex z );\n  (1)   (since C99)\ndouble complex      csin( double complex z );\n  (2)   (since C99)\nlong double complex csinl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define sin( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, the complex sine of z.\n   Errors and special cases are handled as if the operation is implemented by -I * csinh(I*z).\n\nNotes\n   The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =\n", "url": "https://devdocs.io/c/numeric/complex/csin\n"}, {"name": "csinhf, csinh, csinhl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       csinhf( float complex z );\n  (1)   (since C99)\ndouble complex      csinh( double complex z );\n  (2)   (since C99)\nlong double complex csinhl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define sinh( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, complex hyperbolic sine of z is returned.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n   where cis(y) is cos(y) + i sin(y).\n\nNotes\n   Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2\u03c0i.\n", "url": "https://devdocs.io/c/numeric/complex/csinh\n"}, {"name": "csqrtf, csqrt, csqrtl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       csqrtf( float complex z );\n  (1)   (since C99)\ndouble complex      csqrt( double complex z );\n  (2)   (since C99)\nlong double complex csqrtl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define sqrt( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, returns the square root of z, in the range of the right half-plane, including the imaginary axis ([0; +\u221e) along the real axis and (\u2212\u221e; +\u221e) along the imaginary axis.).\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n", "url": "https://devdocs.io/c/numeric/complex/csqrt\n"}, {"name": "ctanf, ctan, ctanl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       ctanf( float complex z );\n  (1)   (since C99)\ndouble complex      ctan( double complex z );\n  (2)   (since C99)\nlong double complex ctanl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define tan( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, the complex tangent of z is returned.\n   Errors and special cases are handled as if the operation is implemented by -i * ctanh(i*z), where i is the imaginary unit.\n\nNotes\n   Tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the real component, with period \u03c0i, and has poles of the first order along the real line, at coordinates (\u03c0(1/2 + n), 0). However no common floating-point representation is able to represent \u03c0/2 exactly, thus there is no value of the argument for which a pole error occurs.  Mathematical definition of the tangent is tan z =\n", "url": "https://devdocs.io/c/numeric/complex/ctan\n"}, {"name": "ctanhf, ctanh, ctanhl", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\nfloat complex       ctanhf( float complex z );\n  (1)   (since C99)\ndouble complex      ctanh( double complex z );\n  (2)   (since C99)\nlong double complex ctanhl( long double complex z );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define tanh( z )\n  (4)   (since C99)\n\n\nParameters\nz   -   complex argument\n\n\nReturn value\n   If no errors occur, complex hyperbolic tangent of z is returned.\n\nError handling and special values\n   Errors are reported consistent with math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic,\n\nNotes\n   Hyperbolic tangent is an analytical function on the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period \u03c0i, and has poles of the first order along the imaginary line, at coordinates (0, \u03c0(1/2 + n)). However no common floating-point representation is able to represent \u03c0/2 exactly, thus there is no value of the argument for which a pole error occurs.\n", "url": "https://devdocs.io/c/numeric/complex/ctanh\n"}, {"name": "div, ldiv, lldiv, imaxdiv", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\ndiv_t     div( int x, int y );\n  (1)\nldiv_t    ldiv( long x, long y );\n  (2)\nlldiv_t   lldiv( long long x, long long y );\n  (3)   (since C99)\nDefined in header <inttypes.h>\nimaxdiv_t imaxdiv( intmax_t x, intmax_t y );\n  (4)   (since C99)\n\n   Computes both the quotient and the remainder of the division of the numerator x by the denominator y.\nComputes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that quot * y + rem == x.\n (until C99)\nComputes the quotient (the result of the expression x/y) and remainder (the result of the expression x%y) simultaneously.\n (since C99)\n\n\nParameters\nx, y   -   integer values\n\n\nReturn value\n   If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, imaxdiv_t, respectively), returns both as an object of type div_t, ldiv_t, lldiv_t, imaxdiv_t defined as follows:\n   If either the remainder or the quotient cannot be represented, the behavior is undefined.\n\nNotes\n   Until C99, the rounding direction of the quotient and the sign of the remainder in the built-in division and remainder operators was implementation-defined if either of the operands was negative, but it was well-defined in div and ldiv.\n   On many platforms, a single CPU instruction obtains both the quotient and the remainder, and this function may leverage that, although compilers are generally able to merge nearby / and % where suitable.\n", "url": "https://devdocs.io/c/numeric/math/div\n"}, {"name": "float_t, double_t", "type": "STANDARD LIB", "description": "Defined in header <math.h>\ntypedef /*implementation defined*/ float_t\n    (since C99)\ntypedef /*implementation defined*/ double_t\n    (since C99)\n\n   The types float_t and double_t are floating types at least as wide as float and double, respectively, and such that double_t is at least as wide as float_t. The value of FLT_EVAL_METHOD determines the types of float_t and double_t.\nFLT_EVAL_METHOD   Explanation\n0   float_t and double_t are equivalent to float and double, respectively\n1   both float_t and double_t are equivalent to double\n2   both float_t and double_t are equivalent to long double\nother   both float_t and double_t are implementation defined\n\n", "url": "https://devdocs.io/c/numeric/math/float_t\n"}, {"name": "erf, erff, erfl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       erff( float arg );\n  (1)   (since C99)\ndouble      erf( double arg );\n  (2)   (since C99)\nlong double erfl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define erf( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   Underflow is guaranteed if |arg| < DBL_MIN*(sqrt(\u03c0)/2).  erf(\n", "url": "https://devdocs.io/c/numeric/math/erf\n"}, {"name": "erfc, erfcf, erfcl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       erfcf( float arg );\n  (1)   (since C99)\ndouble      erfc( double arg );\n  (2)   (since C99)\nlong double erfcl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define erfc( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   For the IEEE-compatible type double, underflow is guaranteed if arg > 26.55.\n", "url": "https://devdocs.io/c/numeric/math/erfc\n"}, {"name": "exp, expf, expl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       expf( float arg );\n  (1)   (since C99)\ndouble      exp( double arg );\n  (2)\nlong double expl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define exp( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the base-e exponential of arg (earg) is returned.\n   If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   For IEEE-compatible type double, overflow is guaranteed if 709.8 < arg, and underflow is guaranteed if arg < -708.4.\n", "url": "https://devdocs.io/c/numeric/math/exp\n"}, {"name": "exp2, exp2f, exp2l", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       exp2f( float n );\n  (1)   (since C99)\ndouble      exp2( double n );\n  (2)   (since C99)\nlong double exp2l( long double n );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define exp2( n )\n  (4)   (since C99)\n\n\nParameters\nn   -   floating point value\n\n\nReturn value\n   If no errors occur, the base-2 exponential of n (2n) is returned.\n   If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n", "url": "https://devdocs.io/c/numeric/math/exp2\n"}, {"name": "expm1, expm1f, expm1l", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       expm1f( float arg );\n  (1)   (since C99)\ndouble      expm1( double arg );\n  (2)   (since C99)\nlong double expm1l( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define expm1( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur earg-1 is returned.\n   If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   The functions expm1 and log1p are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n-1 can be expressed as expm1(n * log1p(x)). These functions also simplify writing accurate inverse hyperbolic functions.\n   For IEEE-compatible type double, overflow is guaranteed if 709.8 < arg.\n", "url": "https://devdocs.io/c/numeric/math/expm1\n"}, {"name": "fabs, fabsf, fabsl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       fabsf( float arg );\n  (1)   (since C99)\ndouble      fabs( double arg );\n  (2)\nlong double fabsl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define fabs( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If successful, returns the absolute value of arg (|arg|). The value returned is exact and does not depend on any rounding modes.\n\nError handling\n   This function is not subject to any of the error conditions specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n", "url": "https://devdocs.io/c/numeric/math/fabs\n"}, {"name": "fdim", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       fdimf( float x, float y );\n  (1)   (since C99)\ndouble      fdim( double x, double y );\n  (2)   (since C99)\nlong double fdiml( long double x, long double y );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define fdim( x, y )\n  (4)   (since C99)\n\n\nParameters\nx, y   -   floating point value\n\n\nReturn value\n   If successful, returns the positive difference between x and y.\n   If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.\n   If a range error due to underflow occurs, the correct value (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   Equivalent to fmax(x-y, 0) except for the NaN handling requirements.\n", "url": "https://devdocs.io/c/numeric/math/fdim\n"}, {"name": "feclearexcept", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\nint feclearexcept( int excepts );\n    (since C99)\n\n   Attempts to clear the floating-point exceptions that are listed in the bitmask argument excepts, which is a bitwise OR of the floating point exception macros.\n\nParameters\nexcepts   -   bitmask listing the exception flags to clear\n\n\nReturn value\n   \u200b0\u200b if all indicated exceptions were successfully cleared or if excepts is zero. Returns a non-zero value on error.\n", "url": "https://devdocs.io/c/numeric/fenv/feclearexcept\n"}, {"name": "fegetenv, fesetenv", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\nint fegetenv( fenv_t* envp );\n  (1)   (since C99)\nint fesetenv( const fenv_t* envp );\n  (2)   (since C99)\n\n   1) Attempts to store the status of the floating-point environment in the object pointed to by envp.\n   2) Attempts to establish the floating-point environment from the object pointed to by envp. The value of that object must be previously obtained by a call to feholdexcept or fegetenv or be a floating-point macro constant. If any of the floating-point status flags are set in envp, they become set in the environment (and are then testable with fetestexcept), but the corresponding floating-point exceptions are not raised (execution continues uninterrupted).\n\nParameters\nenvp   -   pointer to the object of type fenv_t which holds the status of the floating-point environment\n\n\nReturn value\n   \u200b0\u200b on success, non-zero otherwise.\n", "url": "https://devdocs.io/c/numeric/fenv/feenv\n"}, {"name": "fegetexceptflag, fesetexceptflag", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\nint fegetexceptflag( fexcept_t* flagp, int excepts );\n  (1)   (since C99)\nint fesetexceptflag( const fexcept_t* flagp, int excepts );\n  (2)   (since C99)\n\n   1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument excepts, which is a bitwise OR of the floating point exception macros.\n   2) Attempts to copy the full contents of the floating-point exception flags that are listed in excepts from flagp into the floating-point environment. Does not raise any exceptions, only modifies the flags.\n   The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in flagp in implementation-defined format.\n\nParameters\nflagp   -   pointer to an fexcept_t object where the flags will be stored or read from\nexcepts   -   bitmask listing the exception flags to get/set\n\n\nReturn value\n   \u200b0\u200b on success, non-zero otherwise.\n", "url": "https://devdocs.io/c/numeric/fenv/feexceptflag\n"}, {"name": "fegetround, fesetround", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\nint fesetround( int round );\n  (1)   (since C99)\nint fegetround();\n  (2)   (since C99)\n\n   1) Attempts to establish the floating-point rounding direction equal to the argument round, which is expected to be one of the floating-point rounding macros.\n   2) Returns the value of the floating-point rounding macro that corresponds to the current rounding direction.\n\nParameters\nround   -   rounding direction, one of floating-point rounding macros\n\n\nReturn value\n   1) \u200b0\u200b on success, non-zero otherwise.\n   2) the floating-point rounding macro describing the current rounding direction or a negative value if the direction cannot be determined.\n\nNotes\n   The current rounding mode, reflecting the effects of the most recent fesetround, can also be queried with FLT_ROUNDS.\n", "url": "https://devdocs.io/c/numeric/fenv/feround\n"}, {"name": "feholdexcept", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\nint feholdexcept( fenv_t* envp );\n    (since C99)\n\n   First, saves the current floating-point environment to the object pointed to by envp (similar to fegetenv), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by feupdateenv or fesetenv.\n   This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to feupdateenv after clearing the unwanted exceptions.\n\nParameters\nenvp   -   pointer to the object of type fenv_t where the floating-point environment will be stored\n\n\nReturn value\n   \u200b0\u200b on success, non-zero otherwise.\n", "url": "https://devdocs.io/c/numeric/fenv/feholdexcept\n"}, {"name": "feraiseexcept", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\nint feraiseexcept( int excepts );\n    (since C99)\n\n   Attempts to raise all floating point exceptions listed in excepts (a bitwise OR of the floating point exception macros). If one of the exceptions is FE_OVERFLOW or FE_UNDERFLOW, this function may additionally raise FE_INEXACT. The order in which the exceptions are raised is unspecified, except that FE_OVERFLOW and FE_UNDERFLOW are always raised before FE_INEXACT.\n\nParameters\nexcepts   -   bitmask listing the exception flags to raise\n\n\nReturn value\n   \u200b0\u200b if all listed exceptions were raised, non-zero value otherwise.\n", "url": "https://devdocs.io/c/numeric/fenv/feraiseexcept\n"}, {"name": "fetestexcept", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\nint fetestexcept( int excepts );\n    (since C99)\n\n   Determines which of the specified subset of the floating point exceptions are currently set. The argument excepts is a bitwise OR of the floating point exception macros.\n\nParameters\nexcepts   -   bitmask listing the exception flags to test\n\n\nReturn value\n   Bitwise OR of the floating-point exception macros that are both included in excepts and correspond to floating-point exceptions currently set.\n", "url": "https://devdocs.io/c/numeric/fenv/fetestexcept\n"}, {"name": "feupdateenv", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\nint feupdateenv( const fenv_t* envp );\n    (since C99)\n\n   First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by envp (similar to fesetenv), then raises the floating-point exceptions that were saved.\n   This function may be used to end the non-stop mode established by an earlier call to feholdexcept.\n\nParameters\nenvp   -   pointer to the object of type fenv_t set by an earlier call to feholdexcept or fegetenv or equal to FE_DFL_ENV\n\n\nReturn value\n   \u200b0\u200b on success, non-zero otherwise.\n", "url": "https://devdocs.io/c/numeric/fenv/feupdateenv\n"}, {"name": "FE_DIVBYZERO, FE_INEXACT, FE_INVALID, FE_OVERFLOW, FE_UNDERFLOW, FE_ALL_EXCEPT", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\n#define FE_DIVBYZERO    /*implementation defined power of 2*/\n    (since C99)\n#define FE_INEXACT      /*implementation defined power of 2*/\n    (since C99)\n#define FE_INVALID      /*implementation defined power of 2*/\n    (since C99)\n#define FE_OVERFLOW     /*implementation defined power of 2*/\n    (since C99)\n#define FE_UNDERFLOW    /*implementation defined power of 2*/\n    (since C99)\n#define FE_ALL_EXCEPT  FE_DIVBYZERO | FE_INEXACT | \\\n                       FE_INVALID | FE_OVERFLOW |  \\\n                       FE_UNDERFLOW\n    (since C99)\n\n   All these macro constants (except FE_ALL_EXCEPT) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.\n   The macro constant FE_ALL_EXCEPT, which expands to the bitwise OR of all other FE_*, is always defined and is zero if floating-point exceptions are not supported by the implementation.\nConstant   Explanation\nFE_DIVBYZERO   pole error occurred in an earlier floating-point operation\nFE_INEXACT   inexact result: rounding was necessary to store the result of an earlier floating-point operation\nFE_INVALID   domain error occurred in an earlier floating-point operation\nFE_OVERFLOW   the result of an earlier floating-point operation was too large to be representable\nFE_UNDERFLOW   the result of an earlier floating-point operation was subnormal with a loss of precision\nFE_ALL_EXCEPT   bitwise OR of all supported floating-point exceptions\n\n   The implementation may define additional macro constants in <fenv.h> to identify additional floating-point exceptions. All such constants begin with FE_ followed by at least one uppercase letter.\n   See math_errhandling for further details.\n", "url": "https://devdocs.io/c/numeric/fenv/fe_exceptions\n"}, {"name": "FE_DFL_ENV", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\n#define FE_DFL_ENV  /*implementation defined*/\n    (since C99)\n\n   The macro constant FE_DFL_ENV expands to an expression of type const fenv_t*, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.\n   Additional macros that begin with FE_ followed by uppercase letters, and have the type const fenv_t*, may be supported by an implementation.\n", "url": "https://devdocs.io/c/numeric/fenv/fe_dfl_env\n"}, {"name": "FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD", "type": "STANDARD LIB", "description": "Defined in header <fenv.h>\n#define FE_DOWNWARD     /*implementation defined*/\n    (since C99)\n#define FE_TONEAREST    /*implementation defined*/\n    (since C99)\n#define FE_TOWARDZERO   /*implementation defined*/\n    (since C99)\n#define FE_UPWARD       /*implementation defined*/\n    (since C99)\n\n   Each of these macro constants expands to a nonnegative integer constant expression, which can be used with fesetround and fegetround to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in <fenv.h>, which should all begin with FE_ followed by at least one uppercase letter. Each macro is only defined if it is supported.\nConstant   Explanation\nFE_DOWNWARD   rounding towards negative infinity\nFE_TONEAREST   rounding towards nearest representable value\nFE_TOWARDZERO   rounding towards zero\nFE_UPWARD   rounding towards positive infinity\n\n   Additional rounding modes may be supported by an implementation.\n   The current rounding mode affects the following:\n   The current rounding mode does NOT affect the following:\n   As with any floating-point environment functionality, rounding is only guaranteed if #pragma STDC FENV_ACCESS ON is set.\n", "url": "https://devdocs.io/c/numeric/fenv/fe_round\n"}, {"name": "Floating-point environment", "type": "STANDARD LIB", "description": "   The floating-point environment is the set of floating-point status flags and control modes supported by the implementation. It is thread-local, each thread inherits the initial state of its floating-point environment from the parent thread. Floating-point operations modify the floating-point status flags to indicate abnormal results or auxiliary information. The state of floating-point control modes affects the outcomes of some floating-point operations.\n   The floating-point environment access and modification is only meaningful when  #pragma STDC FENV_ACCESS is set to ON. Otherwise the implementation is free to assume that floating-point control modes are always the default ones and that floating-point status flags are never tested or modified. In practice, few current compilers, such as HP aCC, Oracle Studio, and IBM XL, support the #pragma explicitly, but most compilers allow meaningful access to the floating-point environment anyway.\n\nTypes\nDefined in header <fenv.h>\nfenv_t   The type representing the entire floating-point environment\nfexcept_t   The type representing all floating-point status flags collectively\n\n\nFunctions\nfeclearexcept\n(C99)   clears the specified floating-point status flags  (function)\nfetestexcept\n(C99)   determines which of the specified floating-point status flags are set  (function)\nferaiseexcept\n(C99)   raises the specified floating-point exceptions  (function)\nfegetexceptflagfesetexceptflag\n(C99)(C99)   copies the state of the specified floating-point status flags from or to the floating-point environment  (function)\nfegetroundfesetround\n(C99)(C99)   gets or sets rounding direction  (function)\nfegetenvfesetenv\n(C99)   saves or restores the current floating point environment  (function)\nfeholdexcept\n(C99)   saves the environment, clears all status flags and ignores all future errors  (function)\nfeupdateenv\n(C99)   restores the floating-point environment and raises the previously raise exceptions  (function)\n\n\nMacros\nFE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW\n(C99)   floating-point exceptions  (macro constant)\nFE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD\n(C99)   floating-point rounding direction  (macro constant)\nFE_DFL_ENV\n(C99)   default floating-point environment  (macro constant)\n\n", "url": "https://devdocs.io/c/numeric/fenv\n"}, {"name": "floor, floorf, floorl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       floorf( float arg );\n  (1)   (since C99)\ndouble      floor( double arg );\n  (2)\nlong double floorl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define floor( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the largest integer value not greater than arg, that is \u230aarg\u230b, is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   FE_INEXACT may be (but isn't required to be) raised when rounding a non-integer finite value.\n   The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including intmax_t), when stored in an integer variable.\n", "url": "https://devdocs.io/c/numeric/math/floor\n"}, {"name": "fma, fmaf, fmal", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       fmaf( float x, float y, float z );\n  (1)   (since C99)\ndouble      fma( double x, double y, double z );\n  (2)   (since C99)\nlong double fmal( long double x, long double y, long double z );\n  (3)   (since C99)\n#define FP_FAST_FMA  /* implementation-defined */\n  (4)   (since C99)\n#define FP_FAST_FMAF /* implementation-defined */\n  (5)   (since C99)\n#define FP_FAST_FMAL /* implementation-defined */\n  (6)   (since C99)\nDefined in header <tgmath.h>\n#define fma( x, y, z )\n  (7)   (since C99)\n\n\nParameters\nx, y, z   -   floating point values\n\n\nReturn value\n   If successful, returns the value of (x*y) + z as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).\n   If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.\n   If a range error due to underflow occurs, the correct value (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   This operation is commonly implemented in hardware as fused multiply-add CPU instruction. If supported by hardware, the appropriate FP_FAST_FMA* macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.\n   POSIX specifies that the situation where the value x*y is invalid and z is a NaN is a domain error.\n   Due to its infinite intermediate precision, fma is a common building block of other correctly-rounded mathematical operations, such as sqrt or even the division (where not provided by the CPU, e.g. Itanium).\n   As with all floating-point expressions, the expression (x*y) + z may be compiled as a fused mutiply-add unless the #pragma STDC FP_CONTRACT is off.\n", "url": "https://devdocs.io/c/numeric/math/fma\n"}, {"name": "fmax, fmaxf, fmaxl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       fmaxf( float x, float y );\n  (1)   (since C99)\ndouble      fmax( double x, double y );\n  (2)   (since C99)\nlong double fmaxl( long double x, long double y );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define fmax( x, y )\n  (4)   (since C99)\n\n\nParameters\nx, y   -   floating point values\n\n\nReturn value\n   If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.\n\nError handling\n   This function is not subject to any of the error conditions specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.\n", "url": "https://devdocs.io/c/numeric/math/fmax\n"}, {"name": "fmin, fminf, fminl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       fminf( float x, float y );\n  (1)   (since C99)\ndouble      fmin( double x, double y );\n  (2)   (since C99)\nlong double fminl( long double x, long double y );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define fmin( x, y )\n  (4)   (since C99)\n\n\nParameters\nx, y   -   floating point values\n\n\nReturn value\n   If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.\n\nError handling\n   This function is not subject to any of the error conditions specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.\n", "url": "https://devdocs.io/c/numeric/math/fmin\n"}, {"name": "fmod, fmodf, fmodl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       fmodf( float x, float y );\n  (1)   (since C99)\ndouble      fmod( double x, double y );\n  (2)\nlong double fmodl( long double x, long double y );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define fmod( x, y )\n  (4)   (since C99)\n\n   The floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where n is x/y with its fractional part truncated.\n   The returned value has the same sign as x and is less or equal to y in magnitude.\n\nParameters\nx, y   -   floating point values\n\n\nReturn value\n   If successful, returns the floating-point remainder of the division x/y as defined above.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error may occur if y is zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   POSIX requires that a domain error occurs if x is infinite or y is zero.\n   fmod, but not remainder is useful for doing silent wrapping of floating-point types to unsigned integer types: (0.0 <= (y = fmod(rint(x), 65536.0 )) ? y : 65536.0 + y) is in the range [-0.0 .. 65535.0], which corresponds to unsigned short, but remainder(rint(x), 65536.0) is in the range [-32767.0, +32768.0], which is outside of the range of signed short.\n   The double version of fmod behaves as if implemented as follows:\n", "url": "https://devdocs.io/c/numeric/math/fmod\n"}, {"name": "fpclassify", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define fpclassify(arg) /* implementation defined */\n    (since C99)\n\n   Categorizes floating point value arg into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category. The macro returns an integral value.\n   FLT_EVAL_METHOD is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that: a normal long double value might become subnormal when converted to double and zero when converted to float.\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   One of FP_INFINITE, FP_NAN, FP_NORMAL, FP_SUBNORMAL, FP_ZERO or implementation-defined type, specifying the category of arg.\n", "url": "https://devdocs.io/c/numeric/math/fpclassify\n"}, {"name": "FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define FP_NORMAL    /*implementation defined*/\n    (since C99)\n#define FP_SUBNORMAL /*implementation defined*/\n    (since C99)\n#define FP_ZERO      /*implementation defined*/\n    (since C99)\n#define FP_INFINITE  /*implementation defined*/\n    (since C99)\n#define FP_NAN       /*implementation defined*/\n    (since C99)\n\n   The FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.\nConstant   Explanation\nFP_NORMAL   indicates that the value is normal, i.e. not an infinity, subnormal, not-a-number or zero\nFP_SUBNORMAL   indicates that the value is subnormal\nFP_ZERO   indicates that the value is positive or negative zero\nFP_INFINITE   indicates that the value is not representable by the underlying type (positive or negative infinity)\nFP_NAN   indicates that the value is not-a-number (NaN)\n\n", "url": "https://devdocs.io/c/numeric/math/fp_categories\n"}, {"name": "frexp, frexpf, frexpl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       frexpf( float arg, int* exp );\n  (1)   (since C99)\ndouble      frexp( double arg, int* exp );\n  (2)\nlong double frexpl( long double arg, int* exp );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define frexp( arg, exp )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\nexp   -   pointer to integer value to store the exponent to\n\n\nReturn value\n   If arg is zero, returns zero and stores zero in *exp.\n   Otherwise (if arg is not zero), if no errors occur, returns the value x in the range (-1;-0.5], [0.5; 1) and stores an integer value in *exp such that x\u00d72(*exp)=arg.\n   If the value to be stored in *exp is outside the range of int, the behavior is unspecified.\n   If arg is not a floating-point number, the behavior is unspecified.\n\nError handling\n   This function is not subject to any errors specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   On a binary system (where FLT_RADIX is 2), frexp may be implemented as.\n   The function frexp, together with its dual, ldexp, can be used to manipulate the representation of a floating-point number without direct bit manipulations.\n", "url": "https://devdocs.io/c/numeric/math/frexp\n"}, {"name": "HUGE_VALF, HUGE_VAL, HUGE_VALL", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define HUGE_VALF /*implementation defined*/\n    (since C99)\n#define HUGE_VAL  /*implementation defined*/\n#define HUGE_VALL /*implementation defined*/\n    (since C99)\n\n   The HUGE_VALF, HUGE_VAL and HUGE_VALL macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see math_errhandling).\nConstant   Explanation\nHUGE_VALF   Expands to positive float expression that indicates overflow\nHUGE_VAL   Expands to positive double expression that indicates overflow, not necessarily representable as a float\nHUGE_VALL   Expands to positive long double expression that indicates overflow, not necessarily representable as a float or double\n\n   On implementations that support floating-point infinities, these macros always expand to the positive infinities of float, double, and long double, respectively.\n", "url": "https://devdocs.io/c/numeric/math/huge_val\n"}, {"name": "hypot, hypotf, hypotl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       hypotf( float x, float y );\n  (1)   (since C99)\ndouble      hypot( double x, double y );\n  (2)   (since C99)\nlong double hypotl( long double x, long double y );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define hypot( x, y )\n  (4)   (since C99)\n\n   The value computed by this function is the length of the hypotenuse of a right-angled triangle with sides of length x and y, or the distance of the point (x,y) from the origin (0,0), or the magnitude of a complex number x+iy.\n\nParameters\nx   -   floating point value\ny   -   floating point value\n\n\nReturn value\n   If no errors occur, the hypotenuse of a right-angled triangle, \u221ax2+y2, is returned.\n   If a range error due to overflow occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.\n   If a range error due to underflow occurs, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   Implementations usually guarantee precision of less than 1 ulp (units in the last place): GNU, BSD, Open64.\n   hypot(x, y) is equivalent to cabs(x + I*y).\n   POSIX specifies that underflow may only occur when both arguments are subnormal and the correct result is also subnormal (this forbids naive implementations).\n   hypot(INFINITY, NAN) returns +\u221e, but sqrt(INFINITY*INFINITY+NAN*NAN) returns NaN.\n", "url": "https://devdocs.io/c/numeric/math/hypot\n"}, {"name": "I ", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\n#define I /* unspecified */\n    (since C99)\n\n   The I macro expands to either _Complex_I or _Imaginary_I. If the implementation does not support imaginary types, then the macro always expands to _Complex_I.\n   A program may undefine and perhaps then redefine the macro I.\n\nNotes\n   The macro is not named i, which is the name of the imaginary unit in mathematics, because the name i was already used in many C programs, e.g. as a loop counter variable.\n   The macro I is often used to form complex numbers, with expressions such as x + y*I. If I is defined as _Complex_I, then such expression may create a value with imaginary component +0.0 even when y is -0.0, which is significant for complex number functions with branch cuts. The macro CMPLX provides a way to construct a complex number precisely.\n   GCC provides a non-portable extension that allows imaginary constants to be specified with the suffix i on integer literals: 1.0fi, 1.0i, and 1.0li are imaginary units in GNU C. A similar approach is part of standard C++ as of C++14 (1.0if, 1.0i, and 1.0il are the imaginary units in C++).\n", "url": "https://devdocs.io/c/numeric/complex/i\n"}, {"name": "ilogb, ilogbf, ilogbl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nint ilogbf( float arg );\n  (1)   (since C99)\nint ilogb( double arg );\n  (2)   (since C99)\nint ilogbl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define ilogb( arg )\n  (4)   (since C99)\nDefined in header <math.h>\n#define FP_ILOGB0 /*implementation-defined*/\n  (5)   (since C99)\n#define FP_ILOGBNAN /*implementation-defined*/\n  (6)   (since C99)\n\n   Formally, the unbiased exponent is the integral part of logr|arg| as a signed integral value, for non-zero arg, where r is FLT_RADIX.\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the unbiased exponent of arg is returned as a signed int value.\n   If arg is zero, FP_ILOGB0 is returned.\n   If arg is infinite, INT_MAX is returned.\n   If arg is a NaN, FP_ILOGBNAN is returned.\n   If the correct result is greater than INT_MAX or smaller than INT_MIN, the return value is unspecified and a domain error or range error may occur.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   A domain error or range error may occur if arg is zero, infinite, or NaN.\n   If the correct result is greater than INT_MAX or smaller than INT_MIN, a domain error or a range error may occur.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   If arg is not zero, infinite, or NaN, the value returned is exactly equivalent to (int)logb(arg).\n   POSIX requires that a domain error occurs if arg is zero, infinite, NaN, or if the correct result is outside of the range of int.\n   POSIX also requires that, on XSI-conformant systems, the value returned when the correct result is greater than INT_MAX is INT_MAX and the value returned when the correct result is less than INT_MIN is INT_MIN.\n   The correct result can be represented as int on all known implementations. For overflow to occur, INT_MAX must be less than LDBL_MAX_EXP*log2(FLT_RADIX) or INT_MIN must be greater than LDBL_MIN_EXP-LDBL_MANT_DIG)*log2(FLT_RADIX).\n   The value of the exponent returned by ilogb is always 1 less than the exponent retuned by frexp because of the different normalization requirements: for the exponent e returned by ilogb, |arg*r-e| is between 1 and r (typically between 1 and 2), but for the exponent e returned by frexp, |arg*2-e| is between 0.5 and 1.\n", "url": "https://devdocs.io/c/numeric/math/ilogb\n"}, {"name": "imaginary", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\n#define imaginary _Imaginary\n    (since C99)\n\n   This macro expands to the keyword _Imaginary.\n   This is a convenience macro that makes it possible to use float imaginary, double imaginary, and long double imaginary as an alternative way to write the three pure imaginary C types float _Imaginary, double _Imaginary, and long double _Imaginary.\n   As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.\nA compiler that defines __STDC_IEC_559_COMPLEX__ is not required to support imaginary numbers. POSIX recommends checking if the macro _Imaginary_I is defined to identify imaginary number support.\n \n(since C99)(until C11)\nImaginary numbers are supported if __STDC_IEC_559_COMPLEX__ is defined.\n (since C11)\n\n\nNotes\n   Programs are allowed to undefine and perhaps redefine the imaginary macro.\n", "url": "https://devdocs.io/c/numeric/complex/imaginary\n"}, {"name": "INFINITY", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define INFINITY /*implementation defined*/\n    (since C99)\n\n   If the implementation supports floating-point infinities, the macro INFINITY expands to constant expression of type float which evaluates to positive or unsigned infinity.\n   If the implementation does not support floating-point infinities, the macro INFINITY expands to a positive value that is guaranteed to overflow a float at compile time, and the use of this macro generates a compiler warning.\n   The style used to print an infinity is implementation defined.\n   Show style used to print an infinity and IEEE format.\n", "url": "https://devdocs.io/c/numeric/math/infinity\n"}, {"name": "isfinite", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define isfinite(arg) /* implementation defined */\n    (since C99)\n\n   Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. The macro returns an integral value.\n   FLT_EVAL_METHOD is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   Nonzero integral value if arg has finite value, \u200b0\u200b otherwise.\n", "url": "https://devdocs.io/c/numeric/math/isfinite\n"}, {"name": "isgreater", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define isgreater(x, y) /* implementation defined */\n    (since C99)\n\n   Determines if the floating point number x is greater than the floating-point number (y), without setting floating-point exceptions.\n\nParameters\nx   -   floating point value\ny   -   floating point value\n\n\nReturn value\n   Nonzero integral value if x > y, \u200b0\u200b otherwise.\n\nNotes\n   The built-in operator> for floating-point numbers may set FE_INVALID if one or both of the arguments is NaN. This function is a \"quiet\" version of operator>.\n", "url": "https://devdocs.io/c/numeric/math/isgreater\n"}, {"name": "isgreaterequal", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define isgreaterequal(x, y) /* implementation defined */\n    (since C99)\n\n   Determines if the floating point number x is greater than or equal to the floating-point number y, without setting floating-point exceptions.\n\nParameters\nx   -   floating point value\ny   -   floating point value\n\n\nReturn value\n   Nonzero integral value if x >= y, \u200b0\u200b otherwise.\n\nNotes\n   The built-in operator>= for floating-point numbers may raise FE_INVALID if one or both of the arguments is NaN. This function is a \"quiet\" version of operator>=.\n", "url": "https://devdocs.io/c/numeric/math/isgreaterequal\n"}, {"name": "isinf", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define isinf(arg) /* implementation defined */\n    (since C99)\n\n   Determines if the given floating point number arg is positive or negative infinity. The macro returns an integral value.\n   FLT_EVAL_METHOD is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   Nonzero integral value if arg has an infinite value, \u200b0\u200b otherwise.\n", "url": "https://devdocs.io/c/numeric/math/isinf\n"}, {"name": "isless", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define isless(x, y) /* implementation defined */\n    (since C99)\n\n   Determines if the floating point number x is less than the floating-point number y, without setting floating-point exceptions.\n\nParameters\nx   -   floating point value\ny   -   floating point value\n\n\nReturn value\n   Nonzero integral value if x < y, \u200b0\u200b otherwise.\n\nNotes\n   The built-in operator< for floating-point numbers may raise FE_INVALID if one or both of the arguments is NaN. This function is a \"quiet\" version of operator<.\n", "url": "https://devdocs.io/c/numeric/math/isless\n"}, {"name": "islessequal", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define islessequal(x, y) /* implementation defined */\n    (since C99)\n\n   Determines if the floating point number x is less than or equal to the floating-point number y, without setting floating-point exceptions.\n\nParameters\nx   -   floating point value\ny   -   floating point value\n\n\nReturn value\n   Nonzero integral value if x <= y, \u200b0\u200b otherwise.\n\nNotes\n   The built-in operator<= for floating-point numbers may raise FE_INVALID if one or both of the arguments is NaN. This function is a \"quiet\" version of operator<=.\n", "url": "https://devdocs.io/c/numeric/math/islessequal\n"}, {"name": "islessgreater", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define islessgreater(x, y) /* implementation defined */\n    (since C99)\n\n   Determines if the floating point number x is less than or greater than the floating-point number y, without setting floating-point exceptions.\n\nParameters\nx   -   floating point value\ny   -   floating point value\n\n\nReturn value\n   Nonzero integral value if x < y || x > y, \u200b0\u200b otherwise.\n\nNotes\n   The built-in operator< and operator> for floating-point numbers may raise FE_INVALID if one or both of the arguments is NaN. This function is a \"quiet\" version of the expression x < y || x > y. The macro does not evaluate x and y twice.\n", "url": "https://devdocs.io/c/numeric/math/islessgreater\n"}, {"name": "isnan", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define isnan(arg) /* implementation defined */\n    (since C99)\n\n   Determines if the given floating point number arg is a not-a-number (NaN) value. The macro returns an integral value.\n   FLT_EVAL_METHOD is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that (this matters if the evaluation type supports NaNs, while the semantic type does not).\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   Nonzero integral value if arg is a NaN, \u200b0\u200b otherwise.\n\nNotes\n   There are many different NaN values with different sign bits and payloads, see nan.\n   NaN values never compare equal to themselves or to other NaN values. Copying a NaN may change its bit pattern.\n   Another way to test if a floating-point value is NaN is to compare it with itself: bool is_nan(double x) { return x != x; }\n", "url": "https://devdocs.io/c/numeric/math/isnan\n"}, {"name": "isnormal", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define isnormal(arg) /* implementation defined */\n    (since C99)\n\n   Determines if the given floating point number arg is normal, i.e. is neither zero, subnormal, infinite, nor NaN. The macro returns an integral value.\n   FLT_EVAL_METHOD is ignored: even if the argument is evaluated with more range and precision than its type, it is first converted to its semantic type, and the classification is based on that.\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   Nonzero integral value if arg is normal, \u200b0\u200b otherwise.\n", "url": "https://devdocs.io/c/numeric/math/isnormal\n"}, {"name": "isunordered", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define isunordered(x, y) /* implementation defined */\n    (since C99)\n\n   Determines if the floating point numbers x and y are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.\n\nParameters\nx   -   floating point value\ny   -   floating point value\n\n\nReturn value\n   Nonzero integral value if either x or y is NaN, \u200b0\u200b otherwise.\n", "url": "https://devdocs.io/c/numeric/math/isunordered\n"}, {"name": "ldexp, ldexpf, ldexpl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       ldexpf( float arg, int exp );\n  (1)   (since C99)\ndouble      ldexp( double arg, int exp );\n  (2)\nlong double ldexpl( long double arg, int exp );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define ldexp( arg, exp )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\nexp   -   integer value\n\n\nReturn value\n   If no errors occur, arg multiplied by 2 to the power of exp (arg\u00d72exp) is returned.\n   If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.\n   If a range error due to underflow occurs, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   On binary systems (where FLT_RADIX is 2), ldexp is equivalent to scalbn.\n   The function ldexp (\"load exponent\"), together with its dual, frexp, can be used to manipulate the representation of a floating-point number without direct bit manipulations.\n   On many implementations, ldexp is less efficient than multiplication or division by a power of two using arithmetic operators.\n", "url": "https://devdocs.io/c/numeric/math/ldexp\n"}, {"name": "lgamma, lgammaf, lgammal", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       lgammaf( float arg );\n  (1)   (since C99)\ndouble      lgamma( double arg );\n  (2)   (since C99)\nlong double lgammal( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define lgamma( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the value of the logarithm of the gamma function of arg, that is loge|\u222b\u221e0targ-1 e-t dt|, is returned.\n   If a pole error occurs, +HUGE_VAL, +HUGE_VALF, or +HUGE_VALL is returned.\n   If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If arg is zero or is an integer less than zero, a pole error may occur.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   If arg is a natural number, lgamma(arg) is the logarithm of the factorial of arg-1.\n   The POSIX version of lgamma is not thread-safe: each execution of the function stores the sign of the gamma function of arg in the static external variable signgam. Some implementations provide lgamma_r, which takes a pointer to user-provided storage for singgam as the second parameter, and is thread-safe.\n   There is a non-standard function named gamma in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of gamma executes lgamma, but 4.4BSD version of gamma executes tgamma.\n", "url": "https://devdocs.io/c/numeric/math/lgamma\n"}, {"name": "rint, rintf, rintl, lrint, lrintf, lrintl, llrint, llrintf, llrintl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat rintf( float arg );\n  (1)   (since C99)\ndouble rint( double arg );\n  (2)   (since C99)\nlong double rintl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define rint( arg )\n  (4)   (since C99)\nDefined in header <math.h>\nlong lrintf( float arg );\n  (5)   (since C99)\nlong lrint( double arg );\n  (6)   (since C99)\nlong lrintl( long double arg );\n  (7)   (since C99)\nDefined in header <tgmath.h>\n#define lrint( arg )\n  (8)   (since C99)\nDefined in header <math.h>\nlong long llrintf( float arg );\n  (9)   (since C99)\nlong long llrint( double arg );\n  (10)   (since C99)\nlong long llrintl( long double arg );\n  (11)   (since C99)\nDefined in header <tgmath.h>\n#define llrint( arg )\n  (12)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the nearest integer value to arg, according to the current rounding mode, is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the result of lrint or llrint is outside the range representable by the return type, a domain error or a range error may occur.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the rint function:\n\nNotes\n   POSIX specifies that all cases where lrint or llrint raise FE_INEXACT are domain errors.\n   As specified in math_errhandling, FE_INEXACT may be (but isn't required to be on non-IEEE floating-point platforms) raised by rint when rounding a non-integer finite value.\n   The only difference between rint and nearbyint is that nearbyint never raises FE_INEXACT.\n   The largest representable floating-point values are exact integers in all standard floating-point formats, so rint never overflows on its own; however the result may overflow any integer type (including intmax_t), when stored in an integer variable.\n   If the current rounding mode is...\n", "url": "https://devdocs.io/c/numeric/math/rint\n"}, {"name": "round, roundf, roundl, lround, lroundf, lroundl, llround, llroundf, llroundl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       roundf( float arg );\n  (1)   (since C99)\ndouble      round( double arg );\n  (2)   (since C99)\nlong double roundl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define round( arg )\n  (4)   (since C99)\nDefined in header <math.h>\nlong      lroundf( float arg );\n  (5)   (since C99)\nlong      lround( double arg );\n  (6)   (since C99)\nlong      lroundl( long double arg );\n  (7)   (since C99)\nDefined in header <tgmath.h>\n#define lround( arg )\n  (8)   (since C99)\nDefined in header <math.h>\nlong long llroundf( float arg );\n  (9)   (since C99)\nlong long llround( double arg );\n  (10)   (since C99)\nlong long llroundl( long double arg );\n  (11)   (since C99)\nDefined in header <tgmath.h>\n#define llround( arg )\n  (12)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the nearest integer value to arg, rounding halfway cases away from zero, is returned.\n   If a domain error occurs, an implementation-defined value is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the result of lround or llround is outside the range representable by the return type, a domain error or a range error may occur.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the round, roundf, and roundl function:\n\nNotes\n   FE_INEXACT may be (but isn't required to be) raised by round when rounding a non-integer finite value.\n   The largest representable floating-point values are exact integers in all standard floating-point formats, so round never overflows on its own; however the result may overflow any integer type (including intmax_t), when stored in an integer variable.\n   POSIX specifies that all cases where lround or llround raise FE_INEXACT are domain errors.\n   The double version of round behaves as if implemented as follows:\n", "url": "https://devdocs.io/c/numeric/math/round\n"}, {"name": "log, logf, logl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       logf( float arg );\n  (1)   (since C99)\ndouble      log( double arg );\n  (2)\nlong double logl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define log( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the natural (base-e) logarithm of arg (ln(arg) or loge(arg)) is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error occurs if arg is less than zero.\n   Pole error may occur if arg is zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n", "url": "https://devdocs.io/c/numeric/math/log\n"}, {"name": "log10, log10f, log10l", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       log10f( float arg );\n  (1)   (since C99)\ndouble      log10( double arg );\n  (2)\nlong double log10l( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define log10( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the common (base-10) logarithm of arg (log10(arg) or lg(arg)) is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error occurs if arg is less than zero.\n   Pole error may occur if arg is zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n", "url": "https://devdocs.io/c/numeric/math/log10\n"}, {"name": "log1p, log1pf, log1pl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       log1pf( float arg );\n  (1)   (since C99)\ndouble      log1p( double arg );\n  (2)   (since C99)\nlong double log1pl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define log1p( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur ln(1+arg) is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error occurs if arg is less than -1.\n   Pole error may occur if arg is -1.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   The functions expm1 and log1p are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n-1 can be expressed as expm1(n * log1p(x)). These functions also simplify writing accurate inverse hyperbolic functions.\n", "url": "https://devdocs.io/c/numeric/math/log1p\n"}, {"name": "log2, log2f, log2l", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       log2f( float arg );\n  (1)   (since C99)\ndouble      log2( double arg );\n  (2)   (since C99)\nlong double log2l( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define log2( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the base-2 logarithm of arg (log2(arg) or lb(arg)) is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error occurs if arg is less than zero.\n   Pole error may occur if arg is zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   For integer arg, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.\n", "url": "https://devdocs.io/c/numeric/math/log2\n"}, {"name": "logb, logbf, logbl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       logbf( float arg );\n  (1)   (since C99)\ndouble      logb( double arg );\n  (2)   (since C99)\nlong double logbl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define logb( arg )\n  (4)   (since C99)\n\n   Formally, the unbiased exponent is the signed integral part of logr|arg| (returned by this function as a floating-point value), for non-zero arg, where r is FLT_RADIX. If arg is subnormal, it is treated as though it was normalized.\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the unbiased exponent of arg is returned as a signed floating-point value.\n   If a domain error occurs, an implementation-defined value is returned.\n   If a pole error occurs, -HUGE_VAL, -HUGE_VALF, or -HUGE_VALL is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain or range error may occur if arg is zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   POSIX requires that a pole error occurs if arg is \u00b10.\n   The value of the exponent returned by logb is always 1 less than the exponent retuned by frexp because of the different normalization requirements: for the exponent e returned by logb, |arg*r-e| is between 1 and r (typically between 1 and 2), but for the exponent e returned by frexp, |arg*2-e| is between 0.5 and 1.\n", "url": "https://devdocs.io/c/numeric/math/logb\n"}, {"name": "MATH_ERRNO, MATH_ERREXCEPT, math_errhandling", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define MATH_ERRNO        1\n    (since C99)\n#define MATH_ERREXCEPT    2\n    (since C99)\n#define math_errhandling  /*implementation defined*/\n    (since C99)\n\n   The macro constant math_errhandling expands to an expression of type int that is either equal to MATH_ERRNO, or equal to MATH_ERREXCEPT, or equal to their bitwise OR (MATH_ERRNO | MATH_ERREXCEPT).\n   The value of math_errhandling indicates the type of error handling that is performed by the floating-point operators and functions:\nConstant   Explanation\nMATH_ERREXCEPT   indicates that floating-point exceptions are used: at least FE_DIVBYZERO, FE_INVALID, and FE_OVERFLOW are defined in <fenv.h>.\nMATH_ERRNO   indicates that floating-point operations use the variable errno to report errors.\n\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559), math_errhandling & MATH_ERREXCEPT is required to be non-zero.\n   The following floating-point error conditions are recognized:\nCondition Explanation errno floating-point exception Example\nDomain error  the argument is outside the range in which the operation is mathematically defined (the description of each function lists the required domain errors)  \nEDOM  \nFE_INVALID  \nacos(2)\nPole error  the mathematical result of the function is exactly infinite or undefined  \nERANGE  \nFE_DIVBYZERO  \nlog(0.0), 1.0/0.0\nRange error due to overflow  the mathematical result is finite, but becomes infinite after rounding, or becomes the largest representable finite value after rounding down  \nERANGE  \nFE_OVERFLOW  \npow(DBL_MAX,2)\nRange error due to underflow  the result is non-zero, but becomes zero after rounding, or becomes subnormal with a loss of precision  \nERANGE or unchanged (implementation-defined)  \nFE_UNDERFLOW or nothing (implementation-defined)  \nDBL_MIN/2\nInexact result  the result has to be rounded to fit in the destination type  unchanged  \nFE_INEXACT or nothing (unspecified)  \nsqrt(2), 1.0/10.0\n\n\nNotes\n   Whether FE_INEXACT is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. rint vs nearbyint).\n   Before C99, floating-point exceptions were not specified, EDOM was required for any domain error, ERANGE was required for overflows and implementation-defined for underflows.\n", "url": "https://devdocs.io/c/numeric/math/math_errhandling\n"}, {"name": "modf, modff, modfl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       modff( float arg, float* iptr );\n  (1)   (since C99)\ndouble      modf( double arg, double* iptr );\n  (2)\nlong double modfl( long double arg, long double* iptr );\n  (3)   (since C99)\n\n\nParameters\narg   -   floating point value\niptr   -   pointer to floating point value to store the integral part to\n\n\nReturn value\n   If no errors occur, returns the fractional part of x with the same sign as x. The integral part is put into the value pointed to by iptr.\n   The sum of the returned value and the value stored in *iptr gives arg (allowing for rounding).\n\nError handling\n   This function is not subject to any errors specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   This function behaves as if implemented as follows:\n", "url": "https://devdocs.io/c/numeric/math/modf\n"}, {"name": "nan, nanf, nanl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       nanf( const char* arg );\n    (since C99)\ndouble      nan( const char* arg );\n    (since C99)\nlong double nanl( const char* arg );\n    (since C99)\n\n   Converts the implementation-defined character string arg into the corresponding quiet NaN value, as if by calling strtof, strtod, or strtold, respectively, as follows:\n   The call nan(\"n-char-sequence\"), where n-char-sequence is a sequence of digits, Latin letters, and underscores, is equivalent to the call strtod(\"NAN(n-char-sequence)\", (char**)NULL);.\n   The call nan(\"\") is equivalent to the call strtod(\"NAN()\", (char**)NULL);.\n   The call nan(\"string\"), where string is neither an n-char-sequence nor an empty string, is equivalent to the call strtod(\"NAN\", (char**)NULL);.\n\nParameters\narg   -   narrow character string identifying the contents of a NaN\n\n\nReturn value\n   The quiet NaN value that corresponds to the identifying string arg or zero if the implementation does not support quiet NaNs.\n\nSee also\nisnan\n(C99)   checks if the given number is NaN  (function)\nNAN\n(C99)   evaluates to a quiet NaN of type float  (macro constant)\n\n", "url": "https://devdocs.io/c/numeric/math/nan.2\n"}, {"name": "NAN", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define NAN /*implementation defined*/\n    (since C99)\n\n   The macro NAN expands to constant expression of type float which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.\n   The style used to print a NaN is implementation defined.\n\nNotes\n   There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro NAN are implementation-defined.\n   Show style used to print a NaN and IEEE format.\n", "url": "https://devdocs.io/c/numeric/math/nan\n"}, {"name": "nearbyint, nearbyintf, nearbyintl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       nearbyintf( float arg );\n  (1)   (since C99)\ndouble      nearbyint( double arg );\n  (2)   (since C99)\nlong double nearbyintl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define nearbyint( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   The nearest integer value to arg, according to the current rounding mode, is returned.\n\nError handling\n   This function is not subject to any of the errors specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   The only difference between nearbyint and rint is that nearbyint never raises FE_INEXACT.\n   The largest representable floating-point values are exact integers in all standard floating-point formats, so nearbyint never overflows on its own; however the result may overflow any integer type (including intmax_t), when stored in an integer variable.\n   If the current rounding mode is FE_TONEAREST, this function rounds to even in halfway cases (like rint, but unlike round).\n", "url": "https://devdocs.io/c/numeric/math/nearbyint\n"}, {"name": "nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       nextafterf( float from, float to );\n  (1)   (since C99)\ndouble      nextafter( double from, double to );\n  (2)   (since C99)\nlong double nextafterl( long double from, long double to );\n  (3)   (since C99)\nfloat       nexttowardf( float from, long double to );\n  (4)   (since C99)\ndouble      nexttoward( double from, long double to );\n  (5)   (since C99)\nlong double nexttowardl( long double from, long double to );\n  (6)   (since C99)\nDefined in header <tgmath.h>\n#define nextafter(from, to)\n  (7)   (since C99)\n#define nexttoward(from, to)\n  (8)   (since C99)\n\n\nParameters\nfrom, to   -   floating point values\n\n\nReturn value\n   If no errors occur, the next representable value of from in the direction of to. is returned. If from equals to, then to is returned, converted to the type of the function.\n   If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned (with the same sign as from).\n   If a range error occurs due to underflow, the correct result is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   POSIX specifies that the overflow and the underflow conditions are range errors (errno may be set).\n   IEC 60559 recommends that from is returned whenever from==to. These functions return to instead, which makes the behavior around zero consistent: nextafter(-0.0, +0.0) returns +0.0 and nextafter(+0.0, -0.0) returns \u20130.0.\n", "url": "https://devdocs.io/c/numeric/math/nexttoward\n"}, {"name": "Numerics", "type": "STANDARD LIB", "description": "   The C numerics library includes common mathematical functions and types, as well as support for random number generation.\n\nCommon mathematical functions\n   The header math.h provides standard C library mathematical functions such as fabs, sqrt, and sin.\n\nFloating-point environment\n   The header fenv.h defines flags and functions related to exceptional floating-point state, such as overflow and division by zero.\n\nPseudo-random number generation\n   The header stdlib.h also includes C-style random number generation via srand and rand.\n\nComplex number arithmetic\n   The header complex.h provides types and functions about complex numbers.\n\nType-generic math\n   The header tgmath.h provides some macros for a function which names XXX:\n\nSee also\n", "url": "https://devdocs.io/c/numeric\n"}, {"name": "pow, powf, powl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat powf( float base, float exponent );\n  (1)   (since C99)\ndouble pow( double base, double exponent );\n  (2)\nlong double powl( long double base, long double exponent );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define pow( base, exponent )\n  (4)   (since C99)\n\n\nParameters\nbase   -   base as floating point value\nexponent   -   exponent as floating point value\n\n\nReturn value\n   If no errors occur, base raised to the power of exponent (baseexponent) is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a pole error or a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If base is finite and negative and exponent is finite and non-integer, a domain error occurs and a range error may occur.\n   If base is zero and exponent is zero, a domain error may occur.\n   If base is zero and exponent is negative, a domain error or a pole error may occur.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   Although pow cannot be used to obtain a root of a negative number, cbrt is provided for the common case where exponent is 1/3.\n", "url": "https://devdocs.io/c/numeric/math/pow\n"}, {"name": "Pseudo-random number generation", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nrand   generates a pseudo-random number  (function)\nsrand   seeds pseudo-random number generator  (function)\nRAND_MAX   maximum possible value generated by rand()  (macro constant)\n\n", "url": "https://devdocs.io/c/numeric/random\n"}, {"name": "rand", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint rand();\n\n   Returns a pseudo-random integer value between \u200b0\u200b and RAND_MAX (0 and RAND_MAX included).\n   srand() seeds the pseudo-random number generator used by rand(). If rand() is used before any calls to srand(), rand() behaves as if it was seeded with srand(1). Each time rand() is seeded with srand(), it must produce the same sequence of values.\n   rand() is not guaranteed to be thread-safe.\n\nParameters\n   (none).\n\nReturn value\n   Pseudo-random integer value between \u200b0\u200b and RAND_MAX, inclusive.\n\nNotes\n   There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of rand() have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between 1 and 0 between calls). rand() is not recommended for serious random-number generation needs, like cryptography.\n   POSIX requires that the period of the pseudo-random number generator used by rand be at least 232.\n   POSIX offered a thread-safe version of rand called rand_r, which is obsolete in favor of the drand48 family of functions.\n", "url": "https://devdocs.io/c/numeric/random/rand\n"}, {"name": "RAND_MAX", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\n#define RAND_MAX /*implementation defined*/\n\n   Expands to an integer constant expression equal to the maximum value returned by the function rand(). This value is implementation dependent. It's guaranteed that this value is at least 32767.\n", "url": "https://devdocs.io/c/numeric/random/rand_max\n"}, {"name": "remainder, remainderf, remainderl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       remainderf( float x, float y );\n  (1)   (since C99)\ndouble      remainder( double x, double y );\n  (2)   (since C99)\nlong double remainderl( long double x, long double y );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define remainder( x, y )\n  (4)   (since C99)\n\n   The IEEE floating-point remainder of the division operation x/y calculated by this function is exactly the value x - n*y, where the value n is the integral value nearest the exact value x/y. When |n-x/y| = \u00bd, the value n is chosen to be even.\n   In contrast to fmod(), the returned value is not guaranteed to have the same sign as x.\n   If the returned value is 0, it will have the same sign as x.\n\nParameters\nx, y   -   floating point values\n\n\nReturn value\n   If successful, returns the IEEE floating-point remainder of the division x/y as defined above.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result is returned.\n   If y is zero, but the domain error does not occur, zero is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error may occur if y is zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   POSIX requires that a domain error occurs if x is infinite or y is zero.\n   fmod, but not remainder is useful for doing silent wrapping of floating-point types to unsigned integer types: (0.0 <= (y = fmod(rint(x), 65536.0)) ? y : 65536.0 + y) is in the range [-0.0 .. 65535.0], which corresponds to unsigned short, but remainder(rint(x), 65536.0) is in the range [-32767.0, +32768.0], which is outside of the range of signed short.\n", "url": "https://devdocs.io/c/numeric/math/remainder\n"}, {"name": "remquo, remquof, remquol", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       remquof( float x, float y, int *quo );\n  (1)   (since C99)\ndouble      remquo( double x, double y, int *quo );\n  (2)   (since C99)\nlong double remquol( long double x, long double y, int *quo );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define remquo( x, y, quo )\n  (4)   (since C99)\n\n\nParameters\nx, y   -   floating point values\nquo   -   pointer to an integer value to store the sign and some bits of x/y\n\n\nReturn value\n   If successful, returns the floating-point remainder of the division x/y as defined in remainder, and stores, in *quo, the sign and at least three of the least significant bits of x/y (formally, stores a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to the magnitude of the integral quotient of x/y, where n is an implementation-defined integer greater than or equal to 3).\n   If y is zero, the value stored in *quo is unspecified.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result is returned if subnormals are supported.\n   If y is zero, but the domain error does not occur, zero is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error may occur if y is zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   POSIX requires that a domain error occurs if x is infinite or y is zero.\n   This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(\u03c0x) for a very large x, calling sin directly may result in a large error, but if the function argument is first reduced with remquo, he low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.\n   On some platforms this operation is supported by hardware (and, for example, on Intel CPU, FPREM1 leaves exactly 3 bits of precision in the quotient).\n", "url": "https://devdocs.io/c/numeric/math/remquo\n"}, {"name": "scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       scalbnf( float arg, int exp );\n  (1)   (since C99)\ndouble      scalbn( double arg, int exp );\n  (2)   (since C99)\nlong double scalbnl( long double arg, int exp );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define scalbn( arg, exp )\n  (4)   (since C99)\nDefined in header <math.h>\nfloat       scalblnf( float arg, long exp );\n  (5)   (since C99)\ndouble      scalbln( double arg, long exp );\n  (6)   (since C99)\nlong double scalblnl( long double arg, long exp );\n  (7)   (since C99)\nDefined in header <tgmath.h>\n#define scalbln( arg, exp )\n  (8)   (since C99)\n\n\nParameters\narg   -   floating point value\nexp   -   integer value\n\n\nReturn value\n   If no errors occur, arg multiplied by FLT_RADIX to the power of exp (arg\u00d7FLT_RADIXexp) is returned.\n   If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.\n   If a range error due to underflow occurs, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   On binary systems (where FLT_RADIX is 2), scalbn is equivalent to ldexp.\n   Although scalbn and scalbln are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.\n   The scalbln function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than 32767, the standard-guaranteed INT_MAX. In particular, for the 80-bit long double, the factor is 32828.\n   The GNU implementation does not set errno regardless of math_errhandling.\n", "url": "https://devdocs.io/c/numeric/math/scalbn\n"}, {"name": "signbit", "type": "STANDARD LIB", "description": "Defined in header <math.h>\n#define signbit(arg) /* implementation defined */\n    (since C99)\n\n   Determines if the given floating point number arg is negative. The macro returns an integral value.\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   Nonzero integral value if arg is negative, \u200b0\u200b otherwise.\n\nNotes\n   This macro detects the sign bit of zeroes, infinities, and NaNs. Along with copysign, this macro is one of the only two portable ways to examine the sign of a NaN.\n", "url": "https://devdocs.io/c/numeric/math/signbit\n"}, {"name": "sin, sinf, sinl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       sinf( float arg );\n  (1)   (since C99)\ndouble      sin( double arg );\n  (2)\nlong double sinl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define sin( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing an angle in radians\n\n\nReturn value\n   If no errors occur, the sine of arg (sin(arg)) in the range [-1 ; +1], is returned.\nThe result may have little or no significance if the magnitude of arg is large.\n (until C99)\n\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a domain error in POSIX.\n   POSIX also specifies that in case of underflow, arg is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n", "url": "https://devdocs.io/c/numeric/math/sin\n"}, {"name": "sinh, sinhf, sinhl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       sinhf( float arg );\n  (1)   (since C99)\ndouble      sinh( double arg );\n  (2)\nlong double sinhl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define sinh( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing a hyperbolic angle\n\n\nReturn value\n   If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   POSIX specifies that in case of underflow, arg is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n", "url": "https://devdocs.io/c/numeric/math/sinh\n"}, {"name": "sqrt, sqrtf, sqrtl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       sqrtf( float arg );\n  (1)   (since C99)\ndouble      sqrt( double arg );\n  (2)\nlong double sqrtl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define sqrt( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, square root of arg (\u221aarg), is returned.\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   Domain error occurs if arg is less than zero.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   sqrt is required by the IEEE standard to be exact. The only other operations required to be exact are the arithmetic operators and the function fma. After rounding to the return type (using default rounding mode), the result of sqrt is indistinguishable from the infinitely precise result. In other words, the error is less than 0.5 ulp. Other functions, including pow, are not so constrained.\n", "url": "https://devdocs.io/c/numeric/math/sqrt\n"}, {"name": "srand", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid srand( unsigned seed );\n\n   Seeds the pseudo-random number generator used by rand() with the value seed.\n   If rand() is used before any calls to srand(), rand() behaves as if it was seeded with srand(1).\n   Each time rand() is seeded with the same seed, it must produce the same sequence of values.\n   srand() is not guaranteed to be thread-safe.\n\nParameters\nseed   -   the seed value\n\n\nReturn value\n   (none).\n\nNotes\n   Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to rand(), and the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.\n   Standard practice is to use the result of a call to time(0) as the seed. However, time() returns a time_t value, and time_t is not guaranteed to be an integral type. In practice, though, every major implementation defines time_t to be an integral type, and this is also what POSIX requires.\n", "url": "https://devdocs.io/c/numeric/random/srand\n"}, {"name": "tan, tanf, tanl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       tanf( float arg );\n  (1)   (since C99)\ndouble      tan( double arg );\n  (2)\nlong double tanl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define tan( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing angle in radians\n\n\nReturn value\n   If no errors occur, the tangent of arg (tan(arg)) is returned.\nThe result may have little or no significance if the magnitude of arg is large.\n (until C99)\n\n   If a domain error occurs, an implementation-defined value is returned (NaN where supported).\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   The case where the argument is infinite is not specified to be a domain error in C, but it is defined as a domain error in POSIX.\n   The function has mathematical poles at \u03c0(1/2 + n); however no common floating-point representation is able to represent \u03c0/2 exactly, thus there is no value of the argument for which a pole error occurs.\n", "url": "https://devdocs.io/c/numeric/math/tan\n"}, {"name": "tanh, tanhf, tanhl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       tanhf( float arg );\n  (1)   (since C99)\ndouble      tanh( double arg );\n  (2)\nlong double tanhl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define tanh( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value representing a hyperbolic angle\n\n\nReturn value\n   If a range error occurs due to underflow, the correct result (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   POSIX specifies that in case of underflow, arg is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.\n", "url": "https://devdocs.io/c/numeric/math/tanh\n"}, {"name": "tgamma, tgammaf, tgammal", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       tgammaf( float arg );\n  (1)   (since C99)\ndouble      tgamma( double arg );\n  (2)   (since C99)\nlong double tgammal( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define tgamma( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the value of the gamma function of arg, that is \u222b\u221e0targ-1 e-t dt, is returned.\n   If a domain error occurs, an implementation-defined value (NaN where supported) is returned.\n   If a pole error occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.\n   If a range error due to overflow occurs, \u00b1HUGE_VAL, \u00b1HUGE_VALF, or \u00b1HUGE_VALL is returned.\n   If a range error due to underflow occurs, the correct value (after rounding) is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If arg is zero or is an integer less than zero, a pole error or a domain error may occur.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   If arg is a natural number, tgamma(arg) is the factorial of arg-1. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.\n   For IEEE-compatible type double, overflow happens if 0 < x < 1/DBL_MAX or if x > 171.7.\n   POSIX requires that a pole error occurs if the argument is zero, but a domain error occurs when the argument is a negative integer. It also specifies that in future, domain errors may be replaced by pole errors for negative integer arguments (in which case the return value in those cases would change from NaN to \u00b1\u221e).\n   There is a non-standard function named gamma in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of gamma executes lgamma, but 4.4BSD version of gamma executes tgamma.\n", "url": "https://devdocs.io/c/numeric/math/tgamma\n"}, {"name": "trunc, truncf, truncl", "type": "STANDARD LIB", "description": "Defined in header <math.h>\nfloat       truncf( float arg );\n  (1)   (since C99)\ndouble      trunc( double arg );\n  (2)   (since C99)\nlong double truncl( long double arg );\n  (3)   (since C99)\nDefined in header <tgmath.h>\n#define trunc( arg )\n  (4)   (since C99)\n\n\nParameters\narg   -   floating point value\n\n\nReturn value\n   If no errors occur, the nearest integer value not greater in magnitude than arg (in other words, arg rounded towards zero), is returned.\n\nError handling\n   Errors are reported as specified in math_errhandling.\n   If the implementation supports IEEE floating-point arithmetic (IEC 60559),\n\nNotes\n   FE_INEXACT may be (but isn't required to be) raised when truncating a non-integer finite value.\n   The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including intmax_t), when stored in an integer variable.\n   The implicit conversion from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.\n", "url": "https://devdocs.io/c/numeric/math/trunc\n"}, {"name": "Type-generic math", "type": "STANDARD LIB", "description": "   The header <tgmath.h> includes the headers <math.h> and <complex.h> and defines several type-generic macros that determine which real or, when applicable, complex function to call based on the types of the arguments.\n   For each macro, the parameters whose corresponding real type in the unsuffixed math.h function is double are known as generic parameters (for example, both parameters of pow are generic parameters, but only the first parameter of scalbn is a generic parameter).\n   When a <tgmath.h> macro is used the types of the arguments passed to the generic parameters determine which function is selected by the macro as described below. If the types of the arguments are not compatible with the parameter types of the selected function, the behavior is undefined (e.g. if a complex argument is passed into a real-only tgmath macro: float complex fc; ceil(fc) or double complex dc; double d; fmax(dc, d) are examples of undefined behavior).\n   Note: type-generic macros were implemented in implementation-defined manner in C99, but C11 keyword _Generic makes it possible to implement these macros in portable manner.\n\nComplex/real type-generic macros\n   For all functions that have both real and complex counterparts, a type-generic macro XXX exists, which calls either of:\n   An exception to the above rule is the fabs macro (see the table below).\n   The function to call is determined as follows:\n   The type-generic macros are as follows:\nType-generic macro   Real function  variants   Complex function  variants\nfloat   double   long double   float   double   long double\nfabs   fabsf   fabs   fabsl   cabsf   cabs   cabsl\nexp   expf   exp   expl   cexpf   cexp   cexpl\nlog   logf   log   logl   clogf   clog   clogl\npow   powf   pow   powl   cpowf   cpow   cpowl\nsqrt   sqrtf   sqrt   sqrtl   csqrtf   csqrt   csqrtl\nsin   sinf   sin   sinl   csinf   csin   csinl\ncos   cosf   cos   cosl   ccosf   ccos   ccosl\ntan   tanf   tan   tanl   ctanf   ctan   ctanl\nasin   asinf   asin   asinl   casinf   casin   casinl\nacos   acosf   acos   acosl   cacosf   cacos   cacosl\natan   atanf   atan   atanl   catanf   catan   catanl\nsinh   sinhf   sinh   sinhl   csinhf   csinh   csinhl\ncosh   coshf   cosh   coshl   ccoshf   ccosh   ccoshl\ntanh   tanhf   tanh   tanhl   ctanhf   ctanh   ctanhl\nasinh   asinhf   asinh   asinhl   casinhf   casinh   casinhl\nacosh   acoshf   acosh   acoshl   cacoshf   cacosh   cacoshl\natanh   atanhf   atanh   atanhl   catanhf   catanh   catanhl\n\n\nReal-only functions\n   For all functions that do not have complex counterparts, with the exception of modf, a type-generic macro XXX exists, which calls either of the variants of a real function:\n   The function to call is determined as follows:\nType-generic macro   Real function  variants\nfloat   double   long double\natan2   atan2f   atan2   atan2l\ncbrt   cbrtf   cbrt   cbrtl\nceil   ceilf   ceil   ceill\ncopysign   copysignf   copysign   copysignl\nerf   erff   erf   erfl\nerfc   erfcf   erfc   erfcl\nexp2   exp2f   exp2   exp2l\nexpm1   expm1f   expm1   expm1l\nfdim   fdimf   fdim   fdiml\nfloor   floorf   floor   floorl\nfma   fmaf   fma   fmal\nfmax   fmaxf   fmax   fmaxl\nfmin   fminf   fmin   fminl\nfmod   fmodf   fmod   fmodl\nfrexp   frexpf   frexp   frexpl\nhypot   hypotf   hypot   hypotl\nilogb   ilogbf   ilogb   ilogbl\nldexp   ldexpf   ldexp   ldexpl\nlgamma   lgammaf   lgamma   lgammal\nllrint   llrintf   llrint   llrintl\nllround   llroundf   llround   llroundl\nlog10   log10f   log10   log10l\nlog1p   log1pf   log1p   log1pl\nlog2   log2f   log2   log2l\nlogb   logbf   logb   logbl\nlrint   lrintf   lrint   lrintl\nlround   lroundf   lround   lroundl\nnearbyint   nearbyintf   nearbyint   nearbyintl\nnextafter   nextafterf   nextafter   nextafterl\nnexttoward   nexttowardf   nexttoward   nexttowardl\nremainder   remainderf   remainder   remainderl\nremquo   remquof   remquo   remquol\nrint   rintf   rint   rintl\nround   roundf   round   roundl\nscalbln   scalblnf   scalbln   scalblnl\nscalbn   scalbnf   scalbn   scalbnl\ntgamma   tgammaf   tgamma   tgammal\ntrunc   truncf   trunc   truncl\n\n\nComplex-only functions\n   For all complex number functions that do not have real counterparts, a type-generic macro cXXX exists, which calls either of the variants of a complex function:\n   The function to call is determined as follows:\nType-generic macro   Complex function  variants\nfloat   double   long double\ncarg   cargf   carg   cargl\nconj   conjf   conj   conjl\ncreal   crealf   creal   creall\ncimag   cimagf   cimag   cimagl\ncproj   cprojf   cproj   cprojl\n\n", "url": "https://devdocs.io/c/numeric/tgmath\n"}, {"name": "_Complex_I", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\n#define _Complex_I /* unspecified */\n    (since C99)\n\n   The _Complex_I macro expands to a value of type const float _Complex with the value of the imaginary unit.\n\nNotes\n   This macro may be used when I is not available, such as when it has been undefined by the application.\n   Unlike _Imaginary_I and CMPLX, use of this macro to construct a complex number may lose the sign of zero on the imaginary component.\n", "url": "https://devdocs.io/c/numeric/complex/complex_i\n"}, {"name": "_Imaginary_I", "type": "STANDARD LIB", "description": "Defined in header <complex.h>\n#define _Imaginary_I /* unspecified */\n    (since C99)\n\n   The _Imaginary_I macro expands to a value of type const float _Imaginary with the value of the imaginary unit.\n   As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.\nA compiler that defines __STDC_IEC_559_COMPLEX__ is not required to support imaginary numbers. POSIX recommends checking if the macro _Imaginary_I is defined to identify imaginary number support.\n \n(since C99)(until C11)\nImaginary numbers are supported if __STDC_IEC_559_COMPLEX__ is defined.\n (since C11)\n\n\nNotes\n   This macro allows for the precise way to assemble a complex number from its real and imaginary components, e.g. with (double complex)((double)x + _Imaginary_I * (double)y). This pattern was standardized in C11 as the macro CMPLX. Note that if _Complex_I is used instead, this expression is allowed to convert negative zero to positive zero in the imaginary position.\n", "url": "https://devdocs.io/c/numeric/complex/imaginary_i\n"}, {"name": "abort", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid abort(void);\n    (until C11)\n_Noreturn void abort(void);\n    (since C11)\n\n   Causes abnormal program termination unless SIGABRT is being caught by a signal handler passed to signal and the handler does not return.\n   Functions passed to atexit() are not called. Whether open resources such as files are closed is implementation defined. An implementation defined status is returned to the host environment that indicates unsuccessful execution.\n\nParameters\n   (none).\n\nReturn value\n   (none).\n\nNotes\n   POSIX specifies that the abort() function overrides blocking or ignoring the SIGABRT signal.\n", "url": "https://devdocs.io/c/program/abort\n"}, {"name": "atexit", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint atexit( void (*func)(void) );\n\n   Registers the function pointed to by func to be called on normal program termination (via exit() or returning from main()). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.\n   The same function may be registered more than once.\n   atexit is thread-safe: calling the function from several threads does not induce a data race.\n   The implementation is guaranteed to support the registration of at least 32 functions. The exact limit is implementation-defined.\n\nParameters\nfunc   -   pointer to a function to be called on normal program termination\n\n\nReturn value\n   \u200b0\u200b if the registration succeeds, nonzero value otherwise.\n", "url": "https://devdocs.io/c/program/atexit\n"}, {"name": "at_quick_exit", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint at_quick_exit( void (*func)(void) );\n    (since C11)\n\n   Registers the function pointed to by func to be called on quick program termination (via quick_exit).\n   Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least 32 functions.\n\nParameters\nfunc   -   pointer to a function to be called on quick program termination\n\n\nReturn value\n   \u200b0\u200b if the registration succeeds, nonzero value otherwise.\n", "url": "https://devdocs.io/c/program/at_quick_exit\n"}, {"name": "exit", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nvoid exit( int exit_code );\n    (until C11)\n_Noreturn void exit( int exit_code );\n    (since C11)\n\n   Causes normal program termination to occur.\n   Several cleanup steps are performed:\n\nNotes\n   The functions registered with at_quick_exit are not called.\n   The behavior is undefined if a program calls exit more than once, or if it calls exit and quick_exit.\n   The behavior is undefined if during a call to a function registered with atexit, the function exits with longjmp.\n   Returning from the the main function, either by a return statement or by reaching the end of the function, executes exit(), passing the argument of the return statement (or \u200b0\u200b if implicit return was used) as exit_code.\n\nParameters\nexit_code   -   exit status of the program\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/program/exit\n"}, {"name": "EXIT_SUCCESS, EXIT_FAILURE", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\n#define EXIT_SUCCESS /*implementation defined*/\n#define EXIT_FAILURE /*implementation defined*/\n\n   The EXIT_SUCCESS and EXIT_FAILURE macros expand into integral expressions that can be used as arguments to the exit function (and, therefore, as the values to return from the main function), and indicate program execution status.\nConstant   Explanation\nEXIT_SUCCESS   successful execution of a program\nEXIT_FAILURE   unsuccessful execution of a program\n\n\nNotes\n   Both EXIT_SUCCESS and the value zero indicate successful program execution status (see exit), although it is not required that EXIT_SUCCESS equals zero.\n", "url": "https://devdocs.io/c/program/exit_status\n"}, {"name": "getenv, getenv_s", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nchar *getenv( const char *name );\n  (1)\nerrno_t getenv_s( size_t *restrict len, char *restrict value,\n                  rsize_t valuesz, const char *restrict name );\n  (2)   (since C11)\n\n\nParameters\nname   -   null-terminated character string identifying the name of the environmental variable to look for\nlen   -   pointer to a user-provided location where getenv_s will store the length of the environment variable\nvalue   -   pointer to a user-provided character array where getenv_s will store the contents of the environment variable\nvaluesz   -   maximum number of characters that getenv_s is allowed to write to dest (size of the buffer)\n\n\nReturn value\n\nNotes\n   On POSIX systems, the environment variables are also accessible through the global variable environ, declared as extern char **environ; in <unistd.h>, and through the optional third argument, envp, of the main function.\n   The call to getenv_s with a null pointer for value and zero for valuesz is used to determine the size of the buffer required to hold the entire result.\n", "url": "https://devdocs.io/c/program/getenv\n"}, {"name": "jmp_buf", "type": "STANDARD LIB", "description": "Defined in header <setjmp.h>\ntypedef /* unspecified */ jmp_buf;\n\n   The jmp_buf type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type jmp_buf.\n", "url": "https://devdocs.io/c/program/jmp_buf\n"}, {"name": "longjmp", "type": "STANDARD LIB", "description": "Defined in header <setjmp.h>\nvoid longjmp( jmp_buf env, int status );\n    (until C11)\n_Noreturn void longjmp( jmp_buf env, int status );\n    (since C11)\n\n   Loads the execution context env saved by a previous call to setjmp. This function does not return. Control is transferred to the call site of the macro setjmp that set up env. That setjmp then returns the value, passed as the status.\n   If the function that called setjmp has exited (whether by return or by a different longjmp higher up the stack), the behavior is undefined. In other words, only long jumps up the call stack are allowed.\nJumping across threads (if the function that called setjmp was executed by another thread) is also undefined behavior.\n (since C11)\n\nIf when setjmp was called, a VLA or another variably-modified type variable was in scope and control left that scope, longjmp to that setjmp invokes undefined behavior even if control remained within the function.\nOn the way up the stack, longjmp does not deallocate any VLAs, memory leaks may occur if their lifetimes are terminated in this way:\nvoid g(int n)\n{\n    int a[n]; // a may remain allocated\n    h(n); // does not return\n}\nvoid h(int n)\n{\n    int b[n]; // b may remain allocated\n    longjmp(buf, 2); // might cause a memory leak for h's b and g's a\n}  (since C99)\n\n\nParameters\nenv   -   variable referring to the execution state of the program saved by setjmp\nstatus   -   the value to return from setjmp. If it is equal to \u200b0\u200b, 1 is used instead\n\n\nReturn value\n   (none).\n\nNotes\n   longjmp is intended for handling unexpected error conditions where the function cannot return meaningfully. This is similar to exception handling in other programming languages.\n", "url": "https://devdocs.io/c/program/longjmp\n"}, {"name": "Program support utilities", "type": "STANDARD LIB", "description": "\nProgram termination\n   The following functions manage program termination and resource cleanup.\nDefined in header <stdlib.h>\nabort   causes abnormal program termination (without cleaning up)  (function)\nexit   causes normal program termination with cleaning up  (function)\nquick_exit\n(C11)   causes normal program termination without completely cleaning up  (function)\n_Exit\n(C99)   causes normal program termination without cleaning up  (function)\natexit   registers a function to be called on exit() invocation  (function)\nat_quick_exit\n(C11)   registers a function to be called on quick_exit invocation  (function)\nEXIT_SUCCESSEXIT_FAILURE   indicates program execution execution status  (macro constant)\n\n\nCommunicating with the environment\nsystem   calls the host environment's command processor  (function)\ngetenvgetenv_s\n(C11)   access to the list of environment variables  (function)\n\n\nSignals\n   Several functions and macro constants for signal management are provided.\nDefined in header <signal.h>\nsignal   sets a signal handler for particular signal  (function)\nraise   runs the signal handler for particular signal  (function)\nsig_atomic_t   the integer type that can be accessed as an atomic entity from an asynchronous signal handler  (typedef)\nSIG_DFLSIG_IGN   defines signal handling strategies  (macro constant)\nSIG_ERR   error was encountered  (macro constant)\nSignal types\nSIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM   defines signal types  (macro constant)\n\n\nNon-local jumps\nDefined in header <setjmp.h>\nsetjmp   saves the context  (function macro)\nlongjmp   jumps to specified location  (function)\nTypes\njmp_buf   execution context type  (typedef)\n\n", "url": "https://devdocs.io/c/program\n"}, {"name": "quick_exit", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\n_Noreturn void quick_exit( int exit_code );\n    (since C11)\n\n   Causes normal program termination to occur without completely cleaning the resources.\n   Functions passed to at_quick_exit are called in reverse order of their registration. After calling the registered functions, calls _Exit(exit_code).\n\nParameters\nexit_code   -   exit status of the program\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/program/quick_exit\n"}, {"name": "raise", "type": "STANDARD LIB", "description": "Defined in header <signal.h>\nint raise( int sig );\n\n   Sends signal sig to the program. The signal handler, specified using signal(), is invoked.\n   If the user-defined signal handling strategy is not set using signal() yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.\n\nParameters\nsig   -   the signal to be sent. It can be an implementation-defined value or one of the following values:     SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM   defines signal types  (macro constant)\nSIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM   defines signal types  (macro constant)\n\n\nReturn value\n   \u200b0\u200b upon success, non-zero value on failure.\n", "url": "https://devdocs.io/c/program/raise\n"}, {"name": "setjmp", "type": "STANDARD LIB", "description": "Defined in header <setjmp.h>\n#define setjmp(env) /* implementation-defined */\n\n   Saves the current execution context into a variable env of type jmp_buf. This variable can later be used to restore the current execution context by longjmp function. That is, when a call to longjmp function is made, the execution continues at the particular call site that constructed the jmp_buf variable passed to longjmp. In that case setjmp returns the value passed to longjmp.\n   The invocation of setjmp must appear only in one of the following contexts:\n   If setjmp appears in any other context, the behavior is undefined.\n   Upon return to the scope of setjmp, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when longjmp was executed, except for the non-volatile local variables in setjmp's scope, whose values are indeterminate if they have been changed since the setjmp invocation.\n\nParameters\nenv   -   variable to save the execution state of the program to.\n\n\nReturn value\n   \u200b0\u200b if the macro was called by the original code and the execution context was saved to env.\n   Non-zero value if a non-local jump was just performed. The return value is the same as passed to longjmp.\n", "url": "https://devdocs.io/c/program/setjmp\n"}, {"name": "SIGTERM, SIGSEGV, SIGINT, SIGILL, SIGABRT, SIGFPE", "type": "STANDARD LIB", "description": "Defined in header <signal.h>\n#define SIGTERM /*implementation defined*/\n#define SIGSEGV /*implementation defined*/\n#define SIGINT /*implementation defined*/\n#define SIGILL /*implementation defined*/\n#define SIGABRT /*implementation defined*/\n#define SIGFPE /*implementation defined*/\n\n   Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.\nConstant   Explanation\nSIGTERM   termination request, sent to the program\nSIGSEGV   invalid memory access (segmentation fault)\nSIGINT   external interrupt, usually initiated by the user\nSIGILL   invalid program image, such as invalid instruction\nSIGABRT   abnormal termination condition, as is e.g. initiated by abort()\nSIGFPE   erroneous arithmetic operation such as divide by zero\n\n", "url": "https://devdocs.io/c/program/sig_types\n"}, {"name": "signal", "type": "STANDARD LIB", "description": "Defined in header <signal.h>\nvoid (*signal( int sig, void (*handler) (int))) (int);\n\n   Sets the error handler for signal sig. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.\n   When signal handler is set to a function and a signal occurs, it is implementation defined whether signal(sig, SIG_DFL) will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.\n\nParameters\nsig   -   the signal to set the signal handler to. It can be an implementation-defined value or one of the following values:     SIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM   defines signal types  (macro constant)\nSIGABRTSIGFPESIGILLSIGINTSIGSEGVSIGTERM   defines signal types  (macro constant)\nhandler   -   the signal handler. This must be one of the following: \n\nSIG_DFL macro. The signal handler is set to default signal handler. \n\nSIG_IGN macro. The signal is ignored. \npointer to a function. The signature of the function must be equivalent to the following: \n    void fun(int sig);\nvoid fun(int sig);\n\n\nReturn value\n   Previous signal handler on success or SIG_ERR on failure (setting a signal handler can be disabled on some implementations).\n\nSignal handler\n   The following limitations are imposed on the user-defined function that is installed as a signal handler.\n   If the user defined function returns when handling SIGFPE, SIGILL or SIGSEGV, the behavior is undefined.\n   If the signal handler is called as a result of abort or raise, the behavior is undefined if the signal handler calls raise.\n   If the signal handler is called NOT as a result of abort or raise (in other words, the signal handler is asynchronous), the behavior is undefined if.\n   On entry to the signal handler, the state of the floating-point environment and the values of all objects is unspecified, except for.\n   On return from a signal handler, the value of any object modified by the signal handler that is not volatile sig_atomic_t or lock-free atomic(since C11) is undefined.\n   The behavior is undefined if signal is used in a multithreaded program. It is not required to be thread-safe.\n\nNotes\n   POSIX requires that signal is thread-safe, and specifies a list of async-signal-safe library functions that may be called from any signal handler.\n   Besides abort and raise, POSIX specifies that kill, pthread_kill, and sigqueue generate synchronous signals.\n   POSIX recommends sigaction instead of signal, due to its underspecified behavior and significant implementation variations, regarding signal delivery while a signal handler is executed.\n", "url": "https://devdocs.io/c/program/signal\n"}, {"name": "sig_atomic_t", "type": "STANDARD LIB", "description": "Defined in header <signal.h>\ntypedef /* unspecified */ sig_atomic_t;\n\n   An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.\n", "url": "https://devdocs.io/c/program/sig_atomic_t\n"}, {"name": "SIG_DFL, SIG_IGN", "type": "STANDARD LIB", "description": "Defined in header <signal.h>\n#define SIG_DFL /*implementation defined*/\n#define SIG_IGN /*implementation defined*/\n\n   The SIG_DFL and SIG_IGN macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for signal() function.\nConstant   Explanation\nSIG_DFL   default signal handling\nSIG_IGN   signal is ignored\n\n", "url": "https://devdocs.io/c/program/sig_strategies\n"}, {"name": "SIG_ERR", "type": "STANDARD LIB", "description": "Defined in header <signal.h>\n#define SIG_ERR /* implementation defined */\n\n   A value of type void (*)(int). When returned by signal, indicates that an error has occurred.\n", "url": "https://devdocs.io/c/program/sig_err\n"}, {"name": "system", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint system( const char *command );\n\n   Calls the host environment's command processor with the parameter command. Returns an implementation-defined value (usually the value that the invoked program returns).\n   If command is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.\n\nParameters\ncommand   -   character string identifying the command to be run in the command processor. If a null pointer is given, command processor is checked for existence\n\n\nReturn value\n   Implementation-defined value. If command is a null pointer, returns a nonzero value if and only if the command processor exists.\n\nNotes\n   On POSIX systems, the return value can be decomposed using WEXITSTATUS and WSTOPSIG.\n   The related POSIX function popen makes the output generated by command available to the caller.\n   In this example there is a system call of the unix command date +%A:\n", "url": "https://devdocs.io/c/program/system\n"}, {"name": "_Exit", "type": "STANDARD LIB", "description": "void _Exit( int exit_code );\n    (since C99) (until C11)\n_Noreturn void _Exit( int exit_code );\n    (since C11)\n\n   Causes normal program termination to occur without completely cleaning the resources.\n   Functions passed to at_quick_exit() or atexit() are not called. Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined.\n   If exit_code is 0 or EXIT_SUCCESS, an implementation-defined status indicating successful termination is returned to the host environment. If exit_code is EXIT_FAILURE, an implementation-defined status, indicating unsuccessful termination, is returned. In other cases an implementation-defined status value is returned.\n\nParameters\nexit_code   -   exit status of the program\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/program/_exit\n"}, {"name": "atof", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\ndouble atof( const char* str );\n\n   Interprets a floating-point value in a byte string pointed to by str.\n   Function discards any whitespace characters (as determined by std::isspace()) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n\nParameters\nstr   -   pointer to the null-terminated byte string to be interpreted\n\n\nReturn value\n   double value corresponding to the contents of str on success. If the converted value falls out of range of the return type, the return value is undefined. If no conversion can be performed, 0.0 is returned.\n", "url": "https://devdocs.io/c/string/byte/atof\n"}, {"name": "atoi, atol, atoll", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint       atoi( const char *str );\nlong      atol( const char *str );\nlong long atoll( const char *str );\n    (since C99)\n\n   Interprets an integer value in a byte string pointed to by str.\n   Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n\nParameters\nstr   -   pointer to the null-terminated byte string to be interpreted\n\n\nReturn value\n   Integer value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, \u200b0\u200b is returned.\n", "url": "https://devdocs.io/c/string/byte/atoi\n"}, {"name": "btowc", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwint_t btowc( int c );\n    (since C95)\n\n   Widens a single-byte character c (reinterpreted as unsigned char) to its wide character equivalent.\n   Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to wchar_t.\n\nParameters\nc   -   single-byte character to widen\n\n\nReturn value\n   WEOF if c is EOF.\n   wide character representation of c if (unsigned char)c is a valid single-byte character in the initial shift state, WEOF otherwise.\n", "url": "https://devdocs.io/c/string/multibyte/btowc\n"}, {"name": "c16rtomb", "type": "STANDARD LIB", "description": "Defined in header <uchar.h>\nsize_t c16rtomb( char * restrict s, char16_t c16, mbstate_t * restrict ps );\n    (since C11)\n\n   Converts a single code point from its variable-length 16-bit wide character representation (typically, UTF-16) to its narrow multibyte character representation.\n   If s is not a null pointer and c16 is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state *ps), and stores the multibyte character representation in the character array whose first element is pointed to by s, updating *ps as necessary. At most MB_CUR_MAX bytes can be written by this function.\n   If s is a null pointer, the call is equivalent to c16rtomb(buf, u'\\0', ps) for some internal buffer buf.\n   If c16 is the null wide character u'\\0', a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter *ps is updated to represent the initial shift state.\n   If c16 is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by s, only *ps is updated.\n   If the macro __STDC_UTF_16__ is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\nParameters\ns   -   pointer to narrow character array where the multibyte character will be stored\nc16   -   the 16-bit wide character to convert\nps   -   pointer to the conversion state object used when interpreting the multibyte string\n\n\nReturn value\n   On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by s. This value may be \u200b0\u200b, e.g. when processing the leading char16_t units in a multi-char16_t-unit sequence (occurs when processing the leading surrogate in a surrogate pair of UTF-16).\n   On failure (if c16 is not a valid 16-bit code unit), returns -1, stores EILSEQ in errno, and leaves *ps in unspecified state.\n\nNotes\n   In C11 as published, unlike mbrtoc16, which converts variable-width multibyte (such as UTF-8) to variable-width 16-bit (such as UTF-16) encoding, this function can only convert single-unit 16-bit encoding, meaning it cannot convert UTF-16 to UTF-8 despite that being the original intent of this function. This was corrected by the post-C11 defect report DR488.\n", "url": "https://devdocs.io/c/string/multibyte/c16rtomb\n"}, {"name": "c32rtomb", "type": "STANDARD LIB", "description": "Defined in header <uchar.h>\nsize_t c32rtomb( char * restrict s, char32_t c32, mbstate_t * restrict ps );\n    (since C11)\n\n   Converts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation.\n   If s is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of c32 (including any shift sequences, and taking into account the current multibyte conversion state *ps), and stores the multibyte character representation in the character array whose first element is pointed to by s, updating *ps as necessary. At most MB_CUR_MAX bytes can be written by this function.\n   If s is a null pointer, the call is equivalent to c32rtomb(buf, U'\\0', ps) for some internal buffer buf.\n   If c32 is the null wide character U'\\0', a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter *ps is updated to represent the initial shift state.\n   If the macro __STDC_UTF_32__ is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\nParameters\ns   -   pointer to narrow character array where the multibyte character will be stored\nc32   -   the 32-bit wide character to convert\nps   -   pointer to the conversion state object used when interpreting the multibyte string\n\n\nReturn value\n   On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by s. This value may be \u200b0\u200b, e.g. when processing the leading char32_t units in a multi-char32_t-unit sequence (does not occur in UTF-32).\n   On failure (if c32 is not a valid 32-bit wide character), returns -1, stores EILSEQ in errno, and leaves *ps in unspecified state.\n", "url": "https://devdocs.io/c/string/multibyte/c32rtomb\n"}, {"name": "char16_t", "type": "STANDARD LIB", "description": "Defined in header <uchar.h>\ntypedef uint_least16_t char16_t;\n    (since C11)\nDefined in header <stdint.h>\ntypedef /*implementation-defined*/ uint_least16_t;\n    (since C99)\n\n   char16_t is an unsigned integer type used for 16-bit wide characters and is the same type as uint_least16_t.\n   uint_least16_t is the smallest unsigned integer type with width of at least 16 bits.\n\nNotes\n   On any given platform, the width of type char16_t can be greater than 16 bits, but the actual values stored in an object of type char16_t will always have a width of 16 bits.\n", "url": "https://devdocs.io/c/string/multibyte/char16_t\n"}, {"name": "char32_t", "type": "STANDARD LIB", "description": "Defined in header <uchar.h>\ntypedef uint_least32_t char32_t;\n    (since C11)\nDefined in header <stdint.h>\ntypedef /*implementation-defined*/ uint_least32_t;\n    (since C99)\n\n   char32_t is an unsigned integer type used for 32-bit wide characters and is the same type as uint_least32_t.\n   uint_least32_t is the smallest unsigned integer type with width of at least 32 bits.\n\nNotes\n   On any given platform, the width of type char32_t can be greater than 32 bits, but the actual values stored in an object of type char32_t will always have a width of 32 bits.\n", "url": "https://devdocs.io/c/string/multibyte/char32_t\n"}, {"name": "isalnum", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isalnum( int ch );\n\n   Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is an alphanumeric character, 0 otherwise.\n", "url": "https://devdocs.io/c/string/byte/isalnum\n"}, {"name": "isalpha", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isalpha( int ch );\n\n   Checks if the given character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), or a lowercase letter (abcdefghijklmnopqrstuvwxyz).\n   In locales other than \"C\", an alphabetic character is a character for which isupper() or islower() returns true or any other character considered alphabetic by the locale. In any case, iscntrl(), isdigit(), ispunct() and isspace() will return false for this character.\n   The behavior is undefined if the value of ch is not representable as unsigned char or is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is an alphabetic character, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/isalpha\n"}, {"name": "isblank", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isblank( int ch );\n    (since C99)\n\n   Checks if the given character is a blank character in the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank.\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is a blank character, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/isblank\n"}, {"name": "iscntrl", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint iscntrl( int ch );\n\n   Checks if the given character is a control character, i.e. codes 0x00-0x1F and 0x7F.\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is a control character, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/iscntrl\n"}, {"name": "isdigit", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isdigit( int ch );\n\n   Checks if the given character is a numeric character (0123456789).\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is a numeric character, zero otherwise.\n\nNotes\n   isdigit and isxdigit are the only standard narrow character classification functions that are not affected by the currently installed C locale, although some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits.\n", "url": "https://devdocs.io/c/string/byte/isdigit\n"}, {"name": "isgraph", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isgraph( int ch );\n\n   Checks if the given character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), or a punctuation character(!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~), or any graphical character specific to the current C locale.\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character has a graphical representation character, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/isgraph\n"}, {"name": "islower", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint islower( int ch );\n\n   Checks if the given character is classified as a lowercase character according to the current C locale. In the default \"C\" locale, islower returns true only for the lowercase letters (abcdefghijklmnopqrstuvwxyz).\n   If islower returns true, it is guaranteed that iscntrl, isdigit, ispunct, and isspace return false for the same character in the same C locale.\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is a lowercase letter, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/islower\n"}, {"name": "isprint", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isprint( int ch );\n\n   Checks if the given character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~), or space, or any character classified as printable by the current C locale.\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character can be printed, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/isprint\n"}, {"name": "ispunct", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint ispunct( int ch );\n\n   Checks if the given character is a punctuation character in the current C locale. The default C locale classifies the characters !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ as punctuation.\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is a punctuation character, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/ispunct\n"}, {"name": "isspace", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isspace( int ch );\n\n   Checks if the given character is a whitespace character, i.e. either space (0x20), form feed (0x0c), line feed (0x0a), carriage return (0x0d), horizontal tab (0x09) or vertical tab (0x0b).\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is a whitespace character, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/isspace\n"}, {"name": "isupper", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isupper( int ch );\n\n   Checks if the given character is an uppercase character according to the current C locale. In the default \"C\" locale, isupper returns true only for the uppercase letters (ABCDEFGHIJKLMNOPQRSTUVWXYZ).\n   If isupper returns true, it is guaranteed that iscntrl, isdigit, ispunct, and isspace return false for the same character in the same C locale.\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is an uppercase letter, zero otherwise.\n", "url": "https://devdocs.io/c/string/byte/isupper\n"}, {"name": "iswalnum", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswalnum( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is a alphanumeric character, zero otherwise.\n\nNotes\n   ISO 30112 specifies which Unicode characters are include in POSIX alnum category.\n", "url": "https://devdocs.io/c/string/wide/iswalnum\n"}, {"name": "iswalpha", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswalpha( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is a alphabetic character, zero otherwise.\n\nNotes\n   ISO 30112 specifies which Unicode characters are include in POSIX alpha category.\n", "url": "https://devdocs.io/c/string/wide/iswalpha\n"}, {"name": "iswblank", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswblank( wint_t ch );\n    (since C99)\n\n   Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is a blank character, zero otherwise.\n\nNotes\n   ISO 30112 defines POSIX blank characters as Unicode characters U+0009, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008, U+200A, U+205F, and U+3000.\n", "url": "https://devdocs.io/c/string/wide/iswblank\n"}, {"name": "iswcntrl", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswcntrl( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is a control character, zero otherwise.\n\nNotes\n   ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).\n", "url": "https://devdocs.io/c/string/wide/iswcntrl\n"}, {"name": "iswctype", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswctype( wint_t wc, wctype_t desc );\n    (since C95)\n\n   Classifies the wide character wc using the current C locale's LC_CTYPE category identified by desc.\n\nParameters\nwc   -   the wide character to classify\ndesc   -   the LC_CTYPE category, obtained from a call to wctype\n\n\nReturn value\n   Non-zero if the character wc has the property identified by desc in LC_CTYPE facet of the current C locale, zero otherwise.\n", "url": "https://devdocs.io/c/string/wide/iswctype\n"}, {"name": "iswdigit", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswdigit( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is an numeric character, zero otherwise.\n\nNotes\n   iswdigit and iswxdigit are the only standard wide character classification functions that are not affected by the currently installed C locale.\n", "url": "https://devdocs.io/c/string/wide/iswdigit\n"}, {"name": "iswgraph", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswgraph( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~) or any graphical character specific to the current C locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character has a graphical representation character, zero otherwise.\n\nNotes\n   ISO 30112 specifies which Unicode characters are include in POSIX graph category.\n", "url": "https://devdocs.io/c/string/wide/iswgraph\n"}, {"name": "iswlower", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswlower( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is an lowercase letter, zero otherwise.\n\nNotes\n   ISO 30112 specifies which Unicode characters are include in POSIX lower category.\n", "url": "https://devdocs.io/c/string/wide/iswlower\n"}, {"name": "iswprint", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswprint( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~), space or any printable character specific to the current C locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character can be printed, zero otherwise.\n\nNotes\n   ISO 30112 specifies which Unicode characters are include in POSIX print category.\n", "url": "https://devdocs.io/c/string/wide/iswprint\n"}, {"name": "iswpunct", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswpunct( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character is a punctuation character, i.e. it is one of !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ or any punctuation character specific to the current locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is a punctuation character, zero otherwise.\n\nNotes\n   ISO 30112 specifies which Unicode characters are include in POSIX punct category.\n", "url": "https://devdocs.io/c/string/wide/iswpunct\n"}, {"name": "iswspace", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswspace( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character is a whitespace character, i.e. either space (0x20), form feed (0x0c), line feed (0x0a), carriage return (0x0d), horizontal tab (0x09), vertical tab (0x0b) or any whitespace character specific to the current locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is a whitespace character, zero otherwise.\n\nNotes\n   ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.\n", "url": "https://devdocs.io/c/string/wide/iswspace\n"}, {"name": "iswupper", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswupper( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is an uppercase letter, zero otherwise.\n\nNotes\n   ISO 30112 specifies which Unicode characters are include in POSIX upper category.\n", "url": "https://devdocs.io/c/string/wide/iswupper\n"}, {"name": "iswxdigit", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nint iswxdigit( wint_t ch );\n    (since C95)\n\n   Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF.\n\nParameters\nch   -   wide character\n\n\nReturn value\n   Non-zero value if the wide character is a hexadecimal numeric character, zero otherwise.\n\nNotes\n   iswdigit and iswxdigit are the only standard wide character classification functions that are not affected by the currently installed C locale.\n", "url": "https://devdocs.io/c/string/wide/iswxdigit\n"}, {"name": "isxdigit", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint isxdigit( int ch );\n\n   Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF) or is classified as a hexadecimal character.\n   The behavior is undefined if the value of ch is not representable as unsigned char and is not equal to EOF.\n\nParameters\nch   -   character to classify\n\n\nReturn value\n   Non-zero value if the character is an hexadecimal numeric character, zero otherwise.\n\nNotes\n   isdigit and isxdigit are the only standard narrow character classification functions that are not affected by the currently installed C locale. although some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits.\n", "url": "https://devdocs.io/c/string/byte/isxdigit\n"}, {"name": "mblen", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint mblen( const char* s, size_t n );\n\n   Determines the size, in bytes, of the multibyte character whose first byte is pointed to by s.\n   If s is a null pointer, resets the global conversion state and determined whether shift sequences are used.\n   This function is equivalent to the call mbtowc((wchar_t*)0, s, n), except that conversion state of mbtowc is unaffected.\n\nNotes\n   Each call to mblen updates the internal global conversion state (a static object of type mbstate_t, only known to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call mblen without synchronization: mbrlen may be used instead.\n\nParameters\ns   -   pointer to the multibyte character\nn   -   limit on the number of bytes in s that can be examined\n\n\nReturn value\n   If s is not a null pointer, returns the number of bytes that are contained in the multibyte character or -1 if the first bytes pointed to by s do not form a valid multibyte character or \u200b0\u200b if s is pointing at the null charcter '\\0'.\n   If s is a null pointer, resets its internal conversion state to represent the initial shift state and returns \u200b0\u200b if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).\n", "url": "https://devdocs.io/c/string/multibyte/mblen\n"}, {"name": "mbrlen", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nsize_t mbrlen( const char *s, size_t n, mbstate_t *ps );\n    (since C95) (until C99)\nsize_t mbrlen( const char *restrict s, size_t n, mbstate_t *restrict ps );\n    (since C99)\n\n   Determines the size, in bytes, of the representation of a multibyte character.\n   This function is equivalent to the call mbrtowc(nullptr, s, n, ps?ps:&internal) for some hidden object internal of type mbstate_t, except that the expression ps is evaluated only once.\n\nParameters\ns   -   pointer to an element of a multibyte character string\nn   -   limit on the number of bytes in s that can be examined\nps   -   pointer to the variable holding the conversion state\n\n\nReturn value\n   The first of the following that applies:\n", "url": "https://devdocs.io/c/string/multibyte/mbrlen\n"}, {"name": "mbrtoc16", "type": "STANDARD LIB", "description": "Defined in header <uchar.h>\nsize_t mbrtoc16( char16_t * restrict pc16, const char * restrict s,\n                 size_t n, mbstate_t * restrict ps );\n    (since C11)\n\n   Converts a single code point from its narrow multibyte character representation to its variable-length 16-bit wide character representation (typically, UTF-16).\n   If s is not a null pointer, inspects at most n bytes of the multibyte character string, beginning with the byte pointed to by s to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state *ps). If the function determines that the next multibyte character in s is complete and valid, converts it to the corresponding 16-bit wide character and stores it in *pc16 (if pc16 is not null).\n   If the multibyte character in *s corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, *ps is updated in such a way that the next call to mbrtoc16 will write out the additional char16_t, without considering *s.\n   If s is a null pointer, the values of n and pc16 are ignored and the call is equivalent to mbrtoc16(NULL, \"\", 1, ps).\n   If the wide character produced is the null character, the conversion state *ps represents the initial shift state.\n   If the macro __STDC_UTF_16__ is defined, the 16-bit encoding used by this function is UTF-16; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\nParameters\npc16   -   pointer to the location where the resulting 16-bit wide character will be written\ns   -   pointer to the multibyte character string used as input\nn   -   limit on the number of bytes in s that can be examined\nps   -   pointer to the conversion state object used when interpreting the multibyte string\n\n\nReturn value\n   The first of the following that applies:\n", "url": "https://devdocs.io/c/string/multibyte/mbrtoc16\n"}, {"name": "mbrtoc32", "type": "STANDARD LIB", "description": "Defined in header <uchar.h>\nsize_t mbrtoc32( char32_t restrict * pc32, const char * restrict s,\n                 size_t n, mbstate_t * restrict ps );\n    (since C11)\n\n   Converts a single code point from its narrow multibyte character representation to its variable-length 32-bit wide character representation (but typically, UTF-32).\n   If s is not a null pointer, inspects at most n bytes of the multibyte character string, beginning with the byte pointed to by s to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state *ps). If the function determines that the next multibyte character in s is complete and valid, converts it to the corresponding 32-bit wide character and stores it in *pc32 (if pc32 is not null).\n   If the multibyte character in *s corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, *ps is updated in such a way that the next calls to mbrtoc32 will write out the additional char32_t, without considering *s.\n   If s is a null pointer, the values of n and pc32 are ignored and the call is equivalent to mbrtoc32(NULL, \"\", 1, ps).\n   If the wide character produced is the null character, the conversion state *ps represents the initial shift state.\n   If the macro __STDC_UTF_32__ is defined, the 32-bit encoding used by this function is UTF-32; otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\nParameters\npc32   -   pointer to the location where the resulting 32-bit wide character will be written\ns   -   pointer to the multibyte character string used as input\nn   -   limit on the number of bytes in s that can be examined\nps   -   pointer to the conversion state object used when interpreting the multibyte string\n\n\nReturn value\n   The first of the following that applies:\n", "url": "https://devdocs.io/c/string/multibyte/mbrtoc32\n"}, {"name": "mbrtowc", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nsize_t mbrtowc( wchar_t* pwc, const char* s, size_t n, mbstate_t* ps );\n    (since C95)\nsize_t mbrtowc( wchar_t *restrict pwc, const char *restrict s, size_t n,\n                mbstate_t *restrict ps );\n    (since C99)\n\n   Converts a narrow multibyte character to its wide character representation.\n   If s is not a null pointer, inspects at most n bytes of the multibyte character string, beginning with the byte pointed to by s to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences, and taking into account the current multibyte conversion state *ps). If the function determines that the next multibyte character in s is complete and valid, converts it to the corresponding wide character and stores it in *pwc (if pwc is not null).\n   If s is a null pointer, the values of n and pwc are ignored and call is equivalent to mbrtowc(NULL, \"\", 1, ps).\n   If the wide character produced is the null character, the conversion state stored in *ps is the initial shift state.\n   If the environment macro __STDC_ISO_10646__ is defined, the values of type wchar_t are the same as the short identifiers of the characters in the Unicode required set (typically UTF-32 encoding); otherwise, it is implementation-defined. In any case, the multibyte character encoding used by this function is specified by the currently active C locale.\n\nParameters\npwc   -   pointer to the location where the resulting wide character will be written\ns   -   pointer to the multibyte character string used as input\nn   -   limit on the number of bytes in s that can be examined\nps   -   pointer to the conversion state used when interpreting the multibyte character string\n\n\nReturn value\n   The first of the following that applies:\n", "url": "https://devdocs.io/c/string/multibyte/mbrtowc\n"}, {"name": "mbsinit", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint mbsinit( const mbstate_t* ps);\n    (since C95)\n\n   If ps is not a null pointer, the mbsinit function determines whether the pointed-to mbstate_t object describes the initial conversion state.\n\nNotes\n   Although a zero-initialized mbstate_t always represents the initial conversion state, there may be other values of mbstate_t that also represent the initial conversion state.\n\nParameters\nps   -   pointer to the mbstate_t object to examine\n\n\nReturn value\n   \u200b0\u200b if ps is not a null pointer and does not represent the initial conversion state, nonzero value otherwise.\n", "url": "https://devdocs.io/c/string/multibyte/mbsinit\n"}, {"name": "mbsrtowcs, mbsrtowcs_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nsize_t mbsrtowcs( wchar_t* dst, const char** src, size_t len, mbstate_t* ps );\n  (since C95)\nsize_t mbsrtowcs( wchar_t *restrict dst, const char **restrict src, size_t len,\n                  mbstate_t *restrict ps);\n  (since C99)\nerrno_t mbsrtowcs_s( size_t *restrict retval,\n                     wchar_t *restrict dst, rsize_t dstsz,\n                     const char **restrict src, rsize_t len,\n                     mbstate_t *restrict ps);\n  (2)   (since C11)\n\n\nParameters\ndst   -   pointer to wide character array where the results will be stored\nsrc   -   pointer to pointer to the first element of a null-terminated multibyte string\nlen   -   number of wide characters available in the array pointed to by dst\nps   -   pointer to the conversion state object\ndstsz   -   max number of wide characters that will be written (size of the dst array)\nretval   -   pointer to a size_t object where the result will be stored\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/multibyte/mbsrtowcs\n"}, {"name": "mbstate_t", "type": "STANDARD LIB", "description": "Defined in header <uchar.h>    (since C11)\nDefined in header <wchar.h>\nstruct mbstate_t;\n    (since C95)\n\n   The type mbstate_t is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of mbstate_t represents the initial conversion state, although other values of mbstate_t may exist that also represent the initial conversion state.\n   Possible implementation of mbstate_t is a struct type holding an array representing the incomplete multibyte character, an integer counter indicating the number of bytes in the array that have been processed, and a representation of the current shift state.\n   The following functions should not be called from multiple threads without synchronization with the mbstate_t* argument of NULL due to possible data races: mbrlen, mbrtowc, mbsrtowcs, mbtowc, wcrtomb, wcsrtombs, wctomb.\n", "url": "https://devdocs.io/c/string/multibyte/mbstate_t\n"}, {"name": "mbstowcs, mbstowcs_s", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\n(1)\nsize_t mbstowcs( wchar_t          *dst, const char          *src, size_t len)\n  (until C99)\nsize_t mbstowcs( wchar_t *restrict dst, const char *restrict src, size_t len)\n  (since C99)\nerrno_t mbstowcs_s(size_t *restrict retval, wchar_t *restrict dst,\n                  rsize_t dstsz, const char *restrict src, rsize_t len);\n  (2)   (since C11)\n\n\nNotes\n   In most implementations, mbstowcs updates a global static object of type mbstate_t as it processes through the string, and cannot be called simultaneously by two threads, mbsrtowcs should be used in such cases.\n   POSIX specifies a common extension: if dst is a null pointer, this function returns the number of wide characters that would be written to dst, if converted. Similar behavior is standard for mbstowcs_s and for mbsrtowcs.\n\nParameters\ndst   -   pointer to wide character array where the wide string will be stored\nsrc   -   pointer to the first element of a null-terminated multibyte string to convert\nlen   -   number of wide characters available in the array pointed to by dst\ndstsz   -   max number of wide characters that will be written (size of the dst array)\nretval   -   pointer to a size_t object where the result will be stored\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/multibyte/mbstowcs\n"}, {"name": "mbtowc", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint mbtowc( wchar_t          *pwc, const char          *s, size_t n )\n    (until C99)\nint mbtowc( wchar_t *restrict pwc, const char *restrict s, size_t n )\n    (since C99)\n\n   Converts a multibyte character whose first byte is pointed to by s to a wide character, written to *pwc if pwc is not null.\n   If s is a null pointer, resets the global conversion state and determines whether shift sequences are used.\n\nNotes\n   Each call to mbtowc updates the internal global conversion state (a static object of type mbstate_t, known only to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call mbtowc without synchronization: mbrtowc may be used instead.\n\nParameters\npwc   -   pointer to the wide character for output\ns   -   pointer to the multibyte character\nn   -   limit on the number of bytes in s that can be examined\n\n\nReturn value\n   If s is not a null pointer, returns the number of bytes that are contained in the multibyte character or -1 if the first bytes pointed to by s do not form a valid multibyte character or \u200b0\u200b if s is pointing at the null charcter '\\0'.\n   If s is a null pointer, resets its internal conversion state to represent the initial shift state and returns \u200b0\u200b if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).\n", "url": "https://devdocs.io/c/string/multibyte/mbtowc\n"}, {"name": "memchr", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nvoid* memchr( const void* ptr, int ch, size_t count );\n\n   Finds the first occurrence of ch (after conversion to unsigned char as if by (unsigned char)ch) in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.\n   The behavior is undefined if access occurs beyond the end of the array searched. The behavior is undefined if ptr is a null pointer.\nThis function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by ptr is smaller than count, but the match is found within the array, the behavior is well-defined.\n (since C11)\n\n\nParameters\nptr   -   pointer to the object to be examined\nch   -   character to search for\ncount   -   max number of characters to examine\n\n\nReturn value\n   Pointer to the location of the character, or NULL if no such character is found.\n", "url": "https://devdocs.io/c/string/byte/memchr\n"}, {"name": "memcmp", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nint memcmp( const void* lhs, const void* rhs, size_t count );\n\n   Compares the first count characters of the objects pointed to by lhs and rhs. The comparison is done lexicographically.\n   The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as unsigned char) that differ in the objects being compared.\n   The behavior is undefined if access occurs beyond the end of either object pointed to by lhs and rhs. The behavior is undefined if either lhs or rhs is a null pointer.\n\nParameters\nlhs, rhs   -   pointers to the objects to compare\ncount   -   number of bytes to examine\n\n\nReturn value\n   Negative value if lhs appears before rhs in lexicographical order.\n   Zero if lhs and rhs compare equal, or if count is zero.\n   Positive value if lhs appears after rhs in lexicographical order.\n\nNotes\n   This function reads object representations, not the object values, and is typically meaningful for byte arrays only: structs may have padding bytes whose values are indeterminate, the values of any bytes beyond the last stored member in a union are indeterminate, and a type may have two or more representations for the same value (different encodings for +0 and -0 or for +0.0 and \u20130.0, indeterminate padding bits within the type).\n", "url": "https://devdocs.io/c/string/byte/memcmp\n"}, {"name": "memcpy, memcpy_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\n(1)\nvoid* memcpy( void *dest, const void *src, size_t count );\n  (until C99)\nvoid* memcpy( void *restrict dest, const void *restrict src, size_t count );\n  (since C99)\nerrno_t memcpy_s( void *restrict dest, rsize_t destsz,\n                  const void *restrict src, rsize_t count );\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the object to copy to\ndestsz   -   max number of bytes to modify in the destination (typically the size of the destination object)\nsrc   -   pointer to the object to copy from\ncount   -   number of bytes to copy\n\n\nReturn value\n\nNotes\n   memcpy may be used to set the effective type of an object obtained by an allocation function.\n   memcpy is the fastest library routine for memory-to-memory copy. It is usually more efficient than strcpy, which must scan the data it copies or memmove, which must take precautions to handle overlapping inputs.\n   Several C compilers transform suitable memory-copying loops to memcpy calls.\n   Where strict aliasing prohibits examining the same memory as values of two different types, memcpy may be used to convert the values.\n", "url": "https://devdocs.io/c/string/byte/memcpy\n"}, {"name": "memmove, memmove_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nvoid* memmove( void* dest, const void* src, size_t count );\n  (1)\nerrno_t memmove_s(void *dest, rsize_t destsz, const void *src, rsize_t count);\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the object to copy to\ndestsz   -   max number of bytes to modify in the destination (typically the size of the destination object)\nsrc   -   pointer to the object to copy from\ncount   -   number of bytes to copy\n\n\nReturn value\n\nNotes\n   memmove may be used to set the effective type of an object obtained by an allocation function.\n   Despite being specified \"as if\" a temporary buffer is used, actual implementations of this function do not incur the overhead or double copying or extra memory. A common approach (glibc and bsd libc) is to copy bytes forwards from the beginning of the buffer if the destination starts before the source, and backwards from the end otherwise, with a fall back to the more efficient memcpy when there is no overlap at all.\n   Where strict aliasing prohibits examining the same memory as values of two different types, memmove may be used to convert the values.\n", "url": "https://devdocs.io/c/string/byte/memmove\n"}, {"name": "memset, memset_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nvoid *memset( void *dest, int ch, size_t count );\n  (1)\nerrno_t memset_s( void *dest, rsize_t destsz, int ch, rsize_t count );\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the object to fill\nch   -   fill byte\ncount   -   number of bytes to fill\ndestsz   -   size of the destination array\n\n\nReturn value\n\nNotes\n   memset may be optimized away (under the as-if rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g. gcc bug 8537). For that reason, this function cannot be used to scrub memory (e.g. to fill an array that stored a password with zeroes). This optimization is prohibited for memset_s: it is guaranteed to perform the memory write. Third-party solutions for that include FreeBSD explicit_bzero or Microsoft SecureZeroMemory.\n", "url": "https://devdocs.io/c/string/byte/memset\n"}, {"name": "Null-terminated byte strings", "type": "STANDARD LIB", "description": "   A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array {'\\x63','\\x61','\\x74','\\0'} is an NTBS holding the string \"cat\" in ASCII encoding.\n\nFunctions\nCharacter classification\nDefined in header <ctype.h>\nisalnum   checks if a character is alphanumeric  (function)\nisalpha   checks if a character is alphabetic  (function)\nislower   checks if a character is lowercase  (function)\nisupper   checks if a character is an uppercase character  (function)\nisdigit   checks if a character is a digit  (function)\nisxdigit   checks if a character is a hexadecimal character  (function)\niscntrl   checks if a character is a control character  (function)\nisgraph   checks if a character is a graphical character  (function)\nisspace   checks if a character is a space character  (function)\nisblank\n(C99)   checks if a character is a blank character  (function)\nisprint   checks if a character is a printing character  (function)\nispunct   checks if a character is a punctuation character  (function)\nCharacter manipulation\ntolower   converts a character to lowercase  (function)\ntoupper   converts a character to uppercase  (function)\n\n   Note: additional functions whose names begin with either to or is, followed by a lowercase letter, may be added to the header ctype.h in future and should not be defined by programs that include that header.\nASCII values   characters   iscntrl iswcntrl.\n  isprint iswprint.\n  isspace iswspace.\n  isblank iswblank.\n  isgraph iswgraph.\n  ispunct  iswpunct.\n  isalnum  iswalnum.\n  isalpha  iswalpha.\n  isupper iswupper.\n  islower iswlower.\n  isdigit iswdigit.\n  isxdigit iswxdigit.\ndecimal   hexadecimal   octal\n0\u20138   \\x0\u2013\\x8   \\0\u2013\\10   control codes (NUL, etc.)  \n\u22600   0   0   0   0   0   0   0   0   0   0   0\n9   \\x9   \\11   tab (\\t)  \n\u22600   0  \n\u22600  \n\u22600   0   0   0   0   0   0   0   0\n10\u201313   \\xA\u2013\\xD   \\12\u2013\\15   whitespaces (\\n, \\v, \\f, \\r)  \n\u22600   0  \n\u22600   0   0   0   0   0   0   0   0   0\n14\u201331   \\xE\u2013\\x1F   \\16\u2013\\37   control codes  \n\u22600   0   0   0   0   0   0   0   0   0   0   0\n32   \\x20   \\40   space   0  \n\u22600  \n\u22600  \n\u22600   0   0   0   0   0   0   0   0\n33\u201347   \\x21\u2013\\x2F   \\41\u2013\\57   !\"#$%&'()*+,-./   0  \n\u22600   0   0  \n\u22600  \n\u22600   0   0   0   0   0   0\n48\u201357   \\x30\u2013\\x39   \\60\u2013\\71   0123456789   0  \n\u22600   0   0  \n\u22600   0  \n\u22600   0   0   0  \n\u22600  \n\u22600\n58\u201364   \\x3A\u2013\\x40   \\72\u2013\\100   :;<=>?@   0  \n\u22600   0   0  \n\u22600  \n\u22600   0   0   0   0   0   0\n65\u201370   \\x41\u2013\\x46   \\101\u2013\\106   ABCDEF   0  \n\u22600   0   0  \n\u22600   0  \n\u22600  \n\u22600  \n\u22600   0   0  \n\u22600\n71\u201390   \\x47\u2013\\x5A   \\107\u2013\\132   GHIJKLMNOPQRSTUVWXYZ   0  \n\u22600   0   0  \n\u22600   0  \n\u22600  \n\u22600  \n\u22600   0   0   0\n91\u201396   \\x5B\u2013\\x60   \\133\u2013\\140   [\\]^_`   0  \n\u22600   0   0  \n\u22600  \n\u22600   0   0   0   0   0   0\n97\u2013102   \\x61\u2013\\x66   \\141\u2013\\146   abcdef   0  \n\u22600   0   0  \n\u22600   0  \n\u22600  \n\u22600   0  \n\u22600   0  \n\u22600\n103\u2013122   \\x67\u2013\\x7A   \\147\u2013\\172   ghijklmnopqrstuvwxyz   0  \n\u22600   0   0  \n\u22600   0  \n\u22600  \n\u22600   0  \n\u22600   0   0\n123\u2013126   \\x7B\u2013\\x7E   \\172\u2013\\176   {|}~   0  \n\u22600   0   0  \n\u22600  \n\u22600   0   0   0   0   0   0\n127   \\x7F   \\177   backspace character (DEL)  \n\u22600   0   0   0   0   0   0   0   0   0   0   0\n\nConversions to numeric formats\nDefined in header <stdlib.h>\natof   converts a byte string to a floating-point value  (function)\natoiatolatoll\n(C99)   converts a byte string to an integer value  (function)\nstrtolstrtoll\n(C99)   converts a byte string to an integer value  (function)\nstrtoul strtoull\n(C99)   converts a byte string to an unsigned integer value  (function)\nstrtofstrtodstrtold\n(C99)(C99)   converts a byte string to a floating point value  (function)\nDefined in header <inttypes.h>\nstrtoimaxstrtoumax\n(C99)(C99)   converts a byte string to intmax_t or uintmax_t  (function)\nString manipulation\nDefined in header <string.h>\nstrcpystrcpy_s\n(C11)   copies one string to another  (function)\nstrncpystrncpy_s\n(C11)   copies a certain amount of characters from one string to another  (function)\nstrcatstrcat_s\n(C11)   concatenates two strings  (function)\nstrncatstrncat_s\n(C11)   concatenates a certain amount of characters of two strings  (function)\nstrxfrm   transform a string so that strcmp would produce the same result as strcoll  (function)\nString examination\nDefined in header <string.h>\nstrlenstrnlen_s\n(C11)   returns the length of a given string  (function)\nstrcmp   compares two strings  (function)\nstrncmp   compares a certain amount of characters of two strings  (function)\nstrcoll   compares two strings in accordance to the current locale  (function)\nstrchr   finds the first occurrence of a character  (function)\nstrrchr   finds the last occurrence of a character  (function)\nstrspn   returns the length of the maximum initial segment that consists  of only the characters found in another byte string  (function)\nstrcspn   returns the length of the maximum initial segment that consists  of only the characters not found in another byte string  (function)\nstrpbrk   finds the first location of any character in one string, in another string  (function)\nstrstr   finds the first occurrence of a substring of characters  (function)\nstrtokstrtok_s\n(C11)   finds the next token in a byte string  (function)\nCharacter array manipulation\nDefined in header <string.h>\nmemchr   searches an array for the first occurrence of a character  (function)\nmemcmp   compares two buffers  (function)\nmemsetmemset_s\n(C11)   fills a buffer with a character  (function)\nmemcpymemcpy_s\n(C11)   copies one buffer to another  (function)\nmemmovememmove_s\n(C11)   moves one buffer to another  (function)\nMiscellaneous\nDefined in header <string.h>\nstrerrorstrerror_sstrerrorlen_s\n(C11)(C11)   returns a text version of a given error code  (function)\n\n", "url": "https://devdocs.io/c/string/byte\n"}, {"name": "Null-terminated multibyte strings", "type": "STANDARD LIB", "description": "   A null-terminated multibyte string (NTMBS), or \"multibyte string\", is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).\n   Each character stored in the string may occupy more than one byte. The encoding used to represent characters in a multibyte character string is locale-specific: it may be UTF-8, GB18030, EUC-JP, Shift-JIS, etc. For example, the char array {'\\xe4','\\xbd','\\xa0','\\xe5','\\xa5','\\xbd','\\0'} is an NTMBS holding the string \"\u4f60\u597d\" in UTF-8 multibyte encoding: the first three bytes encode the character \u4f60, the next three bytes encode the character \u597d. The same string encoded in GB18030 is the char array {'\\xc4', '\\xe3', '\\xba', '\\xc3', '\\0'}, where each of the two characters is encoded as a two-byte sequence.\n   In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as \"shift sequences\". Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are BOCU-1 and SCSU.\n   A multibyte character string is layout-compatible with null-terminated byte string (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the following locale-dependent conversion functions:\n\nMultibyte/wide character conversions\nDefined in header <stdlib.h>\nmblen   returns the number of bytes in the next multibyte character  (function)\nmbtowc   converts the next multibyte character to wide character  (function)\nwctombwctomb_s\n(C11)   converts a wide character to its multibyte representation  (function)\nmbstowcsmbstowcs_s\n(C11)   converts a narrow multibyte character string to wide string  (function)\nwcstombswcstombs_s\n(C11)   converts a wide string to narrow multibyte character string  (function)\nDefined in header <wchar.h>\nmbsinit\n(C95)   checks if the mbstate_t object represents initial shift state  (function)\nbtowc\n(C95)   widens a single-byte narrow character to wide character, if possible  (function)\nwctob\n(C95)   narrows a wide character to a single-byte narrow character, if possible  (function)\nmbrlen\n(C95)   returns the number of bytes in the next multibyte character, given state  (function)\nmbrtowc\n(C95)   converts the next multibyte character to wide character, given state  (function)\nwcrtombwcrtomb_s\n(C95)(C11)   converts a wide character to its multibyte representation, given state  (function)\nmbsrtowcsmbsrtowcs_s\n(C95)(C11)   converts a narrow multibyte character string to wide string, given state  (function)\nwcsrtombswcsrtombs_s\n(C95)(C11)   converts a wide string to narrow multibyte character string, given state  (function)\nDefined in header <uchar.h>\nmbrtoc16\n(C11)   generates the next 16-bit wide character from a narrow multibyte string  (function)\nc16rtomb\n(C11)   converts a 16-bit wide character to narrow multibyte string  (function)\nmbrtoc32\n(C11)   generates the next 32-bit wide character from a narrow multibyte string  (function)\nc32rtomb\n(C11)   converts a 32-bit wide character to narrow multibyte string  (function)\n\n\nTypes\nDefined in header <wchar.h>\nmbstate_t\n(C95)   conversion state information necessary to iterate multibyte character strings  (class)\nDefined in header <uchar.h>\nchar16_t\n(C11)   16-bit wide character type  (typedef)\nchar32_t\n(C11)   32-bit wide character type  (typedef)\n\n\nMacros\nDefined in header <limits.h>\nMB_LEN_MAX   maximum number of bytes in a multibyte character, for any supported locale  (macro constant)\nDefined in header <stdlib.h>\nMB_CUR_MAX   maximum number of bytes in a multibyte character, in the current locale(macro variable)\nDefined in header <uchar.h>\n__STDC_UTF_16__\n(C11)   indicates that UTF-16 encoding is used by mbrtoc16 and c16rtomb  (macro constant)\n__STDC_UTF_32__\n(C11)   indicates that UTF-32 encoding is used by mbrtoc32 and c32rtomb  (macro constant)\n\n", "url": "https://devdocs.io/c/string/multibyte\n"}, {"name": "Null-terminated wide strings", "type": "STANDARD LIB", "description": "   A null-terminated wide string is a sequence of valid wide characters, ending with a null-character.\n\nFunctions\nCharacter classification\nDefined in header <wctype.h>\niswalnum\n(C95)   checks if a wide character is alphanumeric  (function)\niswalpha\n(C95)   checks if a wide character is alphabetic  (function)\niswlower\n(C95)   checks if a wide character is an lowercase character  (function)\niswupper\n(C95)   checks if a wide character is an uppercase character  (function)\niswdigit\n(C95)   checks if a wide character is a digit  (function)\niswxdigit\n(C95)   checks if a character is a hexadecimal character  (function)\niswcntrl\n(C95)   checks if a wide character is a control character  (function)\niswgraph\n(C95)   checks if a wide character is a graphical character  (function)\niswspace\n(C95)   checks if a wide character is a space character  (function)\niswblank\n(C99)   checks if a wide character is a blank character  (function)\niswprint\n(C95)   checks if a wide character is a printing character  (function)\niswpunct\n(C95)   checks if a wide character is a punctuation character  (function)\niswctype\n(C95)   classifies a wide character according to the specified LC_CTYPE category  (function)\nwctype\n(C95)   looks up a character classification category in the current C locale  (function)\nCharacter manipulation\nDefined in header <wctype.h>\ntowlower\n(C95)   converts a wide character to lowercase  (function)\ntowupper\n(C95)   converts a wide character to uppercase  (function)\ntowctrans\n(C95)   performs character mapping according to the specified LC_CTYPE mapping category  (function)\nwctrans\n(C95)   looks up a character mapping category in the current C locale  (function)\n\nASCII values   characters   iscntrl iswcntrl.\n  isprint iswprint.\n  isspace iswspace.\n  isblank iswblank.\n  isgraph iswgraph.\n  ispunct  iswpunct.\n  isalnum  iswalnum.\n  isalpha  iswalpha.\n  isupper iswupper.\n  islower iswlower.\n  isdigit iswdigit.\n  isxdigit iswxdigit.\ndecimal   hexadecimal   octal\n0\u20138   \\x0\u2013\\x8   \\0\u2013\\10   control codes (NUL, etc.)  \n\u22600   0   0   0   0   0   0   0   0   0   0   0\n9   \\x9   \\11   tab (\\t)  \n\u22600   0  \n\u22600  \n\u22600   0   0   0   0   0   0   0   0\n10\u201313   \\xA\u2013\\xD   \\12\u2013\\15   whitespaces (\\n, \\v, \\f, \\r)  \n\u22600   0  \n\u22600   0   0   0   0   0   0   0   0   0\n14\u201331   \\xE\u2013\\x1F   \\16\u2013\\37   control codes  \n\u22600   0   0   0   0   0   0   0   0   0   0   0\n32   \\x20   \\40   space   0  \n\u22600  \n\u22600  \n\u22600   0   0   0   0   0   0   0   0\n33\u201347   \\x21\u2013\\x2F   \\41\u2013\\57   !\"#$%&'()*+,-./   0  \n\u22600   0   0  \n\u22600  \n\u22600   0   0   0   0   0   0\n48\u201357   \\x30\u2013\\x39   \\60\u2013\\71   0123456789   0  \n\u22600   0   0  \n\u22600   0  \n\u22600   0   0   0  \n\u22600  \n\u22600\n58\u201364   \\x3A\u2013\\x40   \\72\u2013\\100   :;<=>?@   0  \n\u22600   0   0  \n\u22600  \n\u22600   0   0   0   0   0   0\n65\u201370   \\x41\u2013\\x46   \\101\u2013\\106   ABCDEF   0  \n\u22600   0   0  \n\u22600   0  \n\u22600  \n\u22600  \n\u22600   0   0  \n\u22600\n71\u201390   \\x47\u2013\\x5A   \\107\u2013\\132   GHIJKLMNOPQRSTUVWXYZ   0  \n\u22600   0   0  \n\u22600   0  \n\u22600  \n\u22600  \n\u22600   0   0   0\n91\u201396   \\x5B\u2013\\x60   \\133\u2013\\140   [\\]^_`   0  \n\u22600   0   0  \n\u22600  \n\u22600   0   0   0   0   0   0\n97\u2013102   \\x61\u2013\\x66   \\141\u2013\\146   abcdef   0  \n\u22600   0   0  \n\u22600   0  \n\u22600  \n\u22600   0  \n\u22600   0  \n\u22600\n103\u2013122   \\x67\u2013\\x7A   \\147\u2013\\172   ghijklmnopqrstuvwxyz   0  \n\u22600   0   0  \n\u22600   0  \n\u22600  \n\u22600   0  \n\u22600   0   0\n123\u2013126   \\x7B\u2013\\x7E   \\172\u2013\\176   {|}~   0  \n\u22600   0   0  \n\u22600  \n\u22600   0   0   0   0   0   0\n127   \\x7F   \\177   backspace character (DEL)  \n\u22600   0   0   0   0   0   0   0   0   0   0   0\n\nConversions to numeric formats\nDefined in header <wchar.h>\nwcstolwcstoll\n(C95)(C99)   converts a wide string to an integer value  (function)\nwcstoulwcstoull\n(C95)(C99)   converts a wide string to an unsigned integer value  (function)\nwcstofwcstodwcstold\n(C99)(C95)(C99)   converts a wide string to a floating-point value  (function)\nDefined in header <inttypes.h>\nwcstoimaxwcstoumax\n(C99)(C99)   converts a wide string to intmax_t or uintmax_t  (function)\n\nString manipulation\nDefined in header <wchar.h>\nwcscpywcscpy_s\n(C95)(C11)   copies one wide string to another  (function)\nwcsncpywcsncpy_s\n(C95)(C11)   copies a certain amount of wide characters from one string to another  (function)\nwcscatwcscat_s\n(C95)(C11)   appends a copy of one wide string to another  (function)\nwcsncatwcsncat_s\n(C95)(C11)   appends a certain amount of wide characters from one wide string to another  (function)\nwcsxfrm\n(C95)   transform a wide string so that wcscmp would produce the same result as wcscoll  (function)\nString examination\nDefined in header <wchar.h>\nwcslenwcsnlen_s\n(C95)(C11)   returns the length of a wide string  (function)\nwcscmp\n(C95)   compares two wide strings  (function)\nwcsncmp\n(C95)   compares a certain amount of characters from two wide strings  (function)\nwcscoll\n(C95)   compares two wide strings in accordance to the current locale  (function)\nwcschr\n(C95)   finds the first occurrence of a wide character in a wide string  (function)\nwcsrchr\n(C95)   finds the last occurrence of a wide character in a wide string  (function)\nwcsspn\n(C95)   returns the length of the maximum initial segment that consists  of only the wide characters found in another wide string  (function)\nwcscspn\n(C95)   returns the length of the maximum initial segment that consists  of only the wide chars not found in another wide string  (function)\nwcspbrk\n(C95)   finds the first location of any wide character in one wide string, in another wide string  (function)\nwcsstr\n(C95)   finds the first occurrence of a wide string within another wide string  (function)\nwcstokwcstok_s\n(C95)(C11)   finds the next token in a wide string  (function)\n\nWide character array manipulation\nDefined in header <wchar.h>\nwmemcpywmemcpy_s\n(C95)(C11)   copies a certain amount of wide characters between two non-overlapping arrays  (function)\nwmemmovewmemmove_s\n(C95)(C11)   copies a certain amount of wide characters between two, possibly overlapping, arrays  (function)\nwmemcmp\n(C95)   compares a certain amount of wide characters from two arrays  (function)\nwmemchr\n(C95)   finds the first occurrence of a wide character in a wide character array  (function)\nwmemset\n(C95)   copies the given wide character to every position in a wide character array  (function)\n\n\nTypes\nDefined in header <stddef.h>\nDefined in header <stdlib.h>\nDefined in header <wchar.h>\nwchar_t   integer type that can hold any valid wide character\nDefined in header <wctype.h>\nwint_t(C95)   integer type that can hold any valid wide character and at least one more value\nwctrans_t(C95)   scalar type that holds locale-specific character mapping\nwctype_t(C95)   scalar type that holds locale-specific character classification\n\n\nMacros\nDefined in header <wchar.h>\nDefined in header <wctype.h>\nWEOF\n(C95)   a non-character value of type wint_t used to indicate errors  (macro constant)\nDefined in header <wchar.h>\nDefined in header <stdint.h>\nWCHAR_MIN\n(C95)   the smallest valid value of wchar_t  (macro constant)\nWCHAR_MAX\n(C95)   the largest valid value of wchar_t  (macro constant)\n\n", "url": "https://devdocs.io/c/string/wide\n"}, {"name": "strcat, strcat_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\n(1)\nchar *strcat( char *dest, const char *src );\n  (until C99)\nchar *strcat( char *restrict dest, const char *restrict src );\n  (since C99)\nerrno_t strcat_s(char *restrict dest, rsize_t destsz, const char *restrict src);\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the null-terminated byte string to append to\nsrc   -   pointer to the null-terminated byte string to copy from\ndestsz   -   maximum number of characters to write, typically the size of the destination buffer\n\n\nReturn value\n\nNotes\n   strcat_s is allowed to clobber the destination array from the last character written up to destsz in order to improve efficiency: it may copy in multibyte blocks and then check for null bytes.\n   The function strcat_s is similar to the BSD function strlcat, except that.\n   Although strcat_s prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked strncat_s instead.\n", "url": "https://devdocs.io/c/string/byte/strcat\n"}, {"name": "strchr", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nchar *strchr( const char *str, int ch );\n\n   Finds the first occurrence of ch (after conversion to char as if by (char)ch) in the null-terminated byte string pointed to by str (each character interpreted as unsigned char). The terminating null character is considered to be a part of the string and can be found when searching for '\\0'.\n   The behavior is undefined if str is not a pointer to a null-terminated byte string.\n\nParameters\nstr   -   pointer to the null-terminated byte string to be analyzed\nch   -   character to search for\n\n\nReturn value\n   Pointer to the found character in str, or null pointer if no such character is found.\n", "url": "https://devdocs.io/c/string/byte/strchr\n"}, {"name": "strcmp", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nint strcmp( const char *lhs, const char *rhs );\n\n   Compares two null-terminated byte strings lexicographically.\n   The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as unsigned char) that differ in the strings being compared.\n   The behavior is undefined if lhs or rhs are not pointers to null-terminated byte strings.\n\nParameters\nlhs, rhs   -   pointers to the null-terminated byte strings to compare\n\n\nReturn value\n   Negative value if lhs appears before rhs in lexicographical order.\n   Zero if lhs and rhs compare equal.\n   Positive value if lhs appears after rhs in lexicographical order.\n\nNotes\n   This function is not locale-sensitive, unlike strcoll and strxfrm.\n", "url": "https://devdocs.io/c/string/byte/strcmp\n"}, {"name": "strcoll", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nint strcoll( const char *lhs, const char *rhs );\n\n   Compares two null-terminated byte strings according to the current locale as defined by the LC_COLLATE category.\n\nParameters\nlhs, rhs   -   pointers to the null-terminated byte strings to compare\n\n\nReturn value\n   Negative value if lhs is less than (precedes) rhs.\n   \u200b0\u200b if lhs is equal to rhs.\n   Positive value if lhs is greater than (follows) rhs.\n\nNotes\n   Collation order is the dictionary order: the position of the letter in the national alphabet (its equivalence class) has higher priority than its case or variant. Within an equivalence class, lowercase characters collate before their uppercase equivalents and locale-specific order may apply to the characters with diacritics. In some locales, groups of characters compare as single collation units. For example, \"ch\" in Czech follows \"h\" and precedes \"i\", and \"dzs\" in Hungarian follows \"dz\" and precedes \"g\".\n", "url": "https://devdocs.io/c/string/byte/strcoll\n"}, {"name": "strcpy, strcpy_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\n(1)\nchar *strcpy( char *dest, const char *src );\n  (until C99)\nchar *strcpy( char *restrict dest, const char *restrict src );\n  (since C99)\nerrno_t strcpy_s(char *restrict dest, rsize_t destsz, const char *restrict src);\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the character array to write to\nsrc   -   pointer to the null-terminated byte string to copy from\ndestsz   -   maximum number of characters to write, typically the size of the destination buffer\n\n\nReturn value\n\nNotes\n   strcpy_s is allowed to clobber the destination array from the last character written up to destsz in order to improve efficiency: it may copy in multibyte blocks and then check for null bytes.\n   The function strcpy_s is similar to the BSD function strlcpy, except that.\n   Although strcpy_s prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked strncpy_s instead.\n", "url": "https://devdocs.io/c/string/byte/strcpy\n"}, {"name": "strcspn", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nsize_t strcspn( const char *dest, const char *src );\n\n   Returns the length of the maximum initial segment of the null-terminated byte string pointed to by dest, that consists of only the characters not found in the null-terminated byte string pointed to by src.\n   The behavior is undefined if either dest or src is not a pointer to a null-terminated byte string.\n\nParameters\ndest   -   pointer to the null-terminated byte string to be analyzed\nsrc   -   pointer to the null-terminated byte string that contains the characters to search for\n\n\nReturn value\n   The length of the maximum initial segment that contains only characters not found in the null-terminated byte string pointed to by src.\n\nNotes\n   The function name stands for \"complementary span\" because the function searches for characters not found in src, that is the complement of src.\n", "url": "https://devdocs.io/c/string/byte/strcspn\n"}, {"name": "strerror, strerror_s, strerrorlen_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nchar* strerror( int errnum );\n  (1)\nerrno_t strerror_s( char *buf, rsize_t bufsz, errno_t errnum );\n  (2)   (since C11)\nsize_t strerrorlen_s( errno_t errnum );\n  (3)   (since C11)\n\n\nParameters\nerrnum   -   integral value referring to an error code\nbuf   -   pointer to a user-provided buffer\nbufsz   -   size of the user-provided buffer\n\n\nReturn value\n\nNotes\n   POSIX allows subsequent calls to strerror to invalidate the pointer value returned by an earlier call. It also specifies that it is the LC_MESSAGES locale facet that controls the contents of these messages.\n   strerror_s is the only bounds-checked function that allows truncation, because providing as much information as possible about a failure was deemed to be more desirable. POSIX also defines strerror_r for similar purposes.\n", "url": "https://devdocs.io/c/string/byte/strerror\n"}, {"name": "Strings library", "type": "STANDARD LIB", "description": "\nNull-terminated byte string management\n\nNull-terminated multibyte string management\n\nNull-terminated wide string management\n\nSee also\n", "url": "https://devdocs.io/c/string\n"}, {"name": "strlen, strnlen_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nsize_t strlen( const char *str );\n  (1)\nsize_t strnlen_s( const char *str, size_t strsz );\n  (2)   (since C11)\n\n\nParameters\nstr   -   pointer to the null-terminated byte string to be examined\nstrsz   -   maximum number of characters to examine\n\n\nReturn value\n\nNotes\n   strnlen_s and wcsnlen_s are the only bounds-checked functions that do not invoke the runtime constraints handler. They are pure utility functions used to provide limited support for non-null terminated strings.\n", "url": "https://devdocs.io/c/string/byte/strlen\n"}, {"name": "strncat, strncat_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\n(1)\nchar *strncat( char *dest, const char *src, size_t count );\n  (until C99)\nchar *strncat( char *restrict dest, const char *restrict src, size_t count );\n  (since C99)\nerrno_t strncat_s(char *restrict dest, rsize_t destsz,\n                  const char *restrict src, rsize_t count);\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the null-terminated byte string to append to\nsrc   -   pointer to the character array to copy from\ncount   -   maximum number of characters to copy\ndestsz   -   the size of the destination buffer\n\n\nReturn value\n\nNotes\n   Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for strncat_s, it is possible to get the truncating behavior by specifying count equal to the size of the destination array minus one: it will copy the first count bytes and append the null terminator as always: strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);\n", "url": "https://devdocs.io/c/string/byte/strncat\n"}, {"name": "strncmp", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nint strncmp( const char *lhs, const char *rhs, size_t count );\n\n   Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically.\n   The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as unsigned char) that differ in the arrays being compared.\n   The behavior is undefined when access occurs past the end of either array lhs or rhs. The behavior is undefined when either lhs or rhs is the null pointer.\n\nParameters\nlhs, rhs   -   pointers to the possibly null-terminated arrays to compare\ncount   -   maximum number of characters to compare\n\n\nReturn value\n   Negative value if lhs appears before rhs in lexicographical order.\n   Zero if lhs and rhs compare equal, or if count is zero.\n   Positive value if lhs appears after rhs in lexicographical order.\n\nNotes\n   This function is not locale-sensitive, unlike strcoll and strxfrm.\n", "url": "https://devdocs.io/c/string/byte/strncmp\n"}, {"name": "strncpy, strncpy_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\n(1)\nchar *strncpy( char *dest, const char *src, size_t count );\n  (until C99)\nchar *strncpy( char *restrict dest, const char *restrict src, size_t count );\n  (since C99)\nerrno_t strncpy_s(char *restrict dest, rsize_t destsz,\n                  const char *restrict src, rsize_t count);\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the character array to copy to\nsrc   -   pointer to the character array to copy from\ncount   -   maximum number of characters to copy\ndestsz   -   the size of the destination buffer\n\n\nReturn value\n\nNotes\n   As corrected by the post-C11 DR 468, strncpy_s, unlike strcpy_s, is only allowed to clobber the remainder of the destination array if an error occurs.\n   Unlike strncpy, strncpy_s does not pad the destination array with zeroes, This is a common source of errors when converting existing code to the bounds-checked version.\n   Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for strncpy_s, it is possible to get the truncating behavior by specifying count equal to the size of the destination array minus one: it will copy the first count bytes and append the null terminator as always: strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);\n", "url": "https://devdocs.io/c/string/byte/strncpy\n"}, {"name": "strpbrk", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nchar* strpbrk( const char* dest, const char* breakset );\n\n   Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.\n   The behavior is undefined if either dest or breakset is not a pointer to a null-terminated byte string.\n\nParameters\ndest   -   pointer to the null-terminated byte string to be analyzed\nbreakset   -   pointer to the null-terminated byte string that contains the characters to search for\n\n\nReturn value\n   Pointer to the first character in dest, that is also in breakset, or null pointer if no such character exists.\n\nNotes\n   The name stands for \"string pointer break\", because it returns a pointer to the first of the separator (\"break\") characters.\n", "url": "https://devdocs.io/c/string/byte/strpbrk\n"}, {"name": "strrchr", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nchar *strrchr( const char *str, int ch );\n\n   Finds the last occurrence of ch (after conversion to char as if by (char)ch) in the null-terminated byte string pointed to by str (each character interpreted as unsigned char). The terminating null character is considered to be a part of the string and can be found if searching for '\\0'.\n   The behavior is undefined if str is not a pointer to a null-terminated byte string.\n\nParameters\nstr   -   pointer to the null-terminated byte string to be analyzed\nch   -   character to search for\n\n\nReturn value\n   Pointer to the found character in str, or null pointer if no such character is found.\n", "url": "https://devdocs.io/c/string/byte/strrchr\n"}, {"name": "strspn", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nsize_t strspn( const char *dest, const char *src );\n\n   Returns the length of the maximum initial segment (span) of the null-terminated byte string pointed to by dest, that consists of only the characters found in the null-terminated byte string pointed to by src.\n   The behavior is undefined if either dest or src is not a pointer to a null-terminated byte string.\n\nParameters\ndest   -   pointer to the null-terminated byte string to be analyzed\nsrc   -   pointer to the null-terminated byte string that contains the characters to search for\n\n\nReturn value\n   The length of the maximum initial segment that contains only characters from the null-terminated byte string pointed to by src.\n", "url": "https://devdocs.io/c/string/byte/strspn\n"}, {"name": "strstr", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nchar *strstr( const char* str, const char* substr );\n\n   Finds the first occurrence of the null-terminated byte string pointed to by substr in the null-terminated byte string pointed to by str. The terminating null characters are not compared.\n   The behavior is undefined if either str or substr is not a pointer to a null-terminated byte string.\n\nParameters\nstr   -   pointer to the null-terminated byte string to examine\nsubstr   -   pointer to the null-terminated byte string to search for\n\n\nReturn value\n   Pointer to the first character of the found substring in str, or NULL if no such substring is found. If substr points to an empty string, str is returned.\n", "url": "https://devdocs.io/c/string/byte/strstr\n"}, {"name": "strtof, strtod, strtold", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nfloat       strtof( const char *restrict str, char **restrict str_end );\n    (since C99)\ndouble      strtod( const char          *str, char          **str_end );\n    (until C99)\ndouble      strtod( const char *restrict str, char **restrict str_end );\n    (since C99)\nlong double strtold( const char *restrict str, char **restrict str_end );\n    (since C99)\n\n   Interprets a floating-point value in a byte string pointed to by str.\n   Function discards any whitespace characters (as determined by std::isspace()) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n   The functions sets the pointer pointed to by str_end to point to the character past the last character interpreted. If str_end is NULL, it is ignored.\n\nParameters\nstr   -   pointer to the null-terminated byte string to be interpreted\nstr_end   -   pointer to a pointer to character.\n\n\nReturn value\n   Floating-point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, \u200b0\u200b is returned.\n", "url": "https://devdocs.io/c/string/byte/strtof\n"}, {"name": "strtoimax, strtoumax", "type": "STANDARD LIB", "description": "Defined in header <inttypes.h>\nintmax_t strtoimax( const char *restrict nptr, \n                    char **restrict endptr, int base );\n    (since C99)\nuintmax_t strtoumax( const char *restrict nptr, \n                     char **restrict endptr, int base );\n    (since C99)\n\n   Interprets an integer value in a byte string pointed to by nptr.\n   Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n   The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.\n   Additional numeric formats may be accepted by the currently installed C locale.\n   If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.\n   If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.\n   The functions sets the pointer pointed to by endptr to point to the character past the last character interpreted. If endptr is NULL, it is ignored.\n   If the nptr is empty or does not have the expected form, no conversion is performed, and (if enptr is not NULL) the value of nptr is stored in the object pointed to by endptr.\n\nParameters\nnptr   -   pointer to the null-terminated byte string to be interpreted\nendptr   -   pointer to a pointer to character.\nbase   -   base of the interpreted integer value\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/byte/strtoimax\n"}, {"name": "strtok, strtok_s", "type": "STANDARD LIB", "description": "Defined in header <string.h>\n(1)\nchar *strtok( char *str, const char *delim );\n  (until C99)\nchar *strtok( char *restrict str, const char *restrict delim );\n  (since C99)\nchar *strtok_s(char *restrict str, rsize_t *restrict strmax,\n     const char *restrict delim, char **restrict ptr);\n  (2)   (since C11)\n\n\nParameters\nstr   -   pointer to the null-terminated byte string to tokenize\ndelim   -   pointer to the null-terminated byte string identifying delimiters\nstrmax   -   pointer to an object which initially holds the size of str: strtok_s stores the number of characters that remain to be examined\nptr   -   pointer to an object of type char*, which is used by strtok_s to store its internal state\n\n\nReturn value\n   Returns pointer to the beginning of the next token or NULL if there are no more tokens.\n\nNote\n   This function is destructive: it writes the '\\0' characters in the elements of the string str. In particular, a string literal cannot be used as the first argument of strtok.\n   Each call to strtok modifies a static variable: is not thread safe.\n   Unlike most other tokenizers, the delimiters in strtok can be different for each subsequent token, and can even depend on the contents of the previous tokens.\n   The strtok_s function differs from the POSIX strtok_r function by guarding against storing outside of the string being tokenized, and by checking runtime constraints.\n", "url": "https://devdocs.io/c/string/byte/strtok\n"}, {"name": "strtol, strtoll", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nlong      strtol( const char          *str, char          **str_end, int base );\n    (until C99)\nlong      strtol( const char *restrict str, char **restrict str_end, int base );\n    (since C99)\nlong long strtoll( const char *restrict str, char **restrict str_end, int base );\n    (since C99)\n\n   Interprets an integer value in a byte string pointed to by str.\n   Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n   The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.\n   Additional numeric formats may be accepted by the currently installed C locale.\n   If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.\n   If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.\n   The functions sets the pointer pointed to by str_end to point to the character past the last character interpreted. If str_end is NULL, it is ignored.\n   If the str is empty or does not have the expected form, no conversion is performed, and (if str_end is not NULL) the value of str is stored in the object pointed to by str_end.\n\nParameters\nstr   -   pointer to the null-terminated byte string to be interpreted\nstr_end   -   pointer to a pointer to character.\nbase   -   base of the interpreted integer value\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/byte/strtol\n"}, {"name": "strtoul, strtoull", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nunsigned long      strtoul( const char          *str, char          **str_end, \n                            int base );\n    (until C99)\nunsigned long      strtoul( const char *restrict str, char **restrict str_end, \n                            int base );\n    (since C99)\nunsigned long long strtoull( const char *restrict str, char **restrict str_end,\n                             int base );\n    (since C99)\n\n   Interprets an unsigned integer value in a byte string pointed to by str.\n   Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n   The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.\n   Additional numeric formats may be accepted by the currently installed C locale.\n   If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.\n   If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.\n   The functions sets the pointer pointed to by str_end to point to the character past the last character interpreted. If str_end is NULL, it is ignored.\n\nParameters\nstr   -   pointer to the null-terminated byte string to be interpreted\nstr_end   -   pointer to a pointer to character.\nbase   -   base of the interpreted integer value\n\n\nReturn value\n   Integer value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs (errno is set to ERANGE) and ULONG_MAX or ULLONG_MAX is returned. If no conversion can be performed, \u200b0\u200b is returned.\n", "url": "https://devdocs.io/c/string/byte/strtoul\n"}, {"name": "strxfrm", "type": "STANDARD LIB", "description": "Defined in header <string.h>\nsize_t strxfrm( char          *dest, const char          *src, \n                size_t count );\n    (until C99)\nsize_t strxfrm( char *restrict dest, const char *restrict src, \n                size_t count );\n    (since C99)\n\n   Transforms the null-terminated byte string pointed to by src into the implementation-defined form such that comparing two transformed strings with strcmp gives the same result as comparing the original strings with strcoll, in the current C locale.\n   The first count characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.\n   The behavior is undefined if the dest array is not large enough. The behavior is undefined if dest and src overlap.\n   If count is \u200b0\u200b, then dest is allowed to be a null pointer.\n\nNotes\n   The correct length of the buffer that can receive the entire transformed string is 1+strxfrm(NULL, src, 0).\n   This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use strxfrm to transform all the strings just once, and subsequently compare the transformed strings with strcmp.\n\nParameters\ndest   -   pointer to the first element of the array where the transformed string will be written\nsrc   -   pointer to the first character of a null-terminated byte string to transform\ncount   -   maximum number of characters to be written\n\n\nReturn value\n   The length of the transformed string, not including the terminating null-character.\n", "url": "https://devdocs.io/c/string/byte/strxfrm\n"}, {"name": "tolower", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint tolower( int ch );\n\n   Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.\n   In the default \"C\" locale, the following uppercase letters ABCDEFGHIJKLMNOPQRSTUVWXYZ are replaced with respective lowercase letters abcdefghijklmnopqrstuvwxyz.\n\nParameters\nch   -   character to be converted. If the value of ch is not representable as unsigned char and does not equal EOF, the behavior is undefined.\n\n\nReturn value\n   Lowercase version of ch or unmodified ch if no lowercase version is listed in the current C locale.\n", "url": "https://devdocs.io/c/string/byte/tolower\n"}, {"name": "toupper", "type": "STANDARD LIB", "description": "Defined in header <ctype.h>\nint toupper( int ch );\n\n   Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.\n   In the default \"C\" locale, the following lowercase letters abcdefghijklmnopqrstuvwxyz are replaced with respective uppercase letters ABCDEFGHIJKLMNOPQRSTUVWXYZ.\n\nParameters\nch   -   character to be converted. If the value of ch is not representable as unsigned char and does not equal EOF, the behavior is undefined.\n\n\nReturn value\n   Uppercase version of ch or unmodified ch if no uppercase version is listed in the current C locale.\n", "url": "https://devdocs.io/c/string/byte/toupper\n"}, {"name": "towctrans", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nwint_t towctrans( wint_t wc, wctrans_t desc );\n    (since C95)\n\n   Maps the wide character wc using the current C locale's LC_CTYPE mapping category identified by desc.\n\nParameters\nwc   -   the wide character to map\ndesc   -   the LC_CTYPE mapping, obtained from a call to wctrans\n\n\nReturn value\n   The mapped value of wc using the mapping identified by desc in LC_CTYPE facet of the current C locale.\n", "url": "https://devdocs.io/c/string/wide/towctrans\n"}, {"name": "towlower", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nwint_t towlower( wint_t wc );\n    (since C95)\n\n   Converts the given wide character to lowercase, if possible.\n\nParameters\nwc   -   wide character to be converted\n\n\nReturn value\n   Lowercase version of wc or unmodified wc if no lowercase version is listed in the current C locale.\n\nNotes\n   Only 1:1 character mapping can be performed by this function, e.g. the Greek uppercase letter '\u03a3' has two lowercase forms, depending on the position in a word: '\u03c3' and '\u03c2'. A call to towlower cannot be used to obtain the correct lowercase form in this case.\n   ISO 30112 specifies which pairs of Unicode characters are included in this mapping.\n", "url": "https://devdocs.io/c/string/wide/towlower\n"}, {"name": "towupper", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nwint_t towupper( wint_t wc );\n    (since C95)\n\n   Converts the given wide character to uppercase, if possible.\n\nParameters\nwc   -   wide character to be converted\n\n\nReturn value\n   Uppercase version of wc or unmodified wc if no uppercase version is listed in the current C locale.\n\nNotes\n   Only 1:1 character mapping can be performed by this function, e.g. the uppercase form of '\u00df' is (with some exceptions) the two-character string \"SS\", which cannot be obtained by towupper.\n   ISO 30112 specifies which pairs of Unicode characters are included in this mapping.\n", "url": "https://devdocs.io/c/string/wide/towupper\n"}, {"name": "wcrtomb, wcrtomb_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nsize_t wcrtomb( char *s, wchar_t wc, mbstate_t *ps);\n  (since C95)\nsize_t wcrtomb( char *restrict s, wchar_t wc, mbstate_t *restrict ps);\n  (since C99)\nerrno_t wcrtomb_s(size_t *restrict retval, char *restrict s, rsize_t ssz,\n                  wchar_t wc, mbstate_t *restrict ps);\n  (2)   (since C11)\n\n   Converts a wide character to its narrow multibyte representation.\n\nParameters\ns   -   pointer to narrow character array where the multibyte character will be stored\nwc   -   the wide character to convert\nps   -   pointer to the conversion state object used when interpreting the multibyte string\nssz   -   max number of bytes to write (the size of the buffer s)\nretval   -   pointer to an out-parameter where the result (number of bytes in the multibyte string including any shift sequences) will be stored\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/multibyte/wcrtomb\n"}, {"name": "wcscat, wcscat_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nwchar_t *wcscat( wchar_t *dest, const wchar_t *src );\n  (since C95) (until C99)\nwchar_t *wcscat(wchar_t *restrict dest, const wchar_t *restrict src);\n  (since C99)\nerrno_t wcscat_s(wchar_t *restrict dest, rsize_t destsz,\n                 const wchar_t *restrict src);\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the null-terminated wide string to append to\nsrc   -   pointer to the null-terminated wide string to copy from\ndestsz   -   maximum number of characters to write, typically the size of the destination buffer\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/wide/wcscat\n"}, {"name": "wcschr", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwchar_t* wcschr( const wchar_t* str, wchar_t ch );\n    (since C95)\n\n   Finds the first occurrence of the wide character ch in the wide string pointed to by str.\n\nParameters\nstr   -   pointer to the null-terminated wide string to be analyzed\nch   -   wide character to search for\n\n\nReturn value\n   Pointer to the found character in str, or NULL if no such character is found.\n", "url": "https://devdocs.io/c/string/wide/wcschr\n"}, {"name": "wcscmp", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint wcscmp( const wchar_t *lhs, const wchar_t *rhs );\n    (since C95)\n\n   Compares two null-terminated wide strings lexicographically.\n   The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.\n   The behavior is undefined if lhs or rhs are not pointers to null-terminated wide strings.\n\nParameters\nlhs, rhs   -   pointers to the null-terminated wide strings to compare\n\n\nReturn value\n   Negative value if lhs appears before rhs in lexicographical order.\n   Zero if lhs and rhs compare equal.\n   Positive value if lhs appears after rhs in lexicographical order.\n\nNotes\n   This function is not locale-sensitive, unlike wcscoll, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match any collation order.\n", "url": "https://devdocs.io/c/string/wide/wcscmp\n"}, {"name": "wcscoll", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint wcscoll( const wchar_t *lhs, const wchar_t *rhs );\n    (since C95)\n\n   Compares two null-terminated wide strings according to the collation order defined by the LC_COLLATE category of the currently installed locale.\n\nParameters\nlhs, rhs   -   pointers to the null-terminated wide strings to compare\n\n\nReturn value\n   Negative value if lhs is less than (precedes) rhs.\n   \u200b0\u200b if lhs is equal to rhs.\n   Positive value if lhs is greater than (follows) rhs.\n\nNotes\n   Collation order is the dictionary order: the position of the letter in the national alphabet (its equivalence class) has higher priority than its case or variant. Within an equivalence class, lowercase characters collate before their uppercase equivalents and locale-specific order may apply to the characters with diacritics. In some locales, groups of characters compare as single collation units. For example, \"ch\" in Czech follows \"h\" and precedes \"i\", and \"dzs\" in Hungarian follows \"dz\" and precedes \"g\".\n", "url": "https://devdocs.io/c/string/wide/wcscoll\n"}, {"name": "wcscpy, wcscpy_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nwchar_t *wcscpy( wchar_t *dest, const wchar_t *src );\n  (since C95) (until C99)\nwchar_t *wcscpy( wchar_t *restrict dest, const wchar_t *restrict src );\n  (since C99)\nerrno_t wcscpy_s( wchar_t *restrict dest, rsize_t destsz,\n                  const wchar_t *restrict src );\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the wide character array to copy to\nsrc   -   pointer to the null-terminated wide string to copy from\ndestsz   -   maximum number of characters to write, typically the size of the destination buffer\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/wide/wcscpy\n"}, {"name": "wcscspn", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nsize_t wcscspn( const wchar_t* dest, const wchar_t* src );\n    (since C95)\n\n   Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src.\n\nParameters\ndest   -   pointer to the null-terminated wide string to be analyzed\nsrc   -   pointer to the null-terminated wide string that contains the characters to search for\n\n\nReturn value\n   The length of the maximum initial segment that contains only characters not found in the character string pointed to by src.\n", "url": "https://devdocs.io/c/string/wide/wcscspn\n"}, {"name": "wcslen, wcsnlen_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nsize_t wcslen( const wchar_t *str );\n  (1)   (since C95)\nsize_t wcsnlen_s(const wchar_t *str, size_t strsz);\n  (2)   (since C11)\n\n\nParameters\nstr   -   pointer to the null-terminated wide string to be examined\nstrsz   -   maximum number of wide characters to examine\n\n\nReturn value\n\nNotes\n   strnlen_s and wcsnlen_s are the only bounds-checked functions that do not invoke the runtime constraints handler. They are pure utility functions used to provide limited support for non-null terminated strings.\n", "url": "https://devdocs.io/c/string/wide/wcslen\n"}, {"name": "wcsncat, wcsncat_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nwchar_t *wcsncat( wchar_t *dest, const wchar_t *src, size_t count );\n  (since C95) (until C99)\nwchar_t *wcsncat( wchar_t *restrict dest,\n                  const wchar_t *restrict src, size_t count );\n  (since C99)\nerrno_t wcsncat_s( wchar_t *restrict dest, rsize_t destsz,\n                   const wchar_t *restrict src, rsize_t count );\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the null-terminated wide string to append to\nsrc   -   pointer to the null-terminated wide string to copy from\ncount   -   maximum number of wide characters to copy\ndestsz   -   the size of the destination buffer\n\n\nReturn value\n\nNotes\n   Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for wcsncat_s, it is possible to get the truncating behavior by specifying count equal to the size of the destination array minus one: it will copy the first count wide characters and append the null terminator as always: wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);\n", "url": "https://devdocs.io/c/string/wide/wcsncat\n"}, {"name": "wcsncmp", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint wcsncmp( const wchar_t* lhs, const wchar_t* rhs, size_t count );\n    (since C95)\n\n   Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically.\n   The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.\n   The behavior is undefined if lhs or rhs are not pointers to null-terminated strings.\n\nParameters\nlhs, rhs   -   pointers to the null-terminated wide strings to compare\ncount   -   maximum number of characters to compare\n\n\nReturn value\n   Negative value if lhs appears before rhs in lexicographical order.\n   Zero if lhs and rhs compare equal.\n   Positive value if lhs appears after rhs in lexicographical order.\n\nNotes\n   This function is not locale-sensitive, unlike wcscoll and wcsxfrm.\n", "url": "https://devdocs.io/c/string/wide/wcsncmp\n"}, {"name": "wcsncpy, wcsncpy_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nwchar_t* wcsncpy( wchar_t* dest, const wchar_t* src, size_t count );\n  (since C95) (until C99)\nwchar_t *wcsncpy(wchar_t *restrict dest, const wchar_t *restrict src, size_t n);\n  (since C99)\nerrno_t wcsncpy_s( wchar_t *restrict dest, rsize_t destsz,\n                   const wchar_t *restrict src, rsize_t n);\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the wide character array to copy to\nsrc   -   pointer to the wide string to copy from\ncount   -   maximum number of wide characters to copy\ndestsz   -   the size of the destination buffer\n\n\nReturn value\n\nNotes\n   In typical usage, count is the number of elements in the destination array.\n   Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for wcsncpy_s, it is possible to get the truncating behavior by specifying count equal to the size of the destination array minus one: it will copy the first count wide characters and append the null wide terminator as always: wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);\n", "url": "https://devdocs.io/c/string/wide/wcsncpy\n"}, {"name": "wcspbrk", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwchar_t* wcspbrk( const wchar_t* dest, const wchar_t* str );\n    (since C95)\n\n   Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.\n\nParameters\ndest   -   pointer to the null-terminated wide string to be analyzed\nsrc   -   pointer to the null-terminated wide string that contains the characters to search for\n\n\nReturn value\n   Pointer to the first character in dest, that is also in str, or NULL if no such character exists.\n", "url": "https://devdocs.io/c/string/wide/wcspbrk\n"}, {"name": "wcsrchr", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwchar_t* wcsrchr( const wchar_t* str, wchar_t ch );\n    (since C95)\n\n   Finds the last occurrence of the wide character ch in the wide string pointed to by str.\n\nParameters\nstr   -   pointer to the null-terminated wide string to be analyzed\nch   -   wide character to search for\n\n\nReturn value\n   Pointer to the found character in str, or NULL if no such character is found.\n", "url": "https://devdocs.io/c/string/wide/wcsrchr\n"}, {"name": "wcsrtombs, wcsrtombs_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nsize_t wcsrtombs( char *dst, const wchar_t **src, size_t len, mbstate_t* ps );\n  (since C95)\nsize_t wcsrtombs( char *restrict dst, const wchar_t **restrict src, size_t len,\n                  mbstate_t *restrict ps);\n  (since C99)\nerrno_t wcsrtombs_s( size_t *restrict retval, char *restrict dst, rsize_t dstsz,\n                     const wchar_t **restrict src, rsize_t len,\n                     mbstate_t *restrict ps);\n  (2)   (since C11)\n\n\nParameters\ndst   -   pointer to narrow character array where the multibyte characters will be stored\nsrc   -   pointer to pointer to the first element of a null-terminated wide string\nlen   -   number of bytes available in the array pointed to by dst\nps   -   pointer to the conversion state object\ndstsz   -   max number of bytes that will be written (size of the dst array)\nretval   -   pointer to a size_t object where the result will be stored\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/multibyte/wcsrtombs\n"}, {"name": "wcsspn", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nsize_t wcsspn( const wchar_t* dest, const wchar_t* src );\n    (since C95)\n\n   Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src.\n\nParameters\ndest   -   pointer to the null-terminated wide string to be analyzed\nsrc   -   pointer to the null-terminated wide string that contains the characters to search for\n\n\nReturn value\n   The length of the maximum initial segment that contains only characters from wide string pointed to by src.\n", "url": "https://devdocs.io/c/string/wide/wcsspn\n"}, {"name": "wcsstr", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwchar_t* wcsstr( const wchar_t* dest, const wchar_t* src );\n    (since C95)\n\n   Finds the first occurrence of the wide string src in the wide string pointed to by dest. The terminating null characters are not compared.\n\nParameters\ndest   -   pointer to the null-terminated wide string to examine\nsrc   -   pointer to the null-terminated wide string to search for\n\n\nReturn value\n   Pointer to the first character of the found substring in dest, or NULL if no such substring is found. If src points to an empty string, dest is returned.\n", "url": "https://devdocs.io/c/string/wide/wcsstr\n"}, {"name": "wcstof, wcstod, wcstold", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nfloat       wcstof( const wchar_t * restrict str, wchar_t ** restrict str_end );\n    (since C99)\ndouble      wcstod( const wchar_t * str, wchar_t ** str_end );\n    (since C95) (until C99)\ndouble      wcstod( const wchar_t * restrict str, wchar_t ** restrict str_end );\n    (since C99)\nlong double wcstold( const wchar_t * restrict str, wchar_t ** restrict str_end );\n    (since C99)\n\n   Interprets a floating point value in a wide string pointed to by str.\n   Function discards any whitespace characters (as determined by std::iswspace()) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:\n   The functions sets the pointer pointed to by str_end to point to the wide character past the last character interpreted. If str_end is NULL, it is ignored.\n\nParameters\nstr   -   pointer to the null-terminated wide string to be interpreted\nstr_end   -   pointer to a pointer to a wide character.\n\n\nReturn value\n   Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, \u200b0\u200b is returned.\n", "url": "https://devdocs.io/c/string/wide/wcstof\n"}, {"name": "wcstoimax, wcstoumax", "type": "STANDARD LIB", "description": "Defined in header <inttypes.h>\nintmax_t wcstoimax( const wchar_t *restrict nptr, \n                    wchar_t **restrict endptr, int base );\n    (since C99)\nuintmax_t wcstoumax( const wchar_t *restrict nptr,\n                     wchar_t **restrict endptr, int base );\n    (since C99)\n\n   Interprets an unsigned integer value in a wide string pointed to by nptr.\n   Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n   The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.\n   Additional numeric formats may be accepted by the currently installed C locale.\n   If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.\n   If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.\n   The functions sets the pointer pointed to by endptr to point to the wide character past the last character interpreted. If endptr is NULL, it is ignored.\n\nParameters\nnptr   -   pointer to the null-terminated wide string to be interpreted\nendptr   -   pointer to a pointer to a wide character.\nbase   -   base of the interpreted integer value\n\n\nReturn value\n   Integer value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and INTMAX_MAX, INTMAX_MIN, UINTMAX_MAX, or \u200b0\u200b is returned, as appropriate. If no conversion can be performed, \u200b0\u200b is returned.\n", "url": "https://devdocs.io/c/string/wide/wcstoimax\n"}, {"name": "wcstok, wcstok_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nwchar_t* wcstok( wchar_t* str, const wchar_t* delim, wchar_t **ptr );\n  (since C95) (until C99)\nwchar_t *wcstok(wchar_t * restrict str, const wchar_t * restrict delim,\n                wchar_t **restrict ptr);\n  (since C99)\nwchar_t *wcstok_s( wchar_t *restrict str, rsize_t *restrict strmax,\n                   const wchar_t *restrict delim, wchar_t **restrict ptr);\n  (2)   (since C11)\n\n\nParameters\nstr   -   pointer to the null-terminated wide string to tokenize\ndelim   -   pointer to the null-terminated wide string identifying delimiters\nptr   -   pointer to an object of type wchar_t*, which is used by both wcstok and wcstok_s to store the internal state of the parser\nstrmax   -   pointer to an object which initially holds the size of str: wcstok_s stores the number of characters that remain to be examined\n\n\nReturn value\n   Returns pointer to the beginning of the next token or null pointer if there are no more tokens.\n\nNote\n   This function is destructive: it writes the L'\\0' characters in the elements of the string str. In particular, a wide string literal cannot be used as the first argument of wcstok.\n   Unlike strtok, wcstok does not update static storage: it stores the parser state in the user-provided location.\n   Unlike most other tokenizers, the delimiters in wcstok can be different for each subsequent token, and can even depend on the contents of the previous tokens.\n", "url": "https://devdocs.io/c/string/wide/wcstok\n"}, {"name": "wcstol, wcstoll", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nlong      wcstol( const wchar_t * str, wchar_t ** str_end, int base );\n    (since C95) (until C99)\nlong      wcstol( const wchar_t * str, wchar_t ** restrict str_end,\n                  int base );\n    (since C99)\nlong long wcstoll( const wchar_t * restrict str, wchar_t ** restrict str_end,\n                   int base );\n    (since C99)\n\n   Interprets an integer value in a wide string pointed to by str.\n   Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n   The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.\n   Additional numeric formats may be accepted by the currently installed C locale.\n   If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.\n   If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.\n   The functions sets the pointer pointed to by str_end to point to the wide character past the last character interpreted. If str_end is NULL, it is ignored.\n\nParameters\nstr   -   pointer to the null-terminated wide string to be interpreted\nstr_end   -   pointer to a pointer to wide character\nbase   -   base of the interpreted integer value\n\n\nReturn value\n   Integer value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and LONG_MAX, LONG_MIN, LLONG_MAX or LLONG_MIN is returned. If no conversion can be performed, \u200b0\u200b is returned.\n", "url": "https://devdocs.io/c/string/wide/wcstol\n"}, {"name": "wcstombs, wcstombs_s", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\n(1)\nsize_t wcstombs( char          *dst, const wchar_t          *src, size_t len );\n  (until C99)\nsize_t wcstombs( char *restrict dst, const wchar_t *restrict src, size_t len );\n  (since C99)\nerrno_t wcstombs_s( size_t *restrict retval, char *restrict dst, rsize_t dstsz,\n                    const wchar_t *restrict src, rsize_t len );\n  (2)   (since C11)\n\n\nNotes\n   In most implementations, wcstombs updates a global static object of type mbstate_t as it processes through the string, and cannot be called simultaneously by two threads, wcsrtombs or wcstombs_s should be used in such cases.\n   POSIX specifies a common extension: if dst is a null pointer, this function returns the number of bytes that would be written to dst, if converted. Similar behavior is standard for wcsrtombs and wcstombs_s.\n\nParameters\ndst   -   pointer to narrow character array where the multibyte character will be stored\nsrc   -   pointer to the first element of a null-terminated wide string to convert\nlen   -   number of bytes available in the array pointed to by dst\ndstsz   -   max number of bytes that will be written (size of the dst array)\nretval   -   pointer to a size_t object where the result will be stored\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/multibyte/wcstombs\n"}, {"name": "wcstoul, wcstoull", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nunsigned long      wcstoul( const wchar_t* str, wchar_t** str_end, int base );\n    (since C95) (until C99)\nunsigned long      wcstoul( const wchar_t * restrict str,\n                            wchar_t ** restrict str_end, int base );\n    (since C99)\nunsigned long long wcstoull( const wchar_t * restrict str,\n                             wchar_t ** restrict str_end, int base );\n    (since C99)\n\n   Interprets an unsigned integer value in a wide string pointed to by str.\n   Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) unsigned integer number representation and converts them to an integer value. The valid unsigned integer value consists of the following parts:\n   The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is {0,1}, for base-3 integers is {0,1,2}, and so on. For bases larger than 10, valid digits include alphabetic characters, starting from Aa for base-11 integer, to Zz for base-36 integer. The case of the characters is ignored.\n   Additional numeric formats may be accepted by the currently installed C locale.\n   If the value of base is \u200b0\u200b, the numeric base is auto-detected: if the prefix is 0, the base is octal, if the prefix is 0x or 0X, the base is hexadecimal, otherwise the base is decimal.\n   If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type, which applies unsigned integer wraparound rules.\n   The functions sets the pointer pointed to by str_end to point to the wide character past the last character interpreted. If str_end is NULL, it is ignored.\n\nParameters\nstr   -   pointer to the null-terminated wide string to be interpreted\nstr_end   -   pointer to a pointer to a wide character.\nbase   -   base of the interpreted integer value\n\n\nReturn value\n   Integer value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and ULONG_MAX or ULLONG_MAX is returned. If no conversion can be performed, \u200b0\u200b is returned.\n", "url": "https://devdocs.io/c/string/wide/wcstoul\n"}, {"name": "wcsxfrm", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nsize_t wcsxfrm( wchar_t* dest, const wchar_t* src, size_t count );\n    (until C99) (since C95)\nsize_t wcsxfrm( wchar_t* restrict dest, const wchar_t* restrict src, size_t count );\n    (since C99)\n\n   Transforms the null-terminated wide string pointed to by src into the implementation-defined form such that comparing two transformed strings with wcscmp gives the same result as comparing the original strings with wcscoll, in the current C locale.\n   The first count characters of the transformed string are written to destination, including the terminating null character, and the length of the full transformed string is returned, excluding the terminating null character.\n   If count is \u200b0\u200b, then dest is allowed to be a null pointer.\n\nNotes\n   The correct length of the buffer that can receive the entire transformed string is 1+wcsxfrm(NULL, src, 0).\n   This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use wcsxfrm to transform all the strings just once, and subsequently compare the transformed wide strings with wcscmp.\n\nParameters\ndest   -   pointer to the first element of a wide null-terminated string to write the transformed string to\nsrc   -   pointer to the null-terminated wide character string to transform\ncount   -   maximum number of characters to output\n\n\nReturn value\n   The length of the transformed wide string, not including the terminating null-character.\n", "url": "https://devdocs.io/c/string/wide/wcsxfrm\n"}, {"name": "wctob", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint wctob( wint_t c );\n    (since C95)\n\n   Narrows a wide character c if its multibyte character equivalent in the initial shift state is a single byte.\n   This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.\n\nParameters\nc   -   wide character to narrow\n\n\nReturn value\n   EOF if c does not represent a multibyte character with length 1 in initial shift state.\n   otherwise, the single-byte representation of c as unsigned char converted to int.\n", "url": "https://devdocs.io/c/string/multibyte/wctob\n"}, {"name": "wctomb, wctomb_s", "type": "STANDARD LIB", "description": "Defined in header <stdlib.h>\nint wctomb( char *s, wchar_t wc );\n  (1)\nerrno_t wctomb_s(int *restrict status, char *restrict s, rsize_t ssz, wchar_t wc);\n  (2)   (since C11)\n\n\nNotes\n   Each call to wctomb updates the internal global conversion state (a static object of type mbstate_t, known only to this function). If the multibyte encoding uses shift states, this function is not reentrant. In any case, multiple threads should not call wctomb without synchronization: wcrtomb or wctomb_s may be used instead.\n   Unlike most bounds-checked functions, wctomb_s does not null-terminate its output, because it is designed to be used in loops that process strings character-by-character.\n\nParameters\ns   -   pointer to the character array for output\nwc   -   wide character to convert\nssz   -   maximum number of bytes to write to s (size of the array s)\nstatus   -   pointer to an out-parameter where the result (length of the multibyte sequence or the shift sequence status) will be stored\n\n\nReturn value\n", "url": "https://devdocs.io/c/string/multibyte/wctomb\n"}, {"name": "wctrans", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nwctrans_t wctrans( const char* str );\n    (since C95)\n\n   Constructs a value of type wctrans_t that describes a LC_CTYPE category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as \"tojhira\" or \"tojkana\".\n\nParameters\nstr   -   C string holding the name of the desired mapping. The following values of str are supported in all C locales:\n   Value of str   Effect \n   \"toupper\"   identifies the mapping used by towupper \n   \"tolower\"   identifies the mapping used by towlower\nValue of str   Effect\n\"toupper\"   identifies the mapping used by towupper\n\"tolower\"   identifies the mapping used by towlower\n\n\nReturn value\n   wctrans_t object suitable for use with towctrans to map wide characters according to the named mapping of the current C locale or zero if str does not name a mapping supported by the current C locale.\n", "url": "https://devdocs.io/c/string/wide/wctrans\n"}, {"name": "wctype", "type": "STANDARD LIB", "description": "Defined in header <wctype.h>\nwctype_t wctype( const char* str );\n    (since C95)\n\n   Constructs a value of type wctype_t that describes a LC_CTYPE category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as \"jkanji\".\n\nParameters\nstr   -   C string holding the name of the desired category\n\n   The following values of str are supported in all C locales:\nvalue of str   effect\n\"alnum\"   identifies the category used by iswalnum\n\"alpha\"   identifies the category used by iswalpha\n\"blank\"   identifies the category used by iswblank (C99)\n\"cntrl\"   identifies the category used by iswcntrl\n\"digit\"   identifies the category used by iswdigit\n\"graph\"   identifies the category used by iswgraph\n\"lower\"   identifies the category used by iswlower\n\"print\"   identifies the category used by iswprint\n\"space\"   identifies the category used by iswspace\n\"upper\"   identifies the category used by iswupper\n\"xdigit\"   identifies the category used by iswxdigit\n\n\nReturn value\n   wctype_t object suitable for use with iswctype to classify wide characters according to the named category of the current C locale or zero if str does not name a category supported by the current C locale.\n", "url": "https://devdocs.io/c/string/wide/wctype\n"}, {"name": "wmemchr", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwchar_t *wmemchr( const wchar_t *ptr, wchar_t ch, size_t count );\n    (since C95)\n\n   Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array or integer array of compatible type, pointed to by ptr.\n   If count is zero, the function returns a null pointer.\n\nParameters\nptr   -   pointer to the wide character array to be examined\nch   -   wide character to search for\ncount   -   number of wide characters to examine\n\n\nReturn value\n   Pointer to the location of the wide character, or a null pointer if no such character is found.\n", "url": "https://devdocs.io/c/string/wide/wmemchr\n"}, {"name": "wmemcmp", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nint wmemcmp( const wchar_t *lhs, const wchar_t *rhs, size_t count );\n    (since C95)\n\n   Compares the first count wide characters of the wide character (or compatible integer type) arrays pointed to by lhs and rhs. The comparison is done lexicographically.\n   The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.\n   If count is zero, the function does nothing.\n\nParameters\nlhs, rhs   -   pointers to the wide character arrays to compare\ncount   -   number of wide characters to examine\n\n\nReturn value\n   Negative value if the value of the first differing wide character in lhs is less than the value of the corresponding wide character in rhs: lhs precedes rhs in lexicographical order.\n   \u200b0\u200b if all count wide characters of lhs and rhs are equal.\n   Positive value if the value of the first differing wide character in lhs is greater than the value of the corresponding wide character in rhs: rhs precedes lhs in lexicographical order.\n\nNotes\n   This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it examines: nulls as well as invalid wide characters are compared too.\n", "url": "https://devdocs.io/c/string/wide/wmemcmp\n"}, {"name": "wmemcpy, wmemcpy_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\n(1)\nwchar_t* wmemcpy( wchar_t* dest, const wchar_t* src, size_t count );\n  (since C95) (until C99)\nwchar_t *wmemcpy(wchar_t *restrict dest, const wchar_t *restrict src,\n                 size_t count );\n  (since C99)\nerrno_t wmemcpy_s( wchar_t *restrict dest, rsize_t destsz,\n                   const wchar_t *restrict src, rsize_t count );\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the wide character array to copy to\nsrc   -   pointer to the wide character array to copy from\ncount   -   number of wide characters to copy\ndestsz   -   max number of wide characters to write (the size of the destination buffer)\n\n\nReturn value\n\nNotes\n   This function's analog for byte strings is strncpy, not strcpy.\n   This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it copies: nulls as well as invalid characters are copied too.\n", "url": "https://devdocs.io/c/string/wide/wmemcpy\n"}, {"name": "wmemmove, wmemmove_s", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwchar_t* wmemmove( wchar_t* dest, const wchar_t* src, size_t count );\n  (1)   (since C95)\nerrno_t wmemmove_s( wchar_t *dest, rsize_t destsz,\n                    const wchar_t *src, rsize_t count);\n  (2)   (since C11)\n\n\nParameters\ndest   -   pointer to the wide character array to copy to\nsrc   -   pointer to the wide character array to copy from\ndestsz   -   max number of wide characters to write (the size of the destination buffer)\ncount   -   number of wide characters to copy\n\n\nReturn value\n\nNotes\n   This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it copies: nulls as well as invalid characters are copied too.\n", "url": "https://devdocs.io/c/string/wide/wmemmove\n"}, {"name": "wmemset", "type": "STANDARD LIB", "description": "Defined in header <wchar.h>\nwchar_t *wmemset( wchar_t *dest, wchar_t ch, size_t count );\n    (since C95)\n\n   Copies the wide character ch into each of the first count wide characters of the wide character array (or integer array of compatible type) pointed to by dest.\n   If overflow occurs, the behavior is undefined.\n   If count is zero, the function does nothing.\n\nParameters\ndest   -   pointer to the wide character array to fill\nch   -   fill wide character\ncount   -   number of wide characters to fill\n\n\nReturn value\n   Returns a copy of dest.\n\nNotes\n   This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it writes: nulls as well as invalid wide characters are written too.\n", "url": "https://devdocs.io/c/string/wide/wmemset\n"}, {"name": "call_once, once_flag, ONCE_FLAG_INIT", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nvoid call_once( once_flag* flag, void (*func)(void) );\n  (1)   (since C11)\ntypedef /* unspecified */ once_flag\n  (2)   (since C11)\n#define ONCE_FLAG_INIT /* unspecified */\n  (3)   (since C11)\n\n\nParameters\nflag   -   pointer to an object of type call_once that is used to ensure func is called only once\nfunc   -   the function to execute only once\n\n\nReturn value\n   (none).\n\nNotes\n   The POSIX equivalent of this function is pthread_once.\n", "url": "https://devdocs.io/c/thread/once_flag_init\n"}, {"name": "cnd_broadcast", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint cnd_broadcast( cnd_t *cond );\n    (since C11)\n\n   Unblocks all thread that currently wait on condition variable pointed to by cond. If no threads are blocked, does nothing and returns thrd_success.\n\nParameters\ncond   -   pointer to a condition variable\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/cnd_broadcast\n"}, {"name": "cnd_destroy", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nvoid cnd_destroy( cnd_t* cond );\n    (since C11)\n\n   Destroys the condition variable pointed to by cond.\n   If there are threads waiting on cond, the behavior is undefined.\n\nParameters\ncond   -   pointer to the condition variable to destroy\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/thread/cnd_destroy\n"}, {"name": "cnd_init", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint cnd_init( cnd_t* cond );\n    (since C11)\n\n   Initializes new condition variable. The object pointed to by cond will be set to value that identifies the condition variable.\n\nParameters\ncond   -   pointer to a variable to store identifier of the condition variable to\n\n\nReturn value\n   thrd_success if the condition variable was successfully created. Otherwise returns thrd_nomem if there was insufficient amount of memory or thrd_error if another error occurred.\n", "url": "https://devdocs.io/c/thread/cnd_init\n"}, {"name": "cnd_signal", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint cnd_signal( cnd_t *cond );\n    (since C11)\n\n   Unblocks one thread that currently waits on condition variable pointed to by cond. If no threads are blocked, does nothing and returns thrd_success.\n\nParameters\ncond   -   pointer to a condition variable\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/cnd_signal\n"}, {"name": "cnd_timedwait", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint cnd_timedwait( cnd_t* restrict cond, mtx_t* restrict mutex,\n                   const struct timespec* restrict time_point );\n    (since C11)\n\n   Atomically unlocks the mutex pointed to by mutex and blocks on the condition variable pointed to by cond until the thread is signalled by cnd_signal or cnd_broadcast, or until the TIME_UTC based time point pointed to by time_point has been reached, or until a spurious wake-up occurs. The mutex is locked again before the function returns.\n   The behavior is undefined if the mutex is not already locked by the calling thread.\n\nParameters\ncond   -   pointer to the condition variable to block on\nmutex   -   pointer to the mutex to unlock for the duration of the block\nduration   -   pointer to a object specifying timeout time to wait until\n\n\nReturn value\n   thrd_success if successful, thrd_timedout if the timeout time has been reached before the mutex is locked, or thrd_error if an error occurred.\n", "url": "https://devdocs.io/c/thread/cnd_timedwait\n"}, {"name": "cnd_wait", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint cnd_wait( cnd_t* cond, mtx_t* mutex );\n    (since C11)\n\n   Atomically unlocks the mutex pointed to by mutex and blocks on the condition variable pointed to by cond until the thread is signalled by cnd_signal or cnd_broadcast, or until a spurious wake-up occurs. The mutex is locked again before the function returns.\n   The behavior is undefined if the mutex is not already locked by the calling thread.\n\nParameters\ncond   -   pointer to the condition variable to block on\nmutex   -   pointer to the mutex to unlock for the duration of the block\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/cnd_wait\n"}, {"name": "mtx_destroy", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nvoid mtx_destroy( mtx_t *mutex );\n    (since C11)\n\n   Destroys the mutex pointed to by mutex.\n   If there are threads waiting on mutex, the behavior is undefined.\n\nParameters\nmutex   -   pointer to the mutex to destroy\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/thread/mtx_destroy\n"}, {"name": "mtx_init", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint mtx_init( mtx_t* mutex, int type );\n    (since C11)\n\n   Creates a new mutex object with type. The object pointed to by mutex is set to an identifier of the newly created mutex.\n   type must have one of the following values:\n\nParameters\nmutex   -   pointer to the mutex to initialize\ntype   -   the type of the mutex\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/mtx_init\n"}, {"name": "mtx_lock", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint mtx_lock( mtx_t* mutex );\n    (since C11)\n\n   Blocks the current thread until the mutex pointed to by mutex is locked.\n   The behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.\n   Prior calls to mtx_unlock on the same mutex synchronize-with this operation, and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic).\n\nParameters\nmutex   -   pointer to the mutex to lock\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/mtx_lock\n"}, {"name": "mtx_plain, mtx_recursive, mtx_timed", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nenum {\n    mtx_plain = /* unspecified */,\n    mtx_recursive = /* unspecified */,\n    mtx_timed = /* unspecified */\n};\n    (since C11)\n\n   When passed to mtx_init, identifies the type of a mutex to create.\nConstant   Explanation\nmtx_plain   plain mutex\nmtx_recursive   recursive mutex\nmtx_timed   timed mutex\n\n", "url": "https://devdocs.io/c/thread/mtx_types\n"}, {"name": "mtx_timedlock", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint mtx_timedlock( mtx_t *restrict mutex,\n                   const struct timespec *restrict time_point );\n    (since C11)\n\n   Blocks the current thread until the mutex pointed to by mutex is locked or until the TIME_UTC based time point pointed to by time_point has been reached.\n   The behavior is undefined if the current thread has already locked the mutex and the mutex is not recursive.\n   The behavior is undefined if the mutex does not support timeout.\n   Prior calls to mtx_unlock on the same mutex synchronize-with this operation (if this operation succeeds), and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic).\n\nParameters\nmutex   -   pointer to the mutex to lock\ntime_point   -   pointer to the timeout time to wait until\n\n\nReturn value\n   thrd_success if successful, thrd_timedout if the timeout time has been reached before the mutex is locked, thrd_error if an error occurs.\n", "url": "https://devdocs.io/c/thread/mtx_timedlock\n"}, {"name": "mtx_trylock", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint mtx_trylock( mtx_t *mutex );\n    (since C11)\n\n   Tries to lock the mutex pointed to by mutex without blocking. Returns immediately if the mutex is already locked.\n   Prior calls to mtx_unlock on the same mutex synchronize-with this operation (if this operation succeeds), and all lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic).\n\nParameters\nmutex   -   pointer to the mutex to lock\n\n\nReturn value\n   thrd_success if successful, thrd_busy if the mutex has already been locked or due to a spurious failure to acquire an available mutex (since C17), thrd_error if an error occurs.\n", "url": "https://devdocs.io/c/thread/mtx_trylock\n"}, {"name": "mtx_unlock", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint mtx_unlock( mtx_t *mutex );\n    (since C11)\n\n   Unlocks the mutex pointed to by mutex.\n   The behavior is undefined if the mutex is not locked by the calling thread.\n   This function synchronizes-with subsequent mtx_lock, mtx_trylock, or mtx_timedlock on the same mutex. All lock/unlock operations on any given mutex form a single total order (similar to the modification order of an atomic).\n\nParameters\nmutex   -   pointer to the mutex to unlock\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/mtx_unlock\n"}, {"name": "thrd_success, thrd_timedout, thrd_busy, thrd_nomem, thrd_error", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nenum {\n    thrd_success = /* unspecified */,\n    thrd_nomem = /* unspecified */,\n    thrd_timedout = /* unspecified */,\n    thrd_busy = /* unspecified */,\n    thrd_error = /* unspecified */\n};\n    (since C11)\n\n   Identifiers for thread states and errors.\nConstant   Explanation\nthrd_success   indicates successful return value\nthrd_timedout   indicates timed out return value\nthrd_busy   indicates unsuccessful return value due to resource temporary unavailable\nthrd_nomem   indicates unsuccessful return value due to out of memory condition\nthrd_error   indicates unsuccessful return value\n\n", "url": "https://devdocs.io/c/thread/thrd_errors\n"}, {"name": "thrd_create", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint thrd_create( thrd_t *thr, thrd_start_t func, void *arg );\n    (since C11)\n\n   Creates a new thread executing the function func. The function is invoked as func(arg).\n   If successful, the object pointed to by thr is set to the identifier of the new thread.\n   The completion of this function synchronizes-with the beginning of the thread.\n\nParameters\nthr   -   pointer to memory location to put the identifier of the new thread\nfunc   -   function to execute\narg   -   argument to pass to the function\n\n\nReturn value\n   thrd_success if the creation of the new thread was successful. Otherwise returns thrd_nomem if there was insufficient amount of memory or thrd_error if another error occurred.\n\nNotes\n   The thread identifiers may be reused for new threads once the thread has finished and joined or detached.\n   The type thrd_start_t is a typedef of int(*)(void*), which differs from the POSIX equivalent void*(*)(void*).\n   All thread-specific storage values (see tss_create) are initialized to NULL.\n   Return from the function func is equivalent to calling thrd_exit with the argument equal to the return value of func.\n", "url": "https://devdocs.io/c/thread/thrd_create\n"}, {"name": "thrd_current", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nthrd_t thrd_current(void);\n    (since C11)\n\n   Returns the identifier of the calling thread.\n\nParameters\n   (none).\n\nReturn value\n   The identifier of the calling thread.\n", "url": "https://devdocs.io/c/thread/thrd_current\n"}, {"name": "thrd_detach", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint thrd_detach( thrd_t thr );\n    (since C11)\n\n   Detaches the thread identified by thr from the current environment. The resources held by the thread will be freed automatically once the thread exits.\n\nParameters\nthr   -   identifier of the thread to detach\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/thrd_detach\n"}, {"name": "thrd_equal", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint thrd_equal( thrd_t lhs, thrd_t rhs );\n    (since C11)\n\n   Checks whether lhs and rhs refer to the same thread.\n\nParameters\nlhs, rhs   -   threads to compare\n\n\nReturn value\n   Non-zero value if lhs and rhs refer to the same value, \u200b0\u200b otherwise.\n", "url": "https://devdocs.io/c/thread/thrd_equal\n"}, {"name": "thrd_exit", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\n_Noreturn void thrd_exit( int res );\n    (since C11)\n\n   First, for every thread-specific storage key which was created with a non-null destructor and for which the associated value is non-null (see tss_create), thrd_exit sets the value associated with the key to NULL and then invokes the destructor with the previous value of the key. The order in which the destructors are invoked is unspecified.\n   If, after this, there remain keys with both non-null destructors and values (e.g. if a destructor executed tss_set), the process is repeated up to TSS_DTOR_ITERATIONS times.\n   FInally, the thrd_exit function terminates execution of the calling thread and sets its result code to res.\n   If the last thread in the program is terminated with thrd_exit, the entire program terminates as if by calling exit with EXIT_SUCCESS as the argument (so the functions registered by atexit are executed in the context of that last thread).\n\nParameters\nres   -   the result value to return\n\n\nReturn value\n   (none).\n", "url": "https://devdocs.io/c/thread/thrd_exit\n"}, {"name": "thrd_join", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint thrd_join( thrd_t thr, int *res );\n    (since C11)\n\n   Blocks the current thread until the thread identified by thr finishes execution.\n   If res is not a null pointer, the result code of the thread is put to the location pointed to by res.\n   The termination of the thread synchronizes-with the completion of this function.\n   The behavior is undefined if the thread was previously detached or joined by another thread.\n\nParameters\nthr   -   identifier of the thread to join\nres   -   location to put the result code to\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/thrd_join\n"}, {"name": "thrd_sleep", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint thrd_sleep( const struct timespec* duration,\n                struct timespec* remaining );\n    (since C11)\n\n   Blocks the execution of the current thread for at least until the TIME_UTC based duration pointed to by duration has elapsed.\n   The sleep may resume earlier if a signal that is not ignored is received. In such case, if remaining is not NULL, the remaining time duration is stored into the object pointed to by remaining.\n\nParameters\nduration   -   pointer to the duration to sleep for\nremaining   -   pointer to the object to put the remaining time on interruption. May be NULL, in which case it is ignored\n\n\nReturn value\n   \u200b0\u200b on successful sleep, -1 if a signal occurred, other negative value if an error occurred.\n\nNotes\n   duration and remaining may point at the same object, which simplifies re-running the function after a signal.\n   The actual sleep time may be longer than requested because it is rounded up to the timer granularity and because of scheduling and context switching overhead.\n   The POSIX equivalent of this function is nanosleep.\n", "url": "https://devdocs.io/c/thread/thrd_sleep\n"}, {"name": "thrd_yield", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nvoid thrd_yield(void);\n    (since C11)\n\n   Provides a hint to the implementation to reschedule the execution of threads, allowing other threads to run.\n\nParameters\n   (none).\n\nReturn value\n   (none).\n\nNotes\n   The exact behavior of this function depends on the implementation, in particular on the mechanics of the OS scheduler in use and the state of the system. For example, a first-in-first-out realtime scheduler (SCHED_FIFO in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, yield has no effect).\n   The POSIX equivalent of this function is sched_yield.\n", "url": "https://devdocs.io/c/thread/thrd_yield\n"}, {"name": "Thread support library", "type": "STANDARD LIB", "description": "   If the macro constant __STDC_NO_THREADS__(C11) is defined by the compiler, the header <threads.h> and all of the names listed here are not provided.\n\nThreads\nDefined in header <threads.h>\nthrd_t   implementation-defined complete object type identifying a thread\nthrd_create\n(C11)   creates a thread  (function)\nthrd_equal\n(C11)   checks if two identifiers refer to the same thread  (function)\nthrd_current\n(C11)   obtains the current thread identifier  (function)\nthrd_sleep\n(C11)   suspends execution of the calling thread for the given period of time  (function)\nthrd_yield\n(C11)   yields the current time slice  (function)\nthrd_exit\n(C11)   terminates the calling thread  (function)\nthrd_detach\n(C11)   detaches a thread  (function)\nthrd_join\n(C11)   blocks until a thread terminates  (function)\nthrd_successthrd_timedoutthrd_busythrd_nomemthrd_error\n(C11)   indicates a thread error status  (constant)\nthrd_start_t\n(C11)   a typedef of the function pointer type int(*)(void*), used by thrd_create  (typedef)\n\n\nMutual exclusion\nDefined in header <threads.h>\nmtx_t   mutex identifier\nmtx_init\n(C11)   creates a mutex  (function)\nmtx_lock\n(C11)   blocks until locks a mutex  (function)\nmtx_timedlock\n(C11)   blocks until locks a mutex or times out  (function)\nmtx_trylock\n(C11)   locks a mutex or returns without blocking if already locked  (function)\nmtx_unlock\n(C11)   unlocks a mutex  (function)\nmtx_destroy\n(C11)   destroys a mutex  (function)\nmtx_plainmtx_recursivemtx_timed\n(C11)(C11)(C11)   defines the type of a mutex  (enum)\nCall once\ncall_once\n(C11)   calls a function exactly once  (function)\n\n\nCondition variables\nDefined in header <threads.h>\ncnd_t   condition variable identifier\ncnd_init\n(C11)   creates a condition variable  (function)\ncnd_signal\n(C11)   unblocks one thread blocked on a condition variable  (function)\ncnd_broadcast\n(C11)   unblocks all threads blocked on a condition variable  (function)\ncnd_wait\n(C11)   blocks on a condition variable  (function)\ncnd_timedwait\n(C11)   blocks on a condition variable, with a timeout  (function)\ncnd_destroy\n(C11)   destroys a condition variable  (function)\n\n\nThread-local storage\nDefined in header <threads.h>\nthread_local\n(C11)   thread local type macro  (keyword macro)\ntss_t   thread-specific storage pointer\nTSS_DTOR_ITERATIONS\n(C11)   maximum number of times destructors are called  (macro constant)\ntss_dtor_t   function pointer type void(*)(void*), used for TSS destructor\ntss_create\n(C11)   creates thread-specific storage pointer with a given destructor  (function)\ntss_get\n(C11)   reads from thread-specific storage  (function)\ntss_set\n(C11)   write to thread-specific storage  (function)\ntss_delete\n(C11)   releases the resources held by a given thread-specific pointer  (function)\n\n\nReserved identifiers\n   Function names, type names, and enumeration constants that begin with either cnd_, mtx_, thrd_, or tss_, and a lowercase letter may be added to the declarations in the <threads.h> header in future revisions of the C standard, and portable programs should not use those identifiers.\n", "url": "https://devdocs.io/c/thread\n"}, {"name": "thread_local", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\n#define thread_local _Thread_local\n    (since C11)\n\n   Convenience macro which can be used to specify that an object has thread-local storage duration.\n", "url": "https://devdocs.io/c/thread/thread_local\n"}, {"name": "tss_create", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint tss_create( tss_t* tss_key, tss_dtor_t destructor );\n    (since C11)\n\n   Creates new thread-specific storage key and stores it in the object pointed to by tss_key. Although the same key value may be used by different threads, the values bound to the key by tss_set are maintained on a per-thread basis and persist for the life of the calling thread.\n   The value NULL is associated with the newly created key in all existing threads, and upon thread creation, the values associated with all TSS keys is initialized to NULL.\n   If destructor is not a null pointer, then also associates the destructor which is called when the storage is released by thrd_exit (but not by tss_delete and not at program termination by exit).\n   A call to tss_create from within a thread-specific storage destructor results in undefined behavior.\n\nParameters\ntss_key   -   pointer to memory location to store the new thread-specific storage key\ndestructor   -   pointer to a function to call at thread exit\n\n\nNotes\n   The POSIX equivalent of this function is pthread_key_create.\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n", "url": "https://devdocs.io/c/thread/tss_create\n"}, {"name": "tss_delete", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nvoid tss_delete( tss_t tss_id );\n    (since C11)\n\n   Destroys the thread-specific storage identified by tss_id.\n   The destructor, if one was registered by tss_create, is not called (they are only called at thread exit, either by thrd_exit or by returning from the thread function), it is the responsibility of the programmer to ensure that every thread that is aware of tss_id performed all necessary cleanup, before the call to tss_delete is made.\n   If tss_delete is called while another thread is executing destructors for tss_id, it's unspecified whether this changes the number of invocations to the associated destructor.\n   If tss_delete is called while the calling thread is executing destructors, then the destructor associated with tss_id will not be executed again on this thread.\n\nParameters\ntss_id   -   thread-specific storage key previously returned by tss_create and not yet deleted by tss_delete\n\n\nReturn value\n   (none).\n\nNotes\n   The POSIX equivalent of this function is pthread_key_delete.\n   The reason tss_delete never calls destructors is that the destructors (called at thread exit) are normally intended to be executed by the same thread that originally set the value (via tss_set) that the destructor will be dealing with, and may even rely on the values of that or other thread-specific data as seen by that thread. The thread executing tss_delete has no access to other threads' TSS. Even if it were possible to call the destructor for each thread's own value associated with tss_id, tss_delete would have to synchronize with every thread if only to examine whether the value of this TSS in that thread is null (destructors are only called against non-null values).\n", "url": "https://devdocs.io/c/thread/tss_delete\n"}, {"name": "TSS_DTOR_ITERATIONS", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\n#define TSS_DTOR_ITERATIONS /* unspecified */\n    (since C11)\n\n   Expands to a positive integral constant expression defining the maximum number of times a destructor for thread-local storage pointer will be called by thrd_exit.\n   This constant is equivalent to the POSIX PTHREAD_DESTRUCTOR_ITERATIONS.\n", "url": "https://devdocs.io/c/thread/tss_dtor_iterations\n"}, {"name": "tss_get", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nvoid *tss_get( tss_t tss_key );\n    (since C11)\n\n   Returns the value held in thread-specific storage for the current thread identified by tss_key. Different threads may get different values identified by the same key.\n   On thread startup (see thrd_create), the values associated with all TSS keys are NULL. Different value may be placed in the thread-specific storage with tss_set.\n\nParameters\ntss_key   -   thread-specific storage key, obtained from tss_create and not deleted by tss_delete\n\n\nReturn value\n   The value on success, NULL on failure.\n\nNotes\n   The POSIX equivalent for this function is pthread_getspecific.\n", "url": "https://devdocs.io/c/thread/tss_get\n"}, {"name": "tss_set", "type": "STANDARD LIB", "description": "Defined in header <threads.h>\nint tss_set( tss_t tss_id, void *val );\n    (since C11)\n\n   Sets the value of the thread-specific storage identified by tss_id for the current thread to val. Different threads may set different values to the same key.\n   The destructor, if available, is not invoked.\n\nParameters\ntss_id   -   thread-specific storage key, obtained from tss_create and not deleted by tss_delete\nval   -   value to set thread-specific storage to\n\n\nReturn value\n   thrd_success if successful, thrd_error otherwise.\n\nNotes\n   The POSIX equivalent of this function is pthread_setspecific.\n   Typically TSS is used to store pointers to blocks of dynamically allocated memory that have been reserved for use by the calling thread.\n   tss_set may be called in the TSS destructor. If the destructor exits with non-NULL value in the TSS storage, it will be retried by thrd_exit up to TSS_DTOR_ITERATIONS times, after which the storage will be lost.\n", "url": "https://devdocs.io/c/thread/tss_set\n"}, {"name": "Boolean type support library", "type": "STANDARD LIB", "description": "   The C programming language, as of C99, supports Boolean arithmetic with the built-in type _Bool (see _Bool). When the header <stdbool.h> is included, the Boolean type is also accessible as bool.\n   Standard logical operators &&, ||, ! can be used with the Boolean type in any combination.\n   A program may undefine and perhaps then redefine the macros bool, true and false.\n\nMacros\nMacro name   Expands to\nbool   _Bool\ntrue   integer constant 1\nfalse   integer constant 0\n__bool_true_false_are_defined   integer constant 1\n\n\nSee also\n", "url": "https://devdocs.io/c/types/boolean\n"}, {"name": "Fixed width integer types (since C99)\n", "type": "STANDARD LIB", "description": "\nTypes\nDefined in header <stdint.h>\nint8_tint16_tint32_tint64_t   signed integer type with width of exactly 8, 16, 32 and 64 bits respectivelywith no padding bits and using 2's complement for negative values(provided only if the implementation directly supports the type)\nint_fast8_tint_fast16_tint_fast32_tint_fast64_t   fastest signed integer type with width of at least 8, 16, 32 and 64 bits respectively\nint_least8_tint_least16_tint_least32_tint_least64_t   smallest signed integer type with width of at least 8, 16, 32 and 64 bits respectively\nintmax_t   maximum width integer type\nintptr_t   integer type capable of holding a pointer\nuint8_tuint16_tuint32_tuint64_t   unsigned integer type with width of exactly 8, 16, 32 and 64 bits respectively (provided only if the implementation directly supports the type)\nuint_fast8_tuint_fast16_tuint_fast32_tuint_fast64_t   fastest unsigned integer type with width of at least 8, 16, 32 and 64 bits respectively\nuint_least8_tuint_least16_tuint_least32_tuint_least64_t   smallest unsigned integer type with width of at least 8, 16, 32 and 64 bits respectively\nuintmax_t   maximum width unsigned integer type\nuintptr_t   unsigned integer type capable of holding a pointer\n\n\nMacro constants\nDefined in header <stdint.h>\nSigned integers : minimum value\nINT8_MININT16_MININT32_MININT64_MIN   minimum value of an object of type int8_t, int16_t, int32_t, int64_t  (macro constant)\nINT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN   minimum value of an object of type int_fast8_t, int_fast16_t, int_fast32_t, int_fast64_t  (macro constant)\nINT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN   minimum value of an object of type int_least8_t, int_least16_t, int_least32_t, int_least64_t  (macro constant)\nINTPTR_MIN   minimum value of an object of type intptr_t  (macro constant)\nINTMAX_MIN   minimum value of an object of type intmax_t  (macro constant)\nSigned integers : maximum value\nINT8_MAXINT16_MAXINT32_MAXINT64_MAX   maximum value of an object of type int8_t, int16_t, int32_t, int64_t  (macro constant)\nINT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX   maximum value of an object of type int_fast8_t, int_fast16_t, int_fast32_t, int_fast64_t  (macro constant)\nINT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX   maximum value of an object of type int_least8_t, int_least16_t, int_least32_t, int_least64_t  (macro constant)\nINTPTR_MAX   maximum value of an object of type intptr_t  (macro constant)\nINTMAX_MAX   maximum value of an object of type intmax_t  (macro constant)\nUnsigned integers : maximum value\nUINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX   maximum value of an object of type uint8_t, uint16_t, uint32_t, uint64_t  (macro constant)\nUINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX   maximum value of an object of type uint_fast8_t, uint_fast16_t, uint_fast32_t, uint_fast64_t  (macro constant)\nUINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX   maximum value of an object of type uint_least8_t, uint_least16_t, uint_least32_t, uint_least64_t  (macro constant)\nUINTPTR_MAX   maximum value of an object of type uintptr_t  (macro constant)\nUINTMAX_MAX   maximum value of an object of type uintmax_t  (macro constant)\n\n\nFunction macros for minimum-width integer constants\nINT8_CINT16_CINT32_CINT64_C   expands to an integer constant expression having the value specified by its argument and the type int_least8_t, int_least16_t, int_least32_t, int_least64_t respectively  (function macro)\nINTMAX_C   expands to an integer constant expression having the value specified by its argument and the type intmax_t  (function macro)\nUINT8_CUINT16_CUINT32_CUINT64_C   expands to an integer constant expression having the value specified by its argument and the type uint_least8_t, uint_least16_t, uint_least32_t, uint_least64_t respectively  (function macro)\nUINTMAX_C   expands to an integer constant expression having the value specified by its argument and the type uintmax_t  (function macro)\n\n\nFormat macro constants\nDefined in header <inttypes.h>\n\nEquivalentfor int orunsigned int   Description   Macros for data types\n[u]intx_t\n   [u]int_leastx_t   [u]int_fastx_t   [u]intmax_t   [u]intptr_t\nx = 8, 16, 32 or 64\nd   output of a signed decimal integer value   PRIdx   PRIdLEASTx   PRIdFASTx   PRIdMAX   PRIdPTR\ni   PRIix   PRIiLEASTx   PRIiFASTx   PRIiMAX   PRIiPTR\nu   output of an unsigned decimal integer value   PRIux   PRIuLEASTx   PRIuFASTx   PRIuMAX   PRIuPTR\no   output of an unsigned octal integer value   PRIox   PRIoLEASTx   PRIoFASTx   PRIoMAX   PRIoPTR\nx   output of an unsigned lowercase hexadecimal integer value   PRIxx   PRIxLEASTx   PRIxFASTx   PRIxMAX   PRIxPTR\nX   output of an unsigned uppercase hexadecimal integer value   PRIXx   PRIXLEASTx   PRIXFASTx   PRIXMAX   PRIXPTR\n\nEquivalentfor int orunsigned int   Description   Macros for data types\n[u]intx_t\n   [u]int_leastx_t   [u]int_fastx_t   [u]intmax_t   [u]intptr_t\nx = 8, 16, 32 or 64\nd   input of a signed decimal integer value   SCNdx   SCNdLEASTx   SCNdFASTx   SCNdMAX   SCNdPTR\ni   input of a signed integer value (base is determined by the first characters parsed)   SCNix   SCNiLEASTx   SCNiFASTx   SCNiMAX   SCNiPTR\nu   input of an unsigned decimal integer value   SCNux   SCNuLEASTx   SCNuFASTx   SCNuMAX   SCNuPTR\no   input of an unsigned octal integer value   SCNox   SCNoLEASTx   SCNoFASTx   SCNoMAX   SCNoPTR\nx   input of an unsigned hexadecimal integer value   SCNxx   SCNxLEASTx   SCNxFASTx   SCNxMAX   SCNxPTR\n\n\nSee also\n", "url": "https://devdocs.io/c/types/integer\n"}, {"name": "FLT_EVAL_METHOD", "type": "STANDARD LIB", "description": "Defined in header <float.h>\n#define FLT_EVAL_METHOD /* implementation defined */\n    (since C99)\n\n   Specifies range and precision of floating-point values obtained from floating-point constants and from all operations (operators, implicit conversions of operands) except assignment, cast, and library function call.\nValue   Explanation\nnegative values except -1   implementation-defined behavior\n-1   the default precision is not known\n0   all operations and constants evaluate in the range and precision of the type used. Additionally, float_t and double_t are equivalent to float and double respectively\n1   all operations and constants evaluate in the range and precision of double. Additionally, both float_t and double_t are equivalent to double\n2   all operations and constants evaluate in the range and precision of long double. Additionally, both float_t and double_t are equivalent to long double\n\n\nNotes\n   Regardless of the value of FLT_EVAL_METHOD, any floating-point expression may be contracted, that is, calculated as if all intermediate results have infinite range and precision (unless #pragma STDC FP_CONTRACT is off).\n   Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.\n\nSee also\n", "url": "https://devdocs.io/c/types/limits/flt_eval_method\n"}, {"name": "FLT_ROUNDS", "type": "STANDARD LIB", "description": "Defined in header <float.h>\n#define FLT_ROUNDS /* implementation defined */\n\n   Returns the current rounding direction of floating-point arithmetic operations.\nValue   Explanation\n-1   the default rounding direction is not known\n0   toward zero; same meaning as FE_TOWARDZERO\n1   to nearest; same meaning as FE_TONEAREST\n2   towards positive infinity; same meaning as FE_UPWARD\n3   towards negative infinity; same meaning as FE_DOWNWARD\nother values   implementation-defined behavior\n\n\nNotes\n   The rounding mode can be changed with fesetround and FLT_ROUNDS reflects that change.\n\nSee also\nfegetroundfesetround\n(C99)(C99)   gets or sets rounding direction  (function)\nFE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD\n(C99)   floating-point rounding direction  (macro constant)\n\n", "url": "https://devdocs.io/c/types/limits/flt_rounds\n"}, {"name": "max_align_t", "type": "STANDARD LIB", "description": "Defined in header <stddef.h>\ntypedef /*implementation-defined*/ max_align_t;\n    (since C11)\n\n   max_align_t is a type whose alignment requirement is at least as strict (as large) as that of every scalar type.\n\nNotes\n   Pointers returned by allocation functions such as malloc are suitably aligned for any object, which means they are aligned at least as strictly as max_align_t.\n   max_align_t is usually synonymous with the largest scalar type, which is long double on most platforms, and its alignment requirement is either 8 or 16.\n\nSee also\n", "url": "https://devdocs.io/c/types/max_align_t\n"}, {"name": "NULL", "type": "STANDARD LIB", "description": "Defined in header <stddef.h>\nDefined in header <string.h>\nDefined in header <wchar.h>\nDefined in header <time.h>\nDefined in header <locale.h>\nDefined in header <stdio.h>\nDefined in header <stdlib.h>\n#define NULL /*implementation-defined*/\n\n   The macro NULL is an implementation-defined null pointer constant, which may be.\n   A null pointer constant may be converted to any pointer type; such conversion results in the null pointer value of that type.\n\nPossible implementation\n// C++ compatible:\n#define NULL 0\n// C++ incompatible:\n#define NULL (10*2 - 20)\n#define NULL ((void*)0)\n\n\nSee also\n", "url": "https://devdocs.io/c/types/null\n"}, {"name": "Numeric limits", "type": "STANDARD LIB", "description": "\nLimits of library types\nDefined in header <stdint.h>\nPTRDIFF_MIN\n(C99)   minimum value of object of ptrdiff_t type  (macro constant)\nPTRDIFF_MAX\n(C99)   maximum value of object of ptrdiff_t type  (macro constant)\nSIZE_MAX\n(C99)   maximum value of object of size_t type  (macro constant)\nSIG_ATOMIC_MIN\n(C99)   minimum value of object of sig_atomic_t type  (macro constant)\nSIG_ATOMIC_MAX\n(C99)   maximum value of object of sig_atomic_t type  (macro constant)\nWINT_MIN\n(C99)   minimum value of object of wint_t type  (macro constant)\nWINT_MAX\n(C99)   maximum value of object of wint_t type  (macro constant)\nDefined in header <wchar.h>\nWCHAR_MIN\n(C99)   minimum value of object of wchar_t type  (macro constant)\nWCHAR_MAX\n(C99)   maximum value of object of wchar_t type  (macro constant)\n\n\nLimits of integer types\nDefined in header <limits.h>\nCHAR_BIT   number of bits in a byte  (macro constant)\nMB_LEN_MAX   maximum number of bytes in a multibyte character  (macro constant)\nCHAR_MIN   minimum value of char  (macro constant)\nCHAR_MAX   maximum value of char  (macro constant)\nSCHAR_MINSHRT_MININT_MINLONG_MINLLONG_MIN\n(C99)   minimum value of signed char, short, int, long and long long respectively  (macro constant)\nSCHAR_MAXSHRT_MAXINT_MAXLONG_MAXLLONG_MAX\n(C99)   maximum value of signed char, short, int, long and long long respectively  (macro constant)\nUCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX\n(C99)   maximum value of unsigned char, unsigned short, unsigned int,unsigned long and unsigned long long respectively  (macro constant)\n\n\nLimits of floating point types\nDefined in header <float.h>\nFLT_RADIX   the radix (integer base) used by the representation of all three floating-point types  (macro constant)\nDECIMAL_DIG\n(C99)   conversion from long double to decimal with at least DECIMAL_DIG digits and back to long double is the identity conversion: this is the decimal precision required to serialize/deserialize a long double  (macro constant)\nFLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG\n(C11)   conversion from float/double/long double to decimal with at least FLT_DECIMAL_DIG/DBL_DECIMAL_DIG/LDBL_DECIMAL_DIG digits and back is the identity conversion: this is the decimal precision required to serialize/deserialize a floating point value. Defined to at least 6, 10, and 10 respectively, or 9 for IEEE float and 17 for IEEE double. (see also the C++ analog max_digits10)  (macro constant)\nFLT_MINDBL_MINLDBL_MIN   minimum, normalized, positive value of float, double and long double respectively  (macro constant)\nFLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN\n(C11)   minimum positive value of float, double and long double respectively  (macro constant)\nFLT_MAXDBL_MAXLDBL_MAX   maximum value of float, double and long double respectively  (macro constant)\nFLT_EPSILONDBL_EPSILONLDBL_EPSILON   difference between 1.0 and the next representable value for float, double and long double respectively  (macro constant)\nFLT_DIGDBL_DIGLDBL_DIG   number of decimal digits that are guaranteed to be preserved in text -> float/double/long double -> text roundtrip without change due to rounding or overflow (see the C++ analog digits10 for detail)  (macro constant)\nFLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG   number of base-FLT_RADIX digits that are in the floating-point mantissa and that can be represented without losing precision for float, double and long double respectively  (macro constant)\nFLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP   minimum negative integer such that FLT_RADIX raised by power one less than that integer is a normalized float, double and long double respectively  (macro constant)\nFLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP   minimum negative integer such that 10 raised by power one less than that integer is a normalized float, double and long double respectively  (macro constant)\nFLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP   maximum positive integer such that FLT_RADIX raised by power one less than that integer is a normalized float, double and long double respectively  (macro constant)\nFLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP   maximum positive integer such that 10 raised by power one less than that integer is a normalized float, double and long double respectively  (macro constant)\nFLT_ROUNDS   rounding mode of floating-point arithmetics  (macro constant)\nFLT_EVAL_METHOD\n(C99)   use of extended precision for intermediate results: 0 not used, 1 double is used instead of float, 2: long double is used  (macro constant)\nFLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM\n(C11)   whether the type supports subnormal (denormal) numbers: -1 indeterminable, 0 absent, 1 present  (macro constant)\n\n\nSee also\n", "url": "https://devdocs.io/c/types/limits\n"}, {"name": "offsetof", "type": "STANDARD LIB", "description": "Defined in header <stddef.h>\n#define offsetof(type, member) /*implementation-defined*/\n\n   The macro offsetof expands to an integer constant expression of type size_t, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.\n\nSee also\nsize_t   unsigned integer type returned by the sizeof operator  (typedef)\n\n", "url": "https://devdocs.io/c/types/offsetof\n"}, {"name": "ptrdiff_t", "type": "STANDARD LIB", "description": "Defined in header <stddef.h>\ntypedef /*implementation-defined*/ ptrdiff_t;\n\n   ptrdiff_t is the signed integer type of the result of subtracting two pointers.\n\nNotes\n   ptrdiff_t is used for pointer arithmetic and array indexing, if negative values are possible. Programs that use other types, such as int, may fail on, e.g. 64-bit systems when the index exceeds INT_MAX or if it relies on 32-bit modular arithmetic.\n   Only pointers to elements of the same array (including the pointer one past the end of the array) may be subtracted from each other.\n   If an array is so large (greater than PTRDIFF_MAX elements, but less than SIZE_MAX bytes), that the difference between two pointers may not be representable as ptrdiff_t, the result of subtracting two such pointers is undefined.\n   For char arrays shorter than PTRDIFF_MAX, ptrdiff_t acts as the signed counterpart of size_t: it can store the size of the array of any type and is, on most platforms, synonymous with intptr_t).\n\nSee also\nsize_t   unsigned integer type returned by the sizeof operator  (typedef)\noffsetof   byte offset from the beginning of a struct type to specified member  (function macro)\n\n", "url": "https://devdocs.io/c/types/ptrdiff_t\n"}, {"name": "size_t", "type": "STANDARD LIB", "description": "Defined in header <stddef.h>\nDefined in header <stdio.h>\nDefined in header <stdlib.h>\nDefined in header <string.h>\nDefined in header <time.h>\nDefined in header <uchar.h>    (since C11)\nDefined in header <wchar.h>    (since C95)\ntypedef /*implementation-defined*/ size_t;\n\n   size_t is the unsigned integer type of the result of sizeof , alignof (since C11) and offsetof, depending on the data model.\n\nNotes\n   size_t can store the maximum size of a theoretically possible object of any type (including array).\n   size_t is commonly used for array indexing and loop counting. Programs that use other types, such as unsigned int, for array indexing may fail on, e.g. 64-bit systems when the index exceeds UINT_MAX or if it relies on 32-bit modular arithmetic.\n\nSee also\nptrdiff_t   signed integer type returned when subtracting two pointers  (typedef)\noffsetof   byte offset from the beginning of a struct type to specified member  (function macro)\n\n", "url": "https://devdocs.io/c/types/size_t\n"}, {"name": "Type support", "type": "STANDARD LIB", "description": "\nBasic types\nDefined in header <stddef.h>\nsize_t   unsigned integer type returned by the sizeof operator  (typedef)\nptrdiff_t   signed integer type returned when subtracting two pointers  (typedef)\nNULL   implementation-defined null pointer constant  (macro constant)\nmax_align_t\n(C11)   a type with alignment requirement as great as any other scalar type  (typedef)\noffsetof   byte offset from the beginning of a struct type to specified member  (function macro)\nDefined in header <stdalign.h>\nalignas\n(C11)   convenience macro, expands to keyword _Alignas  (keyword macro)\nalignof\n(C11)   convenience macro, expands to keyword _Alignof  (keyword macro)\n__alignas_is_defined\n(C11)   expands to integer constant 1  (macro constant)\n__alignof_is_defined\n(C11)   expands to integer constant 1  (macro constant)\nDefined in header <stdnoreturn.h>\nnoreturn\n(C11)   convenience macro, expands to _Noreturn  (keyword macro)\n\n", "url": "https://devdocs.io/c/types\n"}, {"name": "Variadic functions", "type": "STANDARD LIB", "description": "   Variadic functions are functions (e.g. printf) which take a variable number of arguments.\n   The declaration of a variadic function uses an ellipsis as the last parameter, e.g. int printf(const char* format, ...);. See variadic arguments for additional detail on the syntax and automatic argument conversions.\n   Accessing the variadic arguments from the function body uses the following library facilities:\nMacros\nDefined in header <stdarg.h>\nva_start   enables access to variadic function arguments  (function macro)\nva_arg   accesses the next variadic function argument  (function macro)\nva_copy\n(C99)   makes a copy of the variadic function arguments  (function macro)\nva_end   ends traversal of the variadic function arguments  (function macro)\nType\nva_list   holds the information needed by va_start, va_arg, va_end, and va_copy  (typedef)\n\n", "url": "https://devdocs.io/c/variadic\n"}, {"name": "va_arg", "type": "STANDARD LIB", "description": "Defined in header <stdarg.h>\nT va_arg( va_list ap, T );\n\n   The va_arg macro expands to an expression of type T that corresponds to the next parameter from the va_list ap.\n   Prior to calling va_arg, ap must be initialized by a call to either va_start or va_copy, with no intervening call to va_end. Each invocation of the va_arg macro modifies ap to point to the next variable argument.\n   If the type of the next argument in ap (after promotions) is not compatible with T, the behavior is undefined, unless:\n   If va_arg is called when there are no more arguments in ap, the behavior is undefined.\n\nParameters\nap   -   an instance of the va_list type\nT   -   the type of the next parameter in ap\n\n\nExpanded value\n   the next variable parameter in ap.\n", "url": "https://devdocs.io/c/variadic/va_arg\n"}, {"name": "va_copy", "type": "STANDARD LIB", "description": "Defined in header <stdarg.h>\nvoid va_copy( va_list dest, va_list src );\n    (since C99)\n\n   The va_copy macro copies src to dest.\n   va_end should be called on dest before the function returns or any subsequent re-initialization of dest (via calls to va_start or va_copy).\n\nParameters\ndest   -   an instance of the va_list type to initialize\nsrc   -   the source va_list that will be used to initialize dest\n\n\nExpanded value\n   (none).\n", "url": "https://devdocs.io/c/variadic/va_copy\n"}, {"name": "va_end", "type": "STANDARD LIB", "description": "Defined in header <stdarg.h>\nvoid va_end( va_list ap );\n\n   The va_end macro performs cleanup for an ap object initialized by a call to va_start or va_copy. va_end may modify ap so that it is no longer usable.\n   If there is no corresponding call to va_start or va_copy, or if va_end is not called before a function that calls va_start or va_copy returns, the behavior is undefined.\n\nParameters\nap   -   an instance of the va_list type to clean up\n\n\nExpanded value\n   (none).\n", "url": "https://devdocs.io/c/variadic/va_end\n"}, {"name": "va_list", "type": "STANDARD LIB", "description": "/* unspecified */ va_list;\n\n   va_list is a complete object type suitable for holding the information needed by the macros va_start, va_copy, va_arg, and va_end.\n   If a va_list instance is created, passed to another function, and used via va_arg in that function, then any subsequent use in the calling function should be preceded by a call to va_end.\n   It is legal to pass a pointer to a va_list object to another function and then use that object after the function returns.\n", "url": "https://devdocs.io/c/variadic/va_list\n"}, {"name": "va_start", "type": "STANDARD LIB", "description": "Defined in header <stdarg.h>\nvoid va_start( va_list ap, parmN );\n\n   The va_start macro enables access to the variable arguments following the named argument parmN.\n   va_start should be invoked with an instance to a valid va_list object ap before any calls to va_arg.\n   If parmN is declared with register storage class specifier, with an array type, with a function type, or with a type not compatible with the type that results from default argument promotions, the behavior is undefined.\n\nParameters\nap   -   an instance of the va_list type\nparmN   -   the named parameter preceding the first variable parameter\n\n\nExpanded value\n   (none).\n", "url": "https://devdocs.io/c/variadic/va_start"}, {"name": "acl", "type": " Operating system", "description": " Access control", "url": "https://savannah.nongnu.org/projects/acl/"}, {"name": "apparmor", "type": " Operating system", "description": " Access control", "url": "https://apparmor.net/"}, {"name": "attr", "type": " Operating system", "description": " Extended attributes", "url": "https://savannah.nongnu.org/projects/attr/"}, {"name": "IUP", "type": " Graphic user interface", "description": "", "url": "http://www.tecgraf.puc-rio.br/iup/"}, {"name": "tiny file dialogs", "type": " Graphic user interface", "description": "a single C cross-platform file (no init, no main loop, 6 modal function calls)", "url": "https://sourceforge.net/projects/tinyfiledialogs/"}, {"name": "gtk+", "type": " Gtk+ widgets", "description": "", "url": "https://www.gtk.org/"}, {"name": "appmenu-gtk", "type": " Gtk+ widgets", "description": "", "url": "https://launchpad.net/appmenu-gtk"}, {"name": "ghex", "type": " Gtk+ widgets", "description": "", "url": "https://wiki.gnome.org/Apps/Ghex"}, {"name": "gtkspell", "type": " Gtk+ widgets", "description": "", "url": "http://gtkspell.sourceforge.net/"}, {"name": "gtksourceview", "type": " Gtk+ widgets", "description": "", "url": "https://wiki.gnome.org/Projects/GtkSourceView"}, {"name": "gtkhotkey", "type": " Gtk+ widgets", "description": "", "url": "https://launchpad.net/gtkhotkey"}, {"name": "gucharmap", "type": " Gtk+ widgets", "description": "", "url": "https://wiki.gnome.org/Apps/Gucharmap"}, {"name": "goocanvas", "type": " Gtk+ widgets", "description": "", "url": "https://wiki.gnome.org/Projects/GooCanvas"}, {"name": "webkitgtk", "type": " Gtk+ widgets", "description": "", "url": "https://www.webkitgtk.org/"}, {"name": "libxlsxwriter", "type": " Microsoft Excel", "description": "", "url": "https://libxlsxwriter.github.io/"}, {"name": "xlsx_drone", "type": " Microsoft Excel", "description": "", "url": "https://github.com/damian-m-g/xlsx_drone"}, {"name": "aften", "type": " Audio", "description": " Codecs", "url": "http://aften.sourceforge.net/"}, {"name": "faad2", "type": " Audio", "description": " Codecs", "url": "http://www.audiocoding.com/"}, {"name": "wavpack", "type": " Audio", "description": " Codecs", "url": "http://www.wavpack.com"}, {"name": "alsa-lib", "type": " Audio", "description": " Infrastructure", "url": "https://www.alsa-project.org/wiki/Main_Page"}, {"name": "portaudio", "type": " Audio", "description": " Infrastructure", "url": "http://www.portaudio.com/"}, {"name": "cdparanoia", "type": " Audio", "description": " CD", "url": "https://www.xiph.org/paranoia/"}, {"name": "espeak", "type": " Audio", "description": "Speech synthesis", "url": "http://espeak.sourceforge.net/"}, {"name": "flite", "type": " Audio", "description": "Speech synthesis", "url": "http://www.festvox.org/flite/"}, {"name": "schroedinger", "type": " Video", "description": " Codecs", "url": "https://slackbuilds.org/repository/14.1/multimedia/schroedinger/"}, {"name": "video4linux", "type": " Video", "description": " Codecs", "url": "https://linuxtv.org/downloads/v4l-utils/"}, {"name": "gmime", "type": " Files", "description": "", "url": "http://spruce.sourceforge.net/gmime/"}, {"name": "gsl", "type": " Maths", "description": "", "url": "https://www.gnu.org/software/gsl/"}, {"name": "argyll", "type": " Maths", "description": " Integer Multi-Dimensional Interpolation", "url": "http://www.argyllcms.com/"}, {"name": "atlas", "type": " Maths", "description": " Linear algebra", "url": "http://math-atlas.sourceforge.net/"}, {"name": "blas", "type": " Maths", "description": " Linear algebra", "url": "https://www.netlib.org/blas/"}, {"name": "eigen", "type": " Maths", "description": " Linear algebra", "url": "http://eigen.tuxfamily.org/index.php"}, {"name": "ta-lib", "type": " Maths", "description": " Finance", "url": "https://sourceforge.net/projects/ta-lib/"}, {"name": "fftw3", "type": " Maths", "description": " FFT", "url": "http://fftw.org"}, {"name": "gmp", "type": " Maths", "description": " Multiprecision", "url": "https://gmplib.org/"}, {"name": "liquid-dsp", "type": " Maths", "description": " Signal Processing", "url": "https://liquidsdr.org/"}, {"name": "vsipl", "type": " Maths", "description": " Signal Processing", "url": "https://www.omg.org/spec/VSIPL"}, {"name": "vsipl++", "type": " Maths", "description": " Signal Processing", "url": "https://www.omg.org/spec/VSIPL++"}, {"name": "cairo", "type": " Graphics", "description": "", "url": "https://www.cairographics.org/"}, {"name": "babl", "type": " Graphics", "description": "", "url": "http://gegl.org/babl/"}, {"name": "SAIL (Squirrel Abstract Image Library)", "type": " Graphics", "description": " small, fast, and cross-platform image decoding library.", "url": "https://github.com/smoked-herring/sail"}, {"name": "SDL (Simple DirectMedia Layer)", "type": " Graphics", "description": "a library for input, audio, drawing and much more supported by many platforms.", "url": "https://libsdl.org/"}, {"name": "SIGIL (Sound, Input, and Graphics Integration Library)", "type": " Graphics", "description": "", "url": "http://www.libsigil.com"}, {"name": "allegro 5 (Multimedia Library)", "type": " Graphics", "description": "a cross-platform library mainly aimed at video game and multimedia programming.", "url": "https://liballeg.org/index.html"}, {"name": "gdbus", "type": " Interprocess", "description": "", "url": "https://www.freedesktop.org/wiki/Software/DBusBindings/"}, {"name": "dbus", "type": " Interprocess", "description": "", "url": "https://www.freedesktop.org/wiki/Software/dbus/"}, {"name": "dee", "type": " Interprocess", "description": "", "url": "https://launchpad.net/dee/"}, {"name": "berkeley db", "type": " Databases", "description": "", "url": "https://www.oracle.com/database/technologies/related/berkeleydb.html"}, {"name": "lmdb", "type": " Databases", "description": "", "url": "https://symas.com/lmdb/technical/"}, {"name": "libconfig", "type": " Configuration", "description": "", "url": "https://hyperrealm.github.io/libconfig"}, {"name": "libconfini", "type": " Configuration", "description": "", "url": "https://madmurphy.github.io/libconfini/html/index.html"}, {"name": "libXDGdirs", "type": " Environment", "description": "", "url": "https://github.com/Jorengarenar/libXDGdirs"}, {"name": "libcurl", "type": " Communications", "description": "", "url": "https://curl.haxx.se/libcurl/"}, {"name": "libmicrohttpd", "type": " Communications", "description": "", "url": "https://www.gnu.org/software/libmicrohttpd/"}, {"name": "libsagui", "type": " Communications", "description": "", "url": "https://risoflora.github.io/libsagui/"}, {"name": "gsoap", "type": " Communications", "description": "", "url": "https://www.genivia.com/dev.html"}, {"name": "zeromq", "type": " Communications", "description": "", "url": "https://zeromq.org/"}, {"name": "nanomsg", "type": " Communications", "description": "A socket library that provides common communication patterns; has no dependencies; cross-platform. Superceded by the nng. (MIT/X11 license)", "url": "https://nanomsg.org/"}, {"name": "MQTT-C", "type": " Communications", "description": "", "url": "https://liambindle.ca/MQTT-C/"}, {"name": "KCP", "type": " Communications", "description": "A fast and reliable ARQ protocol that helps applications to reduce network latency. (MIT License)", "url": "https://github.com/skywind3000/kcp/blob/master/README.en.md"}, {"name": "UCX", "type": " Communications", "description": "Unified Communication X (UCX) provides an optimized communication layer for Message Passing (MPI), Shared Memory (PGAS) and RPC/data-centric applications. (BSD3 License)", "url": "https://github.com/openucx/ucx"}, {"name": "bzip2", "type": " Compression", "description": "", "url": "http://www.bzip.org/"}, {"name": "lz4", "type": " Compression", "description": "", "url": "https://github.com/lz4/lz4"}, {"name": "zlib", "type": " Compression", "description": "", "url": "http://zlib.net/"}, {"name": "ck", "type": " Concurrency", "description": "", "url": "http://www.concurrencykit.org/"}, {"name": "MutexGear", "type": " Concurrency", "description": "Mutex-only synchronization (wheel, rwlock, work queues). (The MutexGear Library License)", "url": "https://github.com/oleh-derevenko/mutexgear"}, {"name": "eglibc", "type": " libc", "description": "", "url": "http://www.eglibc.org"}, {"name": "bstrlib", "type": " Data types", "description": "", "url": "http://bstring.sourceforge.net/"}, {"name": "datastd", "type": " Data types", "description": "", "url": "https://github.com/delphifeel/datastd"}, {"name": "str", "type": " Data types", "description": "Yet another string library for C language.", "url": "https://github.com/maxim2266/str"}, {"name": "expat", "type": " XML", "description": "", "url": "http://expat.sourceforge.net"}, {"name": "gsoap", "type": " XML", "description": "", "url": "http://gsoap2.sourceforge.net"}, {"name": "gjs", "type": " Javascript", "description": "", "url": "http://live.gnome.org/Gjs"}, {"name": "edlib", "type": " Metrics", "description": "", "url": "http://github.com/martinsos/edlib"}, {"name": "Cello", "type": " Object oriented programming", "description": "", "url": "http://libcello.org/"}, {"name": "cgit", "type": " Web Frontend", "description": "", "url": "http://git.zx2c4.com/cgit/about/"}]